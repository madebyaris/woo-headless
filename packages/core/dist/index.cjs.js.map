{"version":3,"file":"index.cjs.js","sources":["../src/types/result.ts","../src/types/errors.ts","../src/types/commerce.ts","../src/types/config.ts","../src/core/client.ts","../src/core/auth.ts","../src/core/config.ts","../src/core/cache.ts","../src/modules/products/index.ts","../src/types/cart.ts","../src/test/utils.ts","../src/modules/cart/sync.ts","../src/modules/cart/index.ts","../src/types/search.ts","../src/modules/search/index.ts","../src/types/user.ts","../src/modules/user/email-verification.ts","../src/modules/user/download-management.ts","../src/modules/user/index.ts","../src/modules/reviews/index.ts","../src/types/checkout.ts","../src/modules/checkout/address.ts","../src/modules/checkout/shipping.ts","../src/modules/checkout/payment.ts","../src/modules/checkout/validation.ts","../src/modules/checkout/flow.ts","../src/modules/checkout/order.ts","../src/modules/checkout/index.ts","../src/index.ts","../src/woo-headless.ts"],"sourcesContent":["/**\n * Result type for comprehensive error handling\n * Following the enhanced unified-10x-dev framework\n */\n\nexport interface Success<T> {\n  readonly success: true;\n  readonly data: T;\n}\n\nexport interface Failure<E> {\n  readonly success: false;\n  readonly error: E;\n}\n\nexport type Result<T, E> = Success<T> | Failure<E>;\n\n/**\n * Create a successful result\n */\nexport function Ok<T>(data: T): Success<T> {\n  return { success: true, data };\n}\n\n/**\n * Create a failed result\n */\nexport function Err<E>(error: E): Failure<E> {\n  return { success: false, error };\n}\n\n/**\n * Check if result is successful\n */\nexport function isOk<T, E>(result: Result<T, E>): result is Success<T> {\n  return result.success;\n}\n\n/**\n * Check if result is failed\n */\nexport function isErr<T, E>(result: Result<T, E>): result is Failure<E> {\n  return !result.success;\n}\n\n/**\n * Get data from successful result or throw\n */\nexport function unwrap<T, E>(result: Result<T, E>): T {\n  if (isOk(result)) {\n    return result.data;\n  }\n  throw new Error(`Called unwrap on Err: ${JSON.stringify(result.error)}`);\n}\n\n/**\n * Get error from failed result or throw\n */\nexport function unwrapErr<T, E>(result: Result<T, E>): E {\n  if (isErr(result)) {\n    return result.error;\n  }\n  throw new Error(`Called unwrapErr on Ok: ${JSON.stringify(result.data)}`);\n}\n\n/**\n * Get data from successful result or return default\n */\nexport function unwrapOr<T, E>(result: Result<T, E>, defaultValue: T): T {\n  return isOk(result) ? result.data : defaultValue;\n}\n\n/**\n * Map successful result to new type\n */\nexport function map<T, U, E>(\n  result: Result<T, E>,\n  fn: (data: T) => U\n): Result<U, E> {\n  return isOk(result) ? Ok(fn(result.data)) : result;\n}\n\n/**\n * Map error to new type\n */\nexport function mapErr<T, E, F>(\n  result: Result<T, E>,\n  fn: (error: E) => F\n): Result<T, F> {\n  return isErr(result) ? Err(fn(result.error)) : result;\n}\n\n/**\n * Chain operations on successful results\n */\nexport function andThen<T, U, E>(\n  result: Result<T, E>,\n  fn: (data: T) => Result<U, E>\n): Result<U, E> {\n  return isOk(result) ? fn(result.data) : result;\n} ","/**\n * WooCommerce Headless SDK Error Types\n * Following the enhanced unified-10x-dev framework\n */\n\n/**\n * Base error interface with mandatory fields\n */\nexport interface WooError {\n  readonly code: WooErrorCode;\n  readonly message: string;\n  readonly details?: unknown;\n  readonly timestamp: Date;\n  readonly statusCode?: number;\n  readonly retryable?: boolean;\n}\n\n/**\n * Specific error codes for different failure scenarios\n */\nexport type WooErrorCode =\n  | 'NETWORK_ERROR'\n  | 'AUTH_ERROR'\n  | 'VALIDATION_ERROR'\n  | 'API_ERROR'\n  | 'RATE_LIMIT_ERROR'\n  | 'TIMEOUT_ERROR'\n  | 'CONFIGURATION_ERROR'\n  | 'PRODUCT_NOT_FOUND'\n  | 'CART_ERROR'\n  | 'CHECKOUT_ERROR'\n  | 'PAYMENT_ERROR'\n  | 'SUBSCRIPTION_ERROR'\n  | 'CACHE_ERROR';\n\n/**\n * Network-related errors\n */\nexport class NetworkError extends Error implements WooError {\n  readonly code = 'NETWORK_ERROR' as const;\n  readonly timestamp: Date;\n  readonly retryable = true;\n  readonly statusCode?: number;\n\n  constructor(\n    message: string,\n    public readonly details?: unknown,\n    statusCode?: number\n  ) {\n    super(message);\n    this.name = 'NetworkError';\n    this.timestamp = new Date();\n    if (statusCode !== undefined) {\n      this.statusCode = statusCode;\n    }\n  }\n}\n\n/**\n * Authentication and authorization errors\n */\nexport class AuthError extends Error implements WooError {\n  readonly code = 'AUTH_ERROR' as const;\n  readonly timestamp: Date;\n  readonly retryable = false;\n  readonly statusCode?: number;\n\n  constructor(\n    message: string,\n    public readonly details?: unknown,\n    statusCode?: number\n  ) {\n    super(message);\n    this.name = 'AuthError';\n    this.timestamp = new Date();\n    if (statusCode !== undefined) {\n      this.statusCode = statusCode;\n    }\n  }\n}\n\n/**\n * Input validation errors\n */\nexport class ValidationError extends Error implements WooError {\n  readonly code = 'VALIDATION_ERROR' as const;\n  readonly timestamp: Date;\n  readonly retryable = false;\n\n  constructor(\n    message: string,\n    public readonly details?: unknown\n  ) {\n    super(message);\n    this.name = 'ValidationError';\n    this.timestamp = new Date();\n  }\n}\n\n/**\n * API-related errors from WooCommerce\n */\nexport class ApiError extends Error implements WooError {\n  readonly code = 'API_ERROR' as const;\n  readonly timestamp: Date;\n  readonly retryable: boolean;\n\n  constructor(\n    message: string,\n    public readonly statusCode: number,\n    public readonly details?: unknown\n  ) {\n    super(message);\n    this.name = 'ApiError';\n    this.timestamp = new Date();\n    // Retry on 5xx errors, not on 4xx\n    this.retryable = statusCode >= 500;\n  }\n}\n\n/**\n * Rate limiting errors\n */\nexport class RateLimitError extends Error implements WooError {\n  readonly code = 'RATE_LIMIT_ERROR' as const;\n  readonly timestamp: Date;\n  readonly retryable = true;\n\n  constructor(\n    message: string,\n    public readonly retryAfter?: number,\n    public readonly details?: unknown\n  ) {\n    super(message);\n    this.name = 'RateLimitError';\n    this.timestamp = new Date();\n  }\n}\n\n/**\n * Timeout errors\n */\nexport class TimeoutError extends Error implements WooError {\n  readonly code = 'TIMEOUT_ERROR' as const;\n  readonly timestamp: Date;\n  readonly retryable = true;\n\n  constructor(\n    message: string,\n    public readonly timeout: number,\n    public readonly details?: unknown\n  ) {\n    super(message);\n    this.name = 'TimeoutError';\n    this.timestamp = new Date();\n  }\n}\n\n/**\n * Configuration errors\n */\nexport class ConfigurationError extends Error implements WooError {\n  readonly code = 'CONFIGURATION_ERROR' as const;\n  readonly timestamp: Date;\n  readonly retryable = false;\n\n  constructor(\n    message: string,\n    public readonly details?: unknown\n  ) {\n    super(message);\n    this.name = 'ConfigurationError';\n    this.timestamp = new Date();\n  }\n}\n\n/**\n * Product-specific errors\n */\nexport class ProductNotFoundError extends Error implements WooError {\n  readonly code = 'PRODUCT_NOT_FOUND' as const;\n  readonly timestamp: Date;\n  readonly retryable = false;\n\n  constructor(\n    public readonly productId: number | string,\n    public readonly details?: unknown\n  ) {\n    super(`Product with ID ${productId} not found`);\n    this.name = 'ProductNotFoundError';\n    this.timestamp = new Date();\n  }\n}\n\n/**\n * Cart-related errors\n */\nexport class CartError extends Error implements WooError {\n  readonly code = 'CART_ERROR' as const;\n  readonly timestamp: Date;\n  readonly retryable = false;\n\n  constructor(\n    message: string,\n    public readonly details?: unknown\n  ) {\n    super(message);\n    this.name = 'CartError';\n    this.timestamp = new Date();\n  }\n}\n\n/**\n * Checkout process errors\n */\nexport class CheckoutError extends Error implements WooError {\n  readonly code = 'CHECKOUT_ERROR' as const;\n  readonly timestamp: Date;\n  readonly retryable = false;\n\n  constructor(\n    message: string,\n    public readonly details?: unknown\n  ) {\n    super(message);\n    this.name = 'CheckoutError';\n    this.timestamp = new Date();\n  }\n}\n\n/**\n * Payment processing errors\n */\nexport class PaymentError extends Error implements WooError {\n  readonly code = 'PAYMENT_ERROR' as const;\n  readonly timestamp: Date;\n  readonly retryable = false;\n  readonly statusCode?: number;\n\n  constructor(\n    message: string,\n    public readonly details?: unknown,\n    statusCode?: number\n  ) {\n    super(message);\n    this.name = 'PaymentError';\n    this.timestamp = new Date();\n    if (statusCode !== undefined) {\n      this.statusCode = statusCode;\n    }\n  }\n}\n\n/**\n * Error factory for creating typed errors\n */\nexport class ErrorFactory {\n  static networkError(message: string, details?: unknown, statusCode?: number): NetworkError {\n    return new NetworkError(message, details, statusCode);\n  }\n\n  static authError(message: string, details?: unknown, statusCode?: number): AuthError {\n    return new AuthError(message, details, statusCode);\n  }\n\n  static validationError(message: string, details?: unknown): ValidationError {\n    return new ValidationError(message, details);\n  }\n\n  static apiError(message: string, statusCode: number, details?: unknown): ApiError {\n    return new ApiError(message, statusCode, details);\n  }\n\n  static rateLimitError(message: string, retryAfter?: number, details?: unknown): RateLimitError {\n    return new RateLimitError(message, retryAfter, details);\n  }\n\n  static timeoutError(message: string, timeout: number, details?: unknown): TimeoutError {\n    return new TimeoutError(message, timeout, details);\n  }\n\n  static configurationError(message: string, details?: unknown): ConfigurationError {\n    return new ConfigurationError(message, details);\n  }\n\n  static productNotFoundError(productId: number | string, details?: unknown): ProductNotFoundError {\n    return new ProductNotFoundError(productId, details);\n  }\n\n  static cartError(message: string, details?: unknown): CartError {\n    return new CartError(message, details);\n  }\n\n  static checkoutError(message: string, details?: unknown): CheckoutError {\n    return new CheckoutError(message, details);\n  }\n\n  static paymentError(message: string, details?: unknown, statusCode?: number): PaymentError {\n    return new PaymentError(message, details, statusCode);\n  }\n\n  static cacheError(message: string, details?: unknown): CacheError {\n    return new CacheError(message, details);\n  }\n\n  static notImplementedError(message: string, details?: unknown): ConfigurationError {\n    return new ConfigurationError(`Not implemented: ${message}`, details);\n  }\n\n  static persistenceError(message: string, details?: unknown): CacheError {\n    return new CacheError(`Persistence error: ${message}`, details);\n  }\n}\n\n/**\n * Cache-related errors\n */\nexport class CacheError extends Error implements WooError {\n  readonly code = 'CACHE_ERROR' as const;\n  readonly timestamp: Date;\n  readonly retryable = false;\n\n  constructor(\n    message: string,\n    public readonly details?: unknown\n  ) {\n    super(message);\n    this.name = 'CacheError';\n    this.timestamp = new Date();\n  }\n}\n\n/**\n * Type guard for WooError\n */\nexport function isWooError(error: unknown): error is WooError {\n  return (\n    error !== null &&\n    typeof error === 'object' &&\n    'code' in error &&\n    'message' in error &&\n    'timestamp' in error\n  );\n} ","/**\n * WooCommerce API Types\n * Following the WooCommerce REST API v3 specification\n */\n\nimport { z } from 'zod';\n\n/**\n * Product status enumeration\n */\nexport type ProductStatus = 'draft' | 'pending' | 'private' | 'publish';\n\n/**\n * Product catalog visibility\n */\nexport type ProductCatalogVisibility = 'visible' | 'catalog' | 'search' | 'hidden';\n\n/**\n * Product type enumeration\n */\nexport type ProductType = 'simple' | 'grouped' | 'external' | 'variable';\n\n/**\n * Order status enumeration\n */\nexport type OrderStatus =\n  | 'pending'\n  | 'processing'\n  | 'on-hold'\n  | 'completed'\n  | 'cancelled'\n  | 'refunded'\n  | 'failed'\n  | 'trash';\n\n/**\n * Image dimensions\n */\nexport interface ImageDimensions {\n  readonly width: number;\n  readonly height: number;\n}\n\n/**\n * Product image interface\n */\nexport interface ProductImage {\n  readonly id: number;\n  readonly date_created: string;\n  readonly date_created_gmt: string;\n  readonly date_modified: string;\n  readonly date_modified_gmt: string;\n  readonly src: string;\n  readonly name: string;\n  readonly alt: string;\n  readonly position: number;\n}\n\n/**\n * Product category interface\n */\nexport interface ProductCategory {\n  readonly id: number;\n  readonly name: string;\n  readonly slug: string;\n}\n\n/**\n * Product tag interface\n */\nexport interface ProductTag {\n  readonly id: number;\n  readonly name: string;\n  readonly slug: string;\n}\n\n/**\n * Product attribute interface\n */\nexport interface ProductAttribute {\n  readonly id: number;\n  readonly name: string;\n  readonly position: number;\n  readonly visible: boolean;\n  readonly variation: boolean;\n  readonly options: readonly string[];\n}\n\n/**\n * Price range for variable products\n */\nexport interface PriceRange {\n  readonly min: string;\n  readonly max: string;\n}\n\n/**\n * Product dimensions\n */\nexport interface ProductDimensions {\n  readonly length: string;\n  readonly width: string;\n  readonly height: string;\n}\n\n/**\n * Meta data interface\n */\nexport interface MetaData {\n  readonly id: number;\n  readonly key: string;\n  readonly value: string;\n}\n\n/**\n * Core product interface matching WooCommerce API\n */\nexport interface WooCommerceProduct {\n  readonly id: number;\n  readonly name: string;\n  readonly slug: string;\n  readonly permalink: string;\n  readonly date_created: string;\n  readonly date_created_gmt: string;\n  readonly date_modified: string;\n  readonly date_modified_gmt: string;\n  readonly type: ProductType;\n  readonly status: ProductStatus;\n  readonly featured: boolean;\n  readonly catalog_visibility: ProductCatalogVisibility;\n  readonly description: string;\n  readonly short_description: string;\n  readonly sku: string;\n  readonly price: string;\n  readonly regular_price: string;\n  readonly sale_price: string;\n  readonly date_on_sale_from?: string;\n  readonly date_on_sale_from_gmt?: string;\n  readonly date_on_sale_to?: string;\n  readonly date_on_sale_to_gmt?: string;\n  readonly price_html: string;\n  readonly on_sale: boolean;\n  readonly purchasable: boolean;\n  readonly total_sales: number;\n  readonly virtual: boolean;\n  readonly downloadable: boolean;\n  readonly downloads: readonly unknown[];\n  readonly download_limit: number;\n  readonly download_expiry: number;\n  readonly external_url: string;\n  readonly button_text: string;\n  readonly tax_status: 'taxable' | 'shipping' | 'none';\n  readonly tax_class: string;\n  readonly manage_stock: boolean;\n  readonly stock_quantity?: number;\n  readonly stock_status: 'instock' | 'outofstock' | 'onbackorder';\n  readonly backorders: 'no' | 'notify' | 'yes';\n  readonly backorders_allowed: boolean;\n  readonly backordered: boolean;\n  readonly sold_individually: boolean;\n  readonly weight: string;\n  readonly dimensions: ProductDimensions;\n  readonly shipping_required: boolean;\n  readonly shipping_taxable: boolean;\n  readonly shipping_class: string;\n  readonly shipping_class_id: number;\n  readonly reviews_allowed: boolean;\n  readonly average_rating: string;\n  readonly rating_count: number;\n  readonly related_ids: readonly number[];\n  readonly upsell_ids: readonly number[];\n  readonly cross_sell_ids: readonly number[];\n  readonly parent_id: number;\n  readonly purchase_note: string;\n  readonly categories: readonly ProductCategory[];\n  readonly tags: readonly ProductTag[];\n  readonly images: readonly ProductImage[];\n  readonly attributes: readonly ProductAttribute[];\n  readonly default_attributes: readonly unknown[];\n  readonly variations: readonly number[];\n  readonly grouped_products: readonly number[];\n  readonly menu_order: number;\n  readonly meta_data: readonly MetaData[];\n}\n\n/**\n * Product variation interface\n */\nexport interface ProductVariation {\n  readonly id: number;\n  readonly date_created: string;\n  readonly date_created_gmt: string;\n  readonly date_modified: string;\n  readonly date_modified_gmt: string;\n  readonly description: string;\n  readonly permalink: string;\n  readonly sku: string;\n  readonly price: string;\n  readonly regular_price: string;\n  readonly sale_price: string;\n  readonly date_on_sale_from?: string;\n  readonly date_on_sale_from_gmt?: string;\n  readonly date_on_sale_to?: string;\n  readonly date_on_sale_to_gmt?: string;\n  readonly on_sale: boolean;\n  readonly status: ProductStatus;\n  readonly purchasable: boolean;\n  readonly virtual: boolean;\n  readonly downloadable: boolean;\n  readonly downloads: readonly unknown[];\n  readonly download_limit: number;\n  readonly download_expiry: number;\n  readonly tax_status: 'taxable' | 'shipping' | 'none';\n  readonly tax_class: string;\n  readonly manage_stock: boolean;\n  readonly stock_quantity?: number;\n  readonly stock_status: 'instock' | 'outofstock' | 'onbackorder';\n  readonly backorders: 'no' | 'notify' | 'yes';\n  readonly backorders_allowed: boolean;\n  readonly backordered: boolean;\n  readonly weight: string;\n  readonly dimensions: ProductDimensions;\n  readonly shipping_class: string;\n  readonly shipping_class_id: number;\n  readonly image: ProductImage;\n  readonly attributes: readonly ProductAttribute[];\n  readonly menu_order: number;\n  readonly meta_data: readonly MetaData[];\n}\n\n/**\n * Billing address interface\n */\nexport interface BillingAddress {\n  readonly first_name: string;\n  readonly last_name: string;\n  readonly company: string;\n  readonly address_1: string;\n  readonly address_2: string;\n  readonly city: string;\n  readonly state: string;\n  readonly postcode: string;\n  readonly country: string;\n  readonly email: string;\n  readonly phone: string;\n}\n\n/**\n * Shipping address interface\n */\nexport interface ShippingAddress {\n  readonly first_name: string;\n  readonly last_name: string;\n  readonly company: string;\n  readonly address_1: string;\n  readonly address_2: string;\n  readonly city: string;\n  readonly state: string;\n  readonly postcode: string;\n  readonly country: string;\n}\n\n/**\n * Order line item interface\n */\nexport interface OrderLineItem {\n  readonly id: number;\n  readonly name: string;\n  readonly product_id: number;\n  readonly variation_id: number;\n  readonly quantity: number;\n  readonly tax_class: string;\n  readonly subtotal: string;\n  readonly subtotal_tax: string;\n  readonly total: string;\n  readonly total_tax: string;\n  readonly taxes: readonly unknown[];\n  readonly meta_data: readonly MetaData[];\n  readonly sku: string;\n  readonly price: string;\n}\n\n/**\n * Order interface\n */\nexport interface WooCommerceOrder {\n  readonly id: number;\n  readonly parent_id: number;\n  readonly status: OrderStatus;\n  readonly currency: string;\n  readonly version: string;\n  readonly prices_include_tax: boolean;\n  readonly date_created: string;\n  readonly date_modified: string;\n  readonly discount_total: string;\n  readonly discount_tax: string;\n  readonly shipping_total: string;\n  readonly shipping_tax: string;\n  readonly cart_tax: string;\n  readonly total: string;\n  readonly total_tax: string;\n  readonly customer_id: number;\n  readonly order_key: string;\n  readonly billing: BillingAddress;\n  readonly shipping: ShippingAddress;\n  readonly payment_method: string;\n  readonly payment_method_title: string;\n  readonly transaction_id: string;\n  readonly customer_ip_address: string;\n  readonly customer_user_agent: string;\n  readonly created_via: string;\n  readonly customer_note: string;\n  readonly date_completed?: string;\n  readonly date_paid?: string;\n  readonly cart_hash: string;\n  readonly number: string;\n  readonly meta_data: readonly MetaData[];\n  readonly line_items: readonly OrderLineItem[];\n  readonly tax_lines: readonly unknown[];\n  readonly shipping_lines: readonly unknown[];\n  readonly fee_lines: readonly unknown[];\n  readonly coupon_lines: readonly unknown[];\n  readonly refunds: readonly unknown[];\n  readonly set_paid: boolean;\n}\n\n/**\n * Customer interface\n */\nexport interface WooCommerceCustomer {\n  readonly id: number;\n  readonly date_created: string;\n  readonly date_created_gmt: string;\n  readonly date_modified: string;\n  readonly date_modified_gmt: string;\n  readonly email: string;\n  readonly first_name: string;\n  readonly last_name: string;\n  readonly role: string;\n  readonly username: string;\n  readonly billing: BillingAddress;\n  readonly shipping: ShippingAddress;\n  readonly is_paying_customer: boolean;\n  readonly avatar_url: string;\n  readonly meta_data: readonly MetaData[];\n}\n\n/**\n * WooCommerce coupon interface following REST API v3\n */\nexport interface WooCommerceCoupon {\n  readonly id: number;\n  readonly code: string;\n  readonly amount: string;\n  readonly date_created: string;\n  readonly date_created_gmt: string;\n  readonly date_modified: string;\n  readonly date_modified_gmt: string;\n  readonly discount_type: 'percent' | 'fixed_cart' | 'fixed_product';\n  readonly description: string;\n  readonly date_expires?: string;\n  readonly date_expires_gmt?: string;\n  readonly usage_count: number;\n  readonly individual_use: boolean;\n  readonly product_ids: readonly number[];\n  readonly excluded_product_ids: readonly number[];\n  readonly usage_limit?: number;\n  readonly usage_limit_per_user?: number;\n  readonly limit_usage_to_x_items?: number;\n  readonly free_shipping: boolean;\n  readonly product_categories: readonly number[];\n  readonly excluded_product_categories: readonly number[];\n  readonly exclude_sale_items: boolean;\n  readonly minimum_amount: string;\n  readonly maximum_amount: string;\n  readonly email_restrictions: readonly string[];\n  readonly used_by: readonly string[];\n  readonly meta_data: readonly MetaData[];\n}\n\n/**\n * Zod schemas for validation\n */\nexport const ProductSchema = z.object({\n  id: z.number(),\n  name: z.string(),\n  slug: z.string(),\n  status: z.enum(['draft', 'pending', 'private', 'publish']),\n  featured: z.boolean(),\n  catalog_visibility: z.enum(['visible', 'catalog', 'search', 'hidden']),\n  description: z.string(),\n  short_description: z.string(),\n  price: z.string(),\n  regular_price: z.string(),\n  sale_price: z.string(),\n  on_sale: z.boolean(),\n  stock_status: z.enum(['instock', 'outofstock', 'onbackorder']),\n  manage_stock: z.boolean(),\n  stock_quantity: z.number().optional(),\n  categories: z.array(z.object({\n    id: z.number(),\n    name: z.string(),\n    slug: z.string()\n  })),\n  images: z.array(z.object({\n    id: z.number(),\n    src: z.string(),\n    name: z.string(),\n    alt: z.string()\n  }))\n});\n\nexport const OrderSchema = z.object({\n  id: z.number(),\n  status: z.enum(['pending', 'processing', 'on-hold', 'completed', 'cancelled', 'refunded', 'failed', 'trash']),\n  currency: z.string(),\n  total: z.string(),\n  customer_id: z.number(),\n  billing: z.object({\n    first_name: z.string(),\n    last_name: z.string(),\n    email: z.string(),\n    phone: z.string()\n  }),\n  line_items: z.array(z.object({\n    id: z.number(),\n    name: z.string(),\n    product_id: z.number(),\n    quantity: z.number(),\n    total: z.string()\n  }))\n});\n\n/**\n * Type guards\n */\nexport function isWooCommerceProduct(data: unknown): data is WooCommerceProduct {\n  try {\n    ProductSchema.parse(data);\n    return true;\n  } catch {\n    return false;\n  }\n}\n\nexport function isWooCommerceOrder(data: unknown): data is WooCommerceOrder {\n  try {\n    OrderSchema.parse(data);\n    return true;\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Type guard for WooCommerceCoupon\n */\nexport function isWooCommerceCoupon(data: unknown): data is WooCommerceCoupon {\n  return typeof data === 'object' && data !== null && \n    'id' in data && 'code' in data && 'amount' in data && 'discount_type' in data;\n} ","/**\n * Configuration types for WooCommerce Headless SDK\n * Following the enhanced unified-10x-dev framework\n */\n\nimport type { CheckoutConfig } from '../modules/checkout';\n\n/**\n * Cache storage types\n */\nexport type CacheStorageType = 'localStorage' | 'sessionStorage' | 'memory';\n\n/**\n * Log levels for debugging\n */\nexport type LogLevel = 'error' | 'warn' | 'info' | 'debug' | 'verbose';\n\n/**\n * Environment types\n */\nexport type Environment = 'development' | 'staging' | 'production';\n\n/**\n * Cache configuration\n */\nexport interface CacheConfig {\n  readonly enabled: boolean;\n  readonly ttl: number; // Time to live in milliseconds\n  readonly storage: CacheStorageType;\n  readonly maxSize?: number; // Maximum cache size in MB\n  readonly prefix?: string; // Cache key prefix\n}\n\n/**\n * JWT Authentication configuration\n */\nexport interface JWTConfig {\n  readonly enabled: boolean;\n  readonly secretKey?: string;\n  readonly expiresIn: number; // Token expiration in seconds\n  readonly autoRefresh: boolean;\n  readonly refreshThreshold?: number; // Refresh when X seconds before expiry\n}\n\n/**\n * HTTP client configuration\n */\nexport interface HttpConfig {\n  readonly timeout: number; // Request timeout in milliseconds\n  readonly retries: number; // Number of retry attempts\n  readonly retryDelay: number; // Base delay between retries in milliseconds\n  readonly maxRetryDelay: number; // Maximum retry delay\n  readonly retryCondition?: (error: unknown) => boolean;\n  readonly headers?: Record<string, string>; // Additional headers\n}\n\n/**\n * Search configuration\n */\nexport interface SearchConfig {\n  readonly fuzzyThreshold: number; // Fuse.js threshold (0.0 = exact, 1.0 = anything)\n  readonly maxResults: number; // Maximum search results\n  readonly enableHighlight: boolean;\n  readonly enableSuggestions: boolean;\n  readonly cacheResults: boolean;\n  readonly enableAnalytics: boolean;\n}\n\n/**\n * Advanced search configuration\n */\nexport interface AdvancedSearchConfig {\n  readonly fuzzy: {\n    readonly enabled: boolean;\n    readonly threshold: number; // 0.0 = exact match, 1.0 = match anything\n    readonly distance: number; // maximum Levenshtein distance\n    readonly minMatchCharLength: number;\n    readonly includeScore: boolean;\n  };\n  readonly highlighting: {\n    readonly enabled: boolean;\n    readonly preTag: string;\n    readonly postTag: string;\n    readonly fragmentSize: number;\n    readonly maxFragments: number;\n  };\n  readonly suggestions: {\n    readonly enabled: boolean;\n    readonly maxSuggestions: number;\n    readonly minQueryLength: number;\n    readonly showPopular: boolean;\n    readonly showRecent: boolean;\n  };\n  readonly facets: {\n    readonly enabled: boolean;\n    readonly maxFacets: number;\n    readonly maxFacetValues: number;\n    readonly minDocumentCount: number;\n  };\n  readonly analytics: {\n    readonly enabled: boolean;\n    readonly trackQueries: boolean;\n    readonly trackFilters: boolean;\n    readonly trackClicks: boolean;\n    readonly trackConversions: boolean;\n    readonly sessionTimeout: number; // minutes\n  };\n  readonly caching: {\n    readonly enabled: boolean;\n    readonly ttl: number; // milliseconds\n    readonly maxCacheSize: number; // number of cached queries\n    readonly cacheKey: string;\n  };\n  readonly performance: {\n    readonly maxResults: number;\n    readonly searchTimeout: number; // milliseconds\n    readonly debounceDelay: number; // milliseconds for auto-complete\n    readonly prefetchResults: boolean;\n  };\n}\n\n/**\n * Analytics configuration\n */\nexport interface AnalyticsConfig {\n  readonly enabled: boolean;\n  readonly trackPageViews: boolean;\n  readonly trackSearches: boolean;\n  readonly trackConversions: boolean;\n  readonly apiKey?: string;\n  readonly endpoint?: string;\n}\n\n/**\n * Internationalization configuration\n */\nexport interface I18nConfig {\n  readonly locale: string; // e.g., 'en-US', 'fr-FR'\n  readonly currency: string; // e.g., 'USD', 'EUR'\n  readonly timezone: string; // e.g., 'America/New_York'\n  readonly dateFormat: string;\n  readonly numberFormat: Intl.NumberFormatOptions;\n}\n\n/**\n * Development/debugging configuration\n */\nexport interface DebugConfig {\n  readonly enabled: boolean;\n  readonly logLevel: LogLevel;\n  readonly performanceMonitoring: boolean;\n  readonly errorReporting: boolean;\n  readonly apiLogging: boolean;\n}\n\n/**\n * Cart persistence options\n */\nexport interface CartPersistenceConfig {\n  readonly strategy: 'localStorage' | 'sessionStorage' | 'indexedDB' | 'server' | 'none';\n  readonly key?: string;\n  readonly encryption?: boolean;\n  readonly expirationDays?: number;\n  readonly syncToServer?: boolean;\n}\n\n/**\n * Cart synchronization configuration\n */\nexport interface CartSyncConfig {\n  readonly enabled: boolean;\n  readonly strategy: 'merge_smart' | 'local_wins' | 'server_wins' | 'merge_quantities' | 'prompt_user';\n  readonly syncIntervalMs: number;        // Auto-sync interval in milliseconds\n  readonly conflictResolution: 'merge_smart' | 'local_wins' | 'server_wins' | 'merge_quantities' | 'prompt_user';\n  readonly maxRetries: number;\n  readonly retryDelayMs: number;\n  readonly syncOnAuth: boolean;           // Sync immediately when user authenticates\n  readonly syncOnCartChange: boolean;     // Sync on every cart modification\n  readonly backgroundSync: boolean;       // Enable background sync\n  readonly offlineQueueSize: number;      // Max offline actions to queue\n}\n\n/**\n * Cart configuration\n */\nexport interface CartConfig {\n  readonly persistence: CartPersistenceConfig;\n  readonly sync: CartSyncConfig;\n  readonly autoCalculateTotals: boolean;\n  readonly validateStock: boolean;\n  readonly allowBackorders: boolean;\n  readonly sessionTimeout: number; // minutes\n  readonly maxItems: number;\n  readonly maxQuantityPerItem: number;\n  readonly enableCoupons: boolean;\n  readonly enableShipping: boolean;\n  readonly enableFees: boolean;\n  readonly enableCrossSells: boolean;\n  readonly taxCalculation: {\n    readonly enabled: boolean;\n    readonly pricesIncludeTax: boolean;\n    readonly displayMode: 'incl' | 'excl' | 'both';\n    readonly roundAtSubtotal: boolean;\n  };\n}\n\n/**\n * User sync configuration\n */\nexport interface UserSyncConfig {\n  readonly enabled: boolean;\n  readonly syncInterval: number; // Sync interval in seconds\n  readonly syncOnLogin: boolean;\n  readonly syncProfile: boolean;\n  readonly syncAddresses: boolean;\n  readonly syncPreferences: boolean;\n  readonly syncOrderHistory: boolean;\n  readonly syncWishlist: boolean;\n  readonly maxOrderHistory: number; // Maximum orders to sync\n  readonly cacheUserData: boolean;\n  readonly cacheTtl: number; // Cache TTL in milliseconds\n}\n\n/**\n * Main WooCommerce configuration\n */\nexport interface WooConfig {\n  readonly baseURL: string;\n  readonly consumerKey: string;\n  readonly consumerSecret: string;\n  readonly version?: string; // API version, defaults to 'wc/v3'\n  readonly environment?: Environment;\n  readonly cache?: Partial<CacheConfig>;\n  readonly auth?: Partial<JWTConfig>;\n  readonly http?: Partial<HttpConfig>;\n  readonly search?: Partial<SearchConfig>;\n  readonly advancedSearch?: Partial<AdvancedSearchConfig>;\n  readonly analytics?: Partial<AnalyticsConfig>;\n  readonly i18n?: Partial<I18nConfig>;\n  readonly debug?: Partial<DebugConfig>;\n  readonly cart?: Partial<CartConfig>;\n  readonly userSync?: Partial<UserSyncConfig>;\n  readonly checkout?: Partial<CheckoutConfig>;\n}\n\n/**\n * Resolved configuration with defaults applied\n */\nexport interface ResolvedWooConfig {\n  readonly baseURL: string;\n  readonly consumerKey: string;\n  readonly consumerSecret: string;\n  readonly version: string;\n  readonly environment: Environment;\n  readonly cache: CacheConfig;\n  readonly auth: JWTConfig;\n  readonly http: HttpConfig;\n  readonly search: SearchConfig;\n  readonly advancedSearch: AdvancedSearchConfig;\n  readonly analytics: AnalyticsConfig;\n  readonly i18n: I18nConfig;\n  readonly debug: DebugConfig;\n  readonly cart: CartConfig;\n  readonly userSync: UserSyncConfig;\n  readonly checkout: CheckoutConfig;\n}\n\n/**\n * Default configuration values\n */\nexport const DEFAULT_CONFIG: Omit<ResolvedWooConfig, 'baseURL' | 'consumerKey' | 'consumerSecret'> = {\n  version: 'wc/v3',\n  environment: 'production',\n  cache: {\n    enabled: true,\n    ttl: 300000, // 5 minutes\n    storage: 'localStorage',\n    maxSize: 50, // 50MB\n    prefix: 'woo-headless'\n  },\n  auth: {\n    enabled: false,\n    expiresIn: 3600, // 1 hour\n    autoRefresh: true,\n    refreshThreshold: 300 // 5 minutes\n  },\n  http: {\n    timeout: 30000, // 30 seconds\n    retries: 3,\n    retryDelay: 1000, // 1 second\n    maxRetryDelay: 10000, // 10 seconds\n    retryCondition: (error: unknown) => {\n      // Retry on network errors and 5xx status codes\n      return error instanceof Error && (\n        error.message.includes('network') ||\n        error.message.includes('timeout') ||\n        error.message.includes('5')\n      );\n    }\n  },\n  search: {\n    fuzzyThreshold: 0.3,\n    maxResults: 50,\n    enableHighlight: true,\n    enableSuggestions: true,\n    cacheResults: true,\n    enableAnalytics: false\n  },\n  advancedSearch: {\n    fuzzy: {\n      enabled: true,\n      threshold: 0.3,\n      distance: 100,\n      minMatchCharLength: 1,\n      includeScore: true\n    },\n    highlighting: {\n      enabled: true,\n      preTag: '<mark>',\n      postTag: '</mark>',\n      fragmentSize: 150,\n      maxFragments: 3\n    },\n    suggestions: {\n      enabled: true,\n      maxSuggestions: 10,\n      minQueryLength: 2,\n      showPopular: true,\n      showRecent: true\n    },\n    facets: {\n      enabled: true,\n      maxFacets: 10,\n      maxFacetValues: 20,\n      minDocumentCount: 1\n    },\n    analytics: {\n      enabled: false,\n      trackQueries: true,\n      trackFilters: true,\n      trackClicks: true,\n      trackConversions: false,\n      sessionTimeout: 30\n    },\n    caching: {\n      enabled: true,\n      ttl: 300000, // 5 minutes\n      maxCacheSize: 100,\n      cacheKey: 'woo-search'\n    },\n    performance: {\n      maxResults: 1000,\n      searchTimeout: 5000, // 5 seconds\n      debounceDelay: 300, // 300ms\n      prefetchResults: false\n    }\n  },\n  analytics: {\n    enabled: false,\n    trackPageViews: false,\n    trackSearches: false,\n    trackConversions: false\n  },\n  i18n: {\n    locale: 'en-US',\n    currency: 'USD',\n    timezone: 'UTC',\n    dateFormat: 'YYYY-MM-DD',\n    numberFormat: {\n      style: 'decimal',\n      minimumFractionDigits: 2,\n      maximumFractionDigits: 2\n    }\n  },\n  debug: {\n    enabled: false,\n    logLevel: 'error',\n    performanceMonitoring: false,\n    errorReporting: false,\n    apiLogging: false\n  },\n  cart: {\n    persistence: {\n      strategy: 'localStorage',\n      key: 'woo-headless-cart',\n      encryption: false,\n      expirationDays: 30,\n      syncToServer: false\n    },\n    sync: {\n      enabled: false,\n      strategy: 'merge_smart',\n      syncIntervalMs: 30000, // 30 seconds\n      conflictResolution: 'merge_smart',\n      maxRetries: 3,\n      retryDelayMs: 1000, // 1 second\n      syncOnAuth: true,\n      syncOnCartChange: false, // Avoid excessive syncing\n      backgroundSync: true,\n      offlineQueueSize: 50\n    },\n    autoCalculateTotals: true,\n    validateStock: true,\n    allowBackorders: false,\n    sessionTimeout: 60, // 60 minutes\n    maxItems: 100,\n    maxQuantityPerItem: 999,\n    enableCoupons: true,\n    enableShipping: true,\n    enableFees: true,\n    enableCrossSells: true,\n    taxCalculation: {\n      enabled: true,\n      pricesIncludeTax: false,\n      displayMode: 'excl',\n      roundAtSubtotal: false\n    }\n  },\n  userSync: {\n    enabled: false,\n    syncInterval: 300, // 5 minutes\n    syncOnLogin: true,\n    syncProfile: true,\n    syncAddresses: true,\n    syncPreferences: true,\n    syncOrderHistory: true,\n    syncWishlist: true,\n    maxOrderHistory: 50,\n    cacheUserData: true,\n    cacheTtl: 1800000 // 30 minutes\n  },\n  checkout: {\n    address: {\n      firstName: true,\n      lastName: true,\n      company: false,\n      address1: true,\n      address2: false,\n      city: true,\n      state: true,\n      postcode: true,\n      country: true,\n      email: true,\n      phone: false\n    },\n    shipping: {\n      enabled: true,\n      calculateTax: true,\n      defaultCountry: 'US',\n      restrictedCountries: [],\n      cacheTimeout: 15\n    },\n    payment: {\n      enabled: true,\n      testMode: true,\n      supportedMethods: ['stripe', 'paypal', 'bank_transfer', 'cash_on_delivery'],\n      minimumAmount: 1,\n      currency: 'USD',\n      returnUrl: '/checkout/payment/return',\n      cancelUrl: '/checkout/payment/cancel',\n      cacheTimeout: 10\n    },\n    flow: {\n      steps: ['billing_address', 'shipping_method', 'payment_method', 'order_review'],\n      allowSkipOptional: false,\n      persistSession: true,\n      sessionTimeout: 30,\n      autoAdvance: false,\n      validationRules: {\n        requireShippingAddress: true,\n        requireBillingAddress: true,\n        requirePhoneNumber: false,\n        requireCompanyName: false,\n        allowGuestCheckout: true,\n        minimumOrderAmount: 0,\n        restrictedCountries: [],\n        requiredFields: []\n      }\n    },\n    order: {\n      autoUpdateInventory: true,\n      sendConfirmationEmail: true,\n      requirePaymentConfirmation: true,\n      orderNumberPrefix: 'WOO-',\n      defaultStatus: 'pending',\n      inventoryHoldMinutes: 15,\n      cacheTimeout: 30\n    },\n    validation: {\n      requireShippingAddress: true,\n      requireBillingAddress: true,\n      requirePhoneNumber: false,\n      requireCompanyName: false,\n      allowGuestCheckout: true,\n      minimumOrderAmount: 0,\n      restrictedCountries: [],\n      requiredFields: []\n    }\n  }\n} as const;\n\n/**\n * Pagination configuration\n */\nexport interface PaginationConfig {\n  readonly page: number;\n  readonly limit: number;\n  readonly offset?: number;\n}\n\n/**\n * Sorting configuration\n */\nexport interface SortConfig {\n  readonly field: string;\n  readonly direction: 'asc' | 'desc';\n}\n\n/**\n * Filter operators for advanced search\n */\nexport type FilterOperator = \n  | 'eq' // equals\n  | 'ne' // not equals\n  | 'gt' // greater than\n  | 'gte' // greater than or equal\n  | 'lt' // less than\n  | 'lte' // less than or equal\n  | 'in' // in array\n  | 'nin' // not in array\n  | 'contains' // string contains\n  | 'startswith' // string starts with\n  | 'endswith'; // string ends with\n\n/**\n * Generic filter interface\n */\nexport interface Filter {\n  readonly field: string;\n  readonly operator: FilterOperator;\n  readonly value: unknown;\n}\n\n/**\n * Search operators configuration\n */\nexport interface SearchOperators {\n  readonly logic: 'AND' | 'OR' | 'NOT';\n  readonly fuzzy: boolean;\n  readonly stemming: boolean;\n  readonly synonyms: boolean;\n}\n\n/**\n * Configuration validation functions\n */\nexport function validateBaseURL(url: string): boolean {\n  try {\n    new URL(url);\n    return true;\n  } catch {\n    return false;\n  }\n}\n\nexport function validateConsumerCredentials(key: string, secret: string): boolean {\n  return key.trim().length > 0 && secret.trim().length > 0;\n}\n\nexport function validateCacheConfig(config: Partial<CacheConfig>): boolean {\n  if (config.ttl !== undefined && config.ttl < 0) {\n    return false;\n  }\n  if (config.maxSize !== undefined && config.maxSize <= 0) {\n    return false;\n  }\n  return true;\n} ","/**\n * HTTP Client for WooCommerce API\n * Following the enhanced unified-10x-dev framework\n */\n\nimport { Result, Ok, Err } from '../types/result';\nimport { \n  WooError,\n  ErrorFactory \n} from '../types/errors';\nimport { HttpConfig, ResolvedWooConfig } from '../types/config';\n\n/**\n * HTTP methods enum\n */\nexport type HttpMethod = 'GET' | 'POST' | 'PUT' | 'PATCH' | 'DELETE';\n\n/**\n * Request options interface\n */\nexport interface RequestOptions {\n  readonly method: HttpMethod;\n  readonly url: string;\n  readonly headers?: Record<string, string>;\n  readonly body?: unknown;\n  readonly timeout?: number;\n  readonly retries?: number;\n}\n\n/**\n * Response interface\n */\nexport interface Response<T> {\n  readonly data: T;\n  readonly status: number;\n  readonly statusText: string;\n  readonly headers: Record<string, string>;\n}\n\n/**\n * Request interceptor function type\n */\nexport type RequestInterceptor = (options: RequestOptions) => RequestOptions | Promise<RequestOptions>;\n\n/**\n * Response interceptor function type\n */\nexport type ResponseInterceptor = <T>(response: Response<T>) => Response<T> | Promise<Response<T>>;\n\n/**\n * Error interceptor function type\n */\nexport type ErrorInterceptor = (error: WooError) => WooError | Promise<WooError>;\n\n/**\n * HTTP Client class with comprehensive error handling\n */\nexport class HttpClient {\n  private readonly config: HttpConfig;\n  private readonly baseURL: string;\n  private readonly requestInterceptors: RequestInterceptor[] = [];\n  private readonly responseInterceptors: ResponseInterceptor[] = [];\n  private readonly errorInterceptors: ErrorInterceptor[] = [];\n  private readonly abortControllers: Map<string, AbortController> = new Map();\n\n  constructor(config: ResolvedWooConfig) {\n    this.config = config.http;\n    this.baseURL = `${config.baseURL}/wp-json/${config.version}`;\n  }\n\n  /**\n   * Add request interceptor\n   */\n  addRequestInterceptor(interceptor: RequestInterceptor): void {\n    this.requestInterceptors.push(interceptor);\n  }\n\n  /**\n   * Add response interceptor\n   */\n  addResponseInterceptor(interceptor: ResponseInterceptor): void {\n    this.responseInterceptors.push(interceptor);\n  }\n\n  /**\n   * Add error interceptor\n   */\n  addErrorInterceptor(interceptor: ErrorInterceptor): void {\n    this.errorInterceptors.push(interceptor);\n  }\n\n  /**\n   * Main request method with retry logic and error handling\n   */\n  async request<T>(options: RequestOptions): Promise<Result<Response<T>, WooError>> {\n    const requestId = this.generateRequestId();\n    \n    try {\n      // Apply request interceptors\n      let processedOptions = { ...options };\n      for (const interceptor of this.requestInterceptors) {\n        processedOptions = await interceptor(processedOptions);\n      }\n\n      // Attempt request with retry logic\n      const result = await this.attemptRequest<T>(processedOptions, requestId);\n      \n      if (result.success) {\n        // Apply response interceptors\n        let response = result.data;\n        for (const interceptor of this.responseInterceptors) {\n          response = await interceptor(response);\n        }\n        return Ok(response);\n      } else {\n        // Apply error interceptors\n        let error = result.error;\n        for (const interceptor of this.errorInterceptors) {\n          error = await interceptor(error);\n        }\n        return Err(error);\n      }\n    } catch (error) {\n      const wooError = this.createErrorFromException(error);\n      return Err(wooError);\n    } finally {\n      // Clean up abort controller\n      this.abortControllers.delete(requestId);\n    }\n  }\n\n  /**\n   * GET request\n   */\n  async get<T>(url: string, headers?: Record<string, string>): Promise<Result<Response<T>, WooError>> {\n    const options: RequestOptions = {\n      method: 'GET',\n      url\n    };\n    \n    if (headers !== undefined) {\n      (options as { headers: Record<string, string> }).headers = headers;\n    }\n    \n    return this.request<T>(options);\n  }\n\n  /**\n   * POST request\n   */\n  async post<T>(url: string, body?: unknown, headers?: Record<string, string>): Promise<Result<Response<T>, WooError>> {\n    const options: RequestOptions = {\n      method: 'POST',\n      url\n    };\n    \n    if (body !== undefined) {\n      (options as { body: unknown }).body = body;\n    }\n    \n    if (headers !== undefined) {\n      (options as { headers: Record<string, string> }).headers = headers;\n    }\n    \n    return this.request<T>(options);\n  }\n\n  /**\n   * PUT request\n   */\n  async put<T>(url: string, body?: unknown, headers?: Record<string, string>): Promise<Result<Response<T>, WooError>> {\n    const options: RequestOptions = {\n      method: 'PUT',\n      url\n    };\n    \n    if (body !== undefined) {\n      (options as { body: unknown }).body = body;\n    }\n    \n    if (headers !== undefined) {\n      (options as { headers: Record<string, string> }).headers = headers;\n    }\n    \n    return this.request<T>(options);\n  }\n\n  /**\n   * PATCH request\n   */\n  async patch<T>(url: string, body?: unknown, headers?: Record<string, string>): Promise<Result<Response<T>, WooError>> {\n    const options: RequestOptions = {\n      method: 'PATCH',\n      url\n    };\n    \n    if (body !== undefined) {\n      (options as { body: unknown }).body = body;\n    }\n    \n    if (headers !== undefined) {\n      (options as { headers: Record<string, string> }).headers = headers;\n    }\n    \n    return this.request<T>(options);\n  }\n\n  /**\n   * DELETE request\n   */\n  async delete<T>(url: string, headers?: Record<string, string>): Promise<Result<Response<T>, WooError>> {\n    const options: RequestOptions = {\n      method: 'DELETE',\n      url\n    };\n    \n    if (headers !== undefined) {\n      (options as { headers: Record<string, string> }).headers = headers;\n    }\n    \n    return this.request<T>(options);\n  }\n\n  /**\n   * Cancel request by ID\n   */\n  cancelRequest(requestId: string): void {\n    const controller = this.abortControllers.get(requestId);\n    if (controller) {\n      controller.abort();\n      this.abortControllers.delete(requestId);\n    }\n  }\n\n  /**\n   * Cancel all pending requests\n   */\n  cancelAllRequests(): void {\n    for (const controller of this.abortControllers.values()) {\n      controller.abort();\n    }\n    this.abortControllers.clear();\n  }\n\n  /**\n   * Attempt request with retry logic\n   */\n  private async attemptRequest<T>(\n    options: RequestOptions, \n    requestId: string\n  ): Promise<Result<Response<T>, WooError>> {\n    const maxRetries = options.retries ?? this.config.retries;\n    let lastError: WooError | null = null;\n\n    for (let attempt = 0; attempt <= maxRetries; attempt++) {\n      try {\n        const result = await this.executeRequest<T>(options, requestId);\n        \n        if (result.success) {\n          return result;\n        }\n\n        lastError = result.error;\n\n        // Check if error is retryable\n        if (!this.shouldRetry(lastError, attempt, maxRetries)) {\n          break;\n        }\n\n        // Wait before retry\n        if (attempt < maxRetries) {\n          await this.delay(this.calculateRetryDelay(attempt));\n        }\n      } catch (error) {\n        lastError = this.createErrorFromException(error);\n        \n        if (!this.shouldRetry(lastError, attempt, maxRetries)) {\n          break;\n        }\n\n        if (attempt < maxRetries) {\n          await this.delay(this.calculateRetryDelay(attempt));\n        }\n      }\n    }\n\n    return Err(lastError ?? ErrorFactory.networkError('Unknown error occurred'));\n  }\n\n  /**\n   * Execute single request\n   */\n  private async executeRequest<T>(\n    options: RequestOptions, \n    requestId: string\n  ): Promise<Result<Response<T>, WooError>> {\n    const abortController = new AbortController();\n    this.abortControllers.set(requestId, abortController);\n\n    const url = this.buildURL(options.url);\n    const timeout = options.timeout ?? this.config.timeout;\n\n    // Set up timeout\n    const timeoutId = setTimeout(() => {\n      abortController.abort();\n    }, timeout);\n\n         try {\n       const fetchOptions: RequestInit = {\n         method: options.method,\n         headers: this.buildHeaders(options.headers),\n         signal: abortController.signal\n       };\n       \n       const body = this.buildBody(options.body);\n       if (body !== undefined) {\n         fetchOptions.body = body;\n       }\n\n      const response = await fetch(url, fetchOptions);\n      clearTimeout(timeoutId);\n\n      // Handle HTTP errors\n      if (!response.ok) {\n        return Err(await this.createErrorFromResponse(response));\n      }\n\n      // Parse response\n      const data = await this.parseResponse<T>(response);\n      const responseHeaders = this.extractHeaders(response);\n\n      return Ok({\n        data,\n        status: response.status,\n        statusText: response.statusText,\n        headers: responseHeaders\n      });\n\n    } catch (error) {\n      clearTimeout(timeoutId);\n      \n      if (abortController.signal.aborted) {\n        return Err(ErrorFactory.timeoutError('Request timeout', timeout));\n      }\n\n      return Err(this.createErrorFromException(error));\n    }\n  }\n\n  /**\n   * Build full URL\n   */\n  private buildURL(path: string): string {\n    const cleanPath = path.startsWith('/') ? path.slice(1) : path;\n    return `${this.baseURL}/${cleanPath}`;\n  }\n\n  /**\n   * Build request headers\n   */\n  private buildHeaders(headers?: Record<string, string>): Record<string, string> {\n    const defaultHeaders = {\n      'Content-Type': 'application/json',\n      'Accept': 'application/json',\n      'User-Agent': 'WooHeadless-SDK/1.0.0',\n      ...this.config.headers\n    };\n\n    return { ...defaultHeaders, ...headers };\n  }\n\n  /**\n   * Build request body\n   */\n  private buildBody(body?: unknown): string | undefined {\n    if (!body) return undefined;\n    \n    if (typeof body === 'string') {\n      return body;\n    }\n\n    return JSON.stringify(body);\n  }\n\n  /**\n   * Parse response based on content type\n   */\n  private async parseResponse<T>(response: globalThis.Response): Promise<T> {\n    const contentType = response.headers.get('content-type') || '';\n\n    if (contentType.includes('application/json')) {\n      return response.json() as Promise<T>;\n    }\n\n    if (contentType.includes('text/')) {\n      return response.text() as Promise<T>;\n    }\n\n    // Default to JSON\n    return response.json() as Promise<T>;\n  }\n\n  /**\n   * Extract headers from response\n   */\n  private extractHeaders(response: globalThis.Response): Record<string, string> {\n    const headers: Record<string, string> = {};\n    response.headers.forEach((value, key) => {\n      headers[key] = value;\n    });\n    return headers;\n  }\n\n  /**\n   * Create error from HTTP response\n   */\n  private async createErrorFromResponse(response: globalThis.Response): Promise<WooError> {\n    const status = response.status;\n    const statusText = response.statusText;\n\n    // Handle rate limiting\n    if (status === 429) {\n      const retryAfter = response.headers.get('retry-after');\n      return ErrorFactory.rateLimitError(\n        'Rate limit exceeded',\n        retryAfter ? parseInt(retryAfter) : undefined\n      );\n    }\n\n    // Handle authentication errors\n    if (status === 401 || status === 403) {\n      return ErrorFactory.authError(`Authentication failed: ${statusText}`, undefined, status);\n    }\n\n    // Try to get error details from response body\n    let details: unknown;\n    try {\n      details = await response.json();\n    } catch {\n      details = await response.text();\n    }\n\n    return ErrorFactory.apiError(`HTTP ${status}: ${statusText}`, status, details);\n  }\n\n  /**\n   * Create error from exception\n   */\n  private createErrorFromException(error: unknown): WooError {\n    if (error instanceof Error) {\n      if (error.name === 'AbortError') {\n        return ErrorFactory.timeoutError('Request was aborted', this.config.timeout);\n      }\n\n      if (error.message.includes('network') || error.message.includes('fetch')) {\n        return ErrorFactory.networkError(error.message);\n      }\n    }\n\n    return ErrorFactory.networkError(\n      error instanceof Error ? error.message : 'Unknown network error'\n    );\n  }\n\n  /**\n   * Check if error should trigger retry\n   */\n  private shouldRetry(error: WooError, attempt: number, maxRetries: number): boolean {\n    if (attempt >= maxRetries) {\n      return false;\n    }\n\n    // Use custom retry condition if provided\n    if (this.config.retryCondition) {\n      return this.config.retryCondition(error);\n    }\n\n    // Default retry logic\n    return error.retryable === true;\n  }\n\n  /**\n   * Calculate retry delay with exponential backoff\n   */\n  private calculateRetryDelay(attempt: number): number {\n    const baseDelay = this.config.retryDelay;\n    const exponentialDelay = baseDelay * Math.pow(2, attempt);\n    const jitteredDelay = exponentialDelay + Math.random() * 1000; // Add jitter\n    \n    return Math.min(jitteredDelay, this.config.maxRetryDelay);\n  }\n\n  /**\n   * Delay helper\n   */\n  private delay(ms: number): Promise<void> {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n\n  /**\n   * Generate unique request ID\n   */\n  private generateRequestId(): string {\n    return `req_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n  }\n} ","/**\n * Authentication system for WooCommerce Headless SDK\n * Following the enhanced unified-10x-dev framework\n */\n\nimport { Result, Ok, Err } from '../types/result';\nimport { WooError, ErrorFactory } from '../types/errors';\nimport { JWTConfig, ResolvedWooConfig } from '../types/config';\n\n/**\n * JWT Token interface\n */\nexport interface JWTToken {\n  readonly token: string;\n  readonly refreshToken?: string;\n  readonly expiresAt: Date;\n  readonly issuedAt: Date;\n}\n\n/**\n * User credentials interface\n */\nexport interface UserCredentials {\n  readonly email: string;\n  readonly password: string;\n}\n\n/**\n * User registration data\n */\nexport interface UserRegistration {\n  readonly email: string;\n  readonly password: string;\n  readonly firstName: string;\n  readonly lastName: string;\n  readonly username?: string;\n}\n\n/**\n * Authentication response from WooCommerce\n */\nexport interface AuthResponse {\n  readonly success: boolean;\n  readonly data: {\n    readonly token: string;\n    readonly user_email: string;\n    readonly user_nicename: string;\n    readonly user_display_name: string;\n    readonly expires: number;\n  };\n}\n\n/**\n * Storage interface for tokens\n */\nexport interface TokenStorage {\n  get(key: string): Promise<string | null>;\n  set(key: string, value: string): Promise<void>;\n  remove(key: string): Promise<void>;\n  clear(): Promise<void>;\n}\n\n/**\n * LocalStorage implementation\n */\nexport class LocalTokenStorage implements TokenStorage {\n  private readonly prefix: string;\n\n  constructor(prefix = 'woo-headless') {\n    this.prefix = prefix;\n  }\n\n  async get(key: string): Promise<string | null> {\n    try {\n      return localStorage.getItem(`${this.prefix}:${key}`);\n    } catch {\n      return null;\n    }\n  }\n\n  async set(key: string, value: string): Promise<void> {\n    try {\n      localStorage.setItem(`${this.prefix}:${key}`, value);\n    } catch {\n      // Silently fail if localStorage is not available\n    }\n  }\n\n  async remove(key: string): Promise<void> {\n    try {\n      localStorage.removeItem(`${this.prefix}:${key}`);\n    } catch {\n      // Silently fail\n    }\n  }\n\n  async clear(): Promise<void> {\n    try {\n      const keys = Object.keys(localStorage);\n      for (const key of keys) {\n        if (key.startsWith(`${this.prefix}:`)) {\n          localStorage.removeItem(key);\n        }\n      }\n    } catch {\n      // Silently fail\n    }\n  }\n}\n\n/**\n * SessionStorage implementation\n */\nexport class SessionTokenStorage implements TokenStorage {\n  private readonly prefix: string;\n\n  constructor(prefix = 'woo-headless') {\n    this.prefix = prefix;\n  }\n\n  async get(key: string): Promise<string | null> {\n    try {\n      return sessionStorage.getItem(`${this.prefix}:${key}`);\n    } catch {\n      return null;\n    }\n  }\n\n  async set(key: string, value: string): Promise<void> {\n    try {\n      sessionStorage.setItem(`${this.prefix}:${key}`, value);\n    } catch {\n      // Silently fail\n    }\n  }\n\n  async remove(key: string): Promise<void> {\n    try {\n      sessionStorage.removeItem(`${this.prefix}:${key}`);\n    } catch {\n      // Silently fail\n    }\n  }\n\n  async clear(): Promise<void> {\n    try {\n      const keys = Object.keys(sessionStorage);\n      for (const key of keys) {\n        if (key.startsWith(`${this.prefix}:`)) {\n          sessionStorage.removeItem(key);\n        }\n      }\n    } catch {\n      // Silently fail\n    }\n  }\n}\n\n/**\n * Memory storage implementation (for server-side or private contexts)\n */\nexport class MemoryTokenStorage implements TokenStorage {\n  private readonly store = new Map<string, string>();\n  private readonly prefix: string;\n\n  constructor(prefix = 'woo-headless') {\n    this.prefix = prefix;\n  }\n\n  async get(key: string): Promise<string | null> {\n    return this.store.get(`${this.prefix}:${key}`) ?? null;\n  }\n\n  async set(key: string, value: string): Promise<void> {\n    this.store.set(`${this.prefix}:${key}`, value);\n  }\n\n  async remove(key: string): Promise<void> {\n    this.store.delete(`${this.prefix}:${key}`);\n  }\n\n  async clear(): Promise<void> {\n    const keys = Array.from(this.store.keys());\n    for (const key of keys) {\n      if (key.startsWith(`${this.prefix}:`)) {\n        this.store.delete(key);\n      }\n    }\n  }\n}\n\n/**\n * Authentication manager\n */\nexport class AuthManager {\n  private readonly config: JWTConfig;\n  private readonly storage: TokenStorage;\n  private currentToken: JWTToken | null = null;\n  private refreshTimer: ReturnType<typeof setTimeout> | null = null;\n\n  constructor(\n    config: ResolvedWooConfig,\n    storage?: TokenStorage\n  ) {\n    this.config = config.auth;\n    \n    // Choose storage based on environment\n    if (storage) {\n      this.storage = storage;\n    } else if (typeof window !== 'undefined') {\n      this.storage = new LocalTokenStorage(config.cache.prefix);\n    } else {\n      this.storage = new MemoryTokenStorage(config.cache.prefix);\n    }\n\n    // Initialize existing token if available\n    this.initializeToken();\n  }\n\n  /**\n   * Initialize token from storage\n   */\n  private async initializeToken(): Promise<void> {\n    try {\n      const tokenData = await this.storage.get('token');\n      if (tokenData) {\n        const parsed = JSON.parse(tokenData) as JWTToken;\n        if (this.isTokenValid(parsed)) {\n          this.currentToken = parsed;\n          this.scheduleRefresh();\n        } else {\n          await this.clearToken();\n        }\n      }\n    } catch {\n      // Invalid token data, clear it\n      await this.clearToken();\n    }\n  }\n\n  /**\n   * Set authentication token\n   */\n  async setToken(tokenData: JWTToken): Promise<void> {\n    this.currentToken = tokenData;\n    await this.storage.set('token', JSON.stringify(tokenData));\n    this.scheduleRefresh();\n  }\n\n  /**\n   * Get current token\n   */\n  getToken(): string | null {\n    if (this.currentToken && this.isTokenValid(this.currentToken)) {\n      return this.currentToken.token;\n    }\n    return null;\n  }\n\n  /**\n   * Check if user is authenticated\n   */\n  isAuthenticated(): boolean {\n    return this.getToken() !== null;\n  }\n\n  /**\n   * Validate token\n   */\n  async validateToken(): Promise<Result<boolean, WooError>> {\n    if (!this.currentToken) {\n      return Ok(false);\n    }\n\n    if (!this.isTokenValid(this.currentToken)) {\n      await this.clearToken();\n      return Ok(false);\n    }\n\n    return Ok(true);\n  }\n\n  /**\n   * Clear authentication token\n   */\n  async clearToken(): Promise<void> {\n    this.currentToken = null;\n    await this.storage.remove('token');\n    this.clearRefreshTimer();\n  }\n\n  /**\n   * Logout\n   */\n  async logout(): Promise<Result<void, WooError>> {\n    await this.clearToken();\n    return Ok(undefined);\n  }\n\n  /**\n   * Create JWT token from auth response\n   */\n  createTokenFromAuthResponse(authResponse: AuthResponse): Result<JWTToken, WooError> {\n    if (!authResponse.success || !authResponse.data.token) {\n      return Err(ErrorFactory.authError('Invalid authentication response'));\n    }\n\n    const now = new Date();\n    const expiresAt = new Date(authResponse.data.expires * 1000);\n\n    const token: JWTToken = {\n      token: authResponse.data.token,\n      expiresAt,\n      issuedAt: now\n    };\n\n    return Ok(token);\n  }\n\n  /**\n   * Get authorization header\n   */\n  getAuthorizationHeader(): Record<string, string> | undefined {\n    const token = this.getToken();\n    if (!token) {\n      return undefined;\n    }\n\n    return {\n      'Authorization': `Bearer ${token}`\n    };\n  }\n\n  /**\n   * Schedule token refresh\n   */\n  private scheduleRefresh(): void {\n    this.clearRefreshTimer();\n\n    if (!this.config.autoRefresh || !this.currentToken) {\n      return;\n    }\n\n    const refreshThreshold = this.config.refreshThreshold ?? 300; // 5 minutes default\n    const refreshTime = this.currentToken.expiresAt.getTime() - Date.now() - (refreshThreshold * 1000);\n\n    if (refreshTime > 0) {\n      this.refreshTimer = setTimeout(() => {\n        this.handleTokenRefresh();\n      }, refreshTime);\n    }\n  }\n\n  /**\n   * Handle token refresh\n   */\n  private async handleTokenRefresh(): Promise<void> {\n    // Token refresh would typically require a refresh endpoint\n    // For now, we'll clear the token to force re-authentication\n    await this.clearToken();\n  }\n\n  /**\n   * Clear refresh timer\n   */\n  private clearRefreshTimer(): void {\n    if (this.refreshTimer) {\n      clearTimeout(this.refreshTimer);\n      this.refreshTimer = null;\n    }\n  }\n\n  /**\n   * Check if token is valid (not expired)\n   */\n  private isTokenValid(token: JWTToken): boolean {\n    return token.expiresAt.getTime() > Date.now();\n  }\n\n  /**\n   * Generate basic auth header for consumer key/secret\n   */\n  static generateBasicAuth(consumerKey: string, consumerSecret: string): string {\n    const credentials = `${consumerKey}:${consumerSecret}`;\n    return `Basic ${btoa(credentials)}`;\n  }\n\n  /**\n   * Create OAuth signature for WooCommerce REST API\n   */\n  static createOAuthSignature(\n    consumerKey: string,\n    consumerSecret: string,\n    url: string,\n    method: string,\n    parameters: Record<string, string> = {}\n  ): Record<string, string> {\n    const timestamp = Math.floor(Date.now() / 1000).toString();\n    const nonce = Math.random().toString(36).substring(2, 15);\n\n    const oauthParams = {\n      oauth_consumer_key: consumerKey,\n      oauth_nonce: nonce,\n      oauth_signature_method: 'HMAC-SHA1',\n      oauth_timestamp: timestamp,\n      oauth_version: '1.0',\n      ...parameters\n    };\n\n    // Sort parameters\n    const sortedParams = Object.keys(oauthParams)\n      .sort()\n      .map(key => {\n        const value = (oauthParams as Record<string, string>)[key];\n        return `${key}=${encodeURIComponent(value ?? '')}`;\n      })\n      .join('&');\n\n    // Create signature base string\n    const signatureBase = `${method.toUpperCase()}&${encodeURIComponent(url)}&${encodeURIComponent(sortedParams)}`;\n\n    // Create signing key\n    const signingKey = `${encodeURIComponent(consumerSecret)}&`;\n\n    // This is a simplified version - in production, you'd use a proper HMAC-SHA1 implementation\n    const signature = btoa(signatureBase + signingKey);\n\n    return {\n      ...oauthParams,\n      oauth_signature: signature\n    };\n  }\n} ","/**\n * Configuration manager for WooCommerce Headless SDK\n * Following the enhanced unified-10x-dev framework\n */\n\nimport { \n  WooConfig, \n  ResolvedWooConfig, \n  DEFAULT_CONFIG,\n  validateBaseURL,\n  validateConsumerCredentials,\n  validateCacheConfig\n} from '../types/config';\nimport { Result, Ok, Err } from '../types/result';\nimport { ConfigurationError, ErrorFactory } from '../types/errors';\n\n/**\n * Configuration manager class\n */\nexport class ConfigManager {\n  /**\n   * Resolve configuration with defaults and validation\n   */\n  static resolveConfig(config: WooConfig): Result<ResolvedWooConfig, ConfigurationError> {\n    // Validate required fields\n    const validation = this.validateConfig(config);\n    if (!validation.success) {\n      return validation;\n    }\n\n    // Merge with defaults\n    const resolvedConfig: ResolvedWooConfig = {\n      baseURL: config.baseURL,\n      consumerKey: config.consumerKey,\n      consumerSecret: config.consumerSecret,\n      version: config.version ?? DEFAULT_CONFIG.version,\n      environment: config.environment ?? DEFAULT_CONFIG.environment,\n      cache: {\n        ...DEFAULT_CONFIG.cache,\n        ...config.cache\n      },\n      auth: {\n        ...DEFAULT_CONFIG.auth,\n        ...config.auth\n      },\n      http: {\n        ...DEFAULT_CONFIG.http,\n        ...config.http\n      },\n      search: {\n        ...DEFAULT_CONFIG.search,\n        ...config.search\n      },\n      analytics: {\n        ...DEFAULT_CONFIG.analytics,\n        ...config.analytics\n      },\n      i18n: {\n        ...DEFAULT_CONFIG.i18n,\n        ...config.i18n\n      },\n      debug: {\n        ...DEFAULT_CONFIG.debug,\n        ...config.debug\n      },\n      advancedSearch: {\n        ...DEFAULT_CONFIG.advancedSearch,\n        ...config.advancedSearch\n      },\n      cart: {\n        ...DEFAULT_CONFIG.cart,\n        ...config.cart\n      },\n      userSync: {\n        ...DEFAULT_CONFIG.userSync,\n        ...config.userSync\n      },\n      checkout: {\n        ...DEFAULT_CONFIG.checkout,\n        ...config.checkout\n      }\n    };\n\n    return Ok(resolvedConfig);\n  }\n\n  /**\n   * Validate configuration\n   */\n  static validateConfig(config: WooConfig): Result<void, ConfigurationError> {\n    // Validate base URL\n    if (!validateBaseURL(config.baseURL)) {\n      return Err(ErrorFactory.configurationError(\n        'Invalid baseURL. Must be a valid URL.',\n        { baseURL: config.baseURL }\n      ));\n    }\n\n    // Validate consumer credentials\n    if (!validateConsumerCredentials(config.consumerKey, config.consumerSecret)) {\n      return Err(ErrorFactory.configurationError(\n        'Invalid consumer credentials. Both consumerKey and consumerSecret are required.',\n        { \n          hasConsumerKey: Boolean(config.consumerKey?.trim()),\n          hasConsumerSecret: Boolean(config.consumerSecret?.trim())\n        }\n      ));\n    }\n\n    // Validate cache config if provided\n    if (config.cache && !validateCacheConfig(config.cache)) {\n      return Err(ErrorFactory.configurationError(\n        'Invalid cache configuration.',\n        { cache: config.cache }\n      ));\n    }\n\n    // Validate search config\n    if (config.search?.fuzzyThreshold !== undefined) {\n      if (config.search.fuzzyThreshold < 0 || config.search.fuzzyThreshold > 1) {\n        return Err(ErrorFactory.configurationError(\n          'Search fuzzyThreshold must be between 0 and 1.',\n          { fuzzyThreshold: config.search.fuzzyThreshold }\n        ));\n      }\n    }\n\n    if (config.search?.maxResults !== undefined) {\n      if (config.search.maxResults <= 0) {\n        return Err(ErrorFactory.configurationError(\n          'Search maxResults must be greater than 0.',\n          { maxResults: config.search.maxResults }\n        ));\n      }\n    }\n\n    // Validate HTTP config\n    if (config.http?.timeout !== undefined && config.http.timeout <= 0) {\n      return Err(ErrorFactory.configurationError(\n        'HTTP timeout must be greater than 0.',\n        { timeout: config.http.timeout }\n      ));\n    }\n\n    if (config.http?.retries !== undefined && config.http.retries < 0) {\n      return Err(ErrorFactory.configurationError(\n        'HTTP retries must be 0 or greater.',\n        { retries: config.http.retries }\n      ));\n    }\n\n    // Validate auth config\n    if (config.auth?.expiresIn !== undefined && config.auth.expiresIn <= 0) {\n      return Err(ErrorFactory.configurationError(\n        'Auth expiresIn must be greater than 0.',\n        { expiresIn: config.auth.expiresIn }\n      ));\n    }\n\n    return Ok(undefined);\n  }\n\n  /**\n   * Get environment-specific configuration\n   */\n  static getEnvironmentConfig(environment: string): Partial<WooConfig> {\n    switch (environment) {\n      case 'development':\n        return {\n          debug: {\n            enabled: true,\n            logLevel: 'debug',\n            performanceMonitoring: true,\n            errorReporting: true,\n            apiLogging: true\n          },\n          http: {\n            timeout: 60000, // Longer timeout for development\n            retries: 1 // Fewer retries for faster debugging\n          }\n        };\n        \n      case 'staging':\n        return {\n          debug: {\n            enabled: true,\n            logLevel: 'info',\n            performanceMonitoring: true,\n            errorReporting: true,\n            apiLogging: false\n          },\n          analytics: {\n            enabled: true,\n            trackPageViews: true,\n            trackSearches: true,\n            trackConversions: true\n          }\n        };\n        \n      case 'production':\n        return {\n          debug: {\n            enabled: false,\n            logLevel: 'error',\n            performanceMonitoring: true,\n            errorReporting: true,\n            apiLogging: false\n          },\n          analytics: {\n            enabled: true,\n            trackPageViews: true,\n            trackSearches: true,\n            trackConversions: true\n          },\n          cache: {\n            enabled: true,\n            ttl: 300000 // 5 minutes in production\n          }\n        };\n        \n      default:\n        return {};\n    }\n  }\n\n  /**\n   * Create configuration from environment variables\n   */\n  static fromEnvironment(): Partial<WooConfig> {\n    // Return empty config in browser environment\n    try {\n      // This will throw in browser environments\n      const processExists = typeof process !== 'undefined' && process.env;\n      if (!processExists) {\n        return {};\n      }\n\n      const env = process.env;\n      const config: Record<string, unknown> = {};\n\n      if (env.WOO_BASE_URL) {\n        config.baseURL = env.WOO_BASE_URL;\n      }\n\n      if (env.WOO_CONSUMER_KEY) {\n        config.consumerKey = env.WOO_CONSUMER_KEY;\n      }\n\n      if (env.WOO_CONSUMER_SECRET) {\n        config.consumerSecret = env.WOO_CONSUMER_SECRET;\n      }\n\n      if (env.WOO_VERSION) {\n        config.version = env.WOO_VERSION;\n      }\n\n      if (env.NODE_ENV) {\n        config.environment = env.NODE_ENV;\n        \n        // Apply environment-specific config\n        const envConfig = this.getEnvironmentConfig(env.NODE_ENV);\n        Object.assign(config, envConfig);\n      }\n\n      return config as Partial<WooConfig>;\n    } catch {\n      // If process is not available, return empty config\n      return {};\n    }\n  }\n\n  /**\n   * Merge multiple configurations\n   */\n  static mergeConfigs(...configs: Partial<WooConfig>[]): Partial<WooConfig> {\n    const merged: Record<string, unknown> = {};\n\n    for (const config of configs) {\n      Object.assign(merged, config);\n      \n      // Deep merge nested objects\n      if (config.cache && (merged.cache as unknown)) {\n        merged.cache = { ...(merged.cache as object), ...config.cache };\n      }\n      \n      if (config.auth && (merged.auth as unknown)) {\n        merged.auth = { ...(merged.auth as object), ...config.auth };\n      }\n      \n      if (config.http && (merged.http as unknown)) {\n        merged.http = { ...(merged.http as object), ...config.http };\n      }\n      \n      if (config.search && (merged.search as unknown)) {\n        merged.search = { ...(merged.search as object), ...config.search };\n      }\n      \n      if (config.analytics && (merged.analytics as unknown)) {\n        merged.analytics = { ...(merged.analytics as object), ...config.analytics };\n      }\n      \n      if (config.i18n && (merged.i18n as unknown)) {\n        merged.i18n = { ...(merged.i18n as object), ...config.i18n };\n      }\n      \n      if (config.debug && (merged.debug as unknown)) {\n        merged.debug = { ...(merged.debug as object), ...config.debug };\n      }\n    }\n\n    return merged as Partial<WooConfig>;\n  }\n} ","/**\n * Multi-layer caching system for WooCommerce Headless SDK\n * Following the enhanced unified-10x-dev framework\n */\n\nimport { Result, Ok, Err } from '../types/result';\nimport { WooError, ErrorFactory } from '../types/errors';\nimport { CacheConfig } from '../types/config';\n\n/**\n * Cache entry interface with metadata\n */\nexport interface CacheEntry<T> {\n  readonly data: T;\n  readonly timestamp: number;\n  readonly ttl: number;\n  readonly key: string;\n}\n\n/**\n * Cache storage interface\n */\nexport interface CacheStorage {\n  get<T>(key: string): Promise<Result<T | null, WooError>>;\n  set<T>(key: string, value: T, ttl: number): Promise<Result<void, WooError>>;\n  delete(key: string): Promise<Result<void, WooError>>;\n  clear(): Promise<Result<void, WooError>>;\n  has(key: string): Promise<Result<boolean, WooError>>;\n  size(): Promise<Result<number, WooError>>;\n}\n\n/**\n * Memory cache implementation (L1)\n */\nexport class MemoryCache implements CacheStorage {\n  private readonly cache = new Map<string, CacheEntry<unknown>>();\n  private readonly maxSize: number;\n\n  constructor(maxSizeMB = 50) {\n    this.maxSize = maxSizeMB * 1024 * 1024; // Convert to bytes\n  }\n\n  async get<T>(key: string): Promise<Result<T | null, WooError>> {\n    try {\n      const entry = this.cache.get(key) as CacheEntry<T> | undefined;\n      \n      if (!entry) {\n        return Ok(null);\n      }\n\n      // Check if expired\n      if (Date.now() > entry.timestamp + entry.ttl) {\n        this.cache.delete(key);\n        return Ok(null);\n      }\n\n      return Ok(entry.data);\n    } catch (error) {\n      return Err(ErrorFactory.cacheError('Failed to get from memory cache', error));\n    }\n  }\n\n  async set<T>(key: string, value: T, ttl: number): Promise<Result<void, WooError>> {\n    try {\n      // Check size limit\n      const size = this.estimateSize(value);\n      if (size > this.maxSize) {\n        return Err(ErrorFactory.cacheError('Value too large for cache'));\n      }\n\n      // Evict old entries if needed\n      await this.evictIfNeeded(size);\n\n      const entry: CacheEntry<T> = {\n        data: value,\n        timestamp: Date.now(),\n        ttl,\n        key\n      };\n\n      this.cache.set(key, entry);\n      return Ok(undefined);\n    } catch (error) {\n      return Err(ErrorFactory.cacheError('Failed to set in memory cache', error));\n    }\n  }\n\n  async delete(key: string): Promise<Result<void, WooError>> {\n    try {\n      this.cache.delete(key);\n      return Ok(undefined);\n    } catch (error) {\n      return Err(ErrorFactory.cacheError('Failed to delete from memory cache', error));\n    }\n  }\n\n  async clear(): Promise<Result<void, WooError>> {\n    try {\n      this.cache.clear();\n      return Ok(undefined);\n    } catch (error) {\n      return Err(ErrorFactory.cacheError('Failed to clear memory cache', error));\n    }\n  }\n\n  async has(key: string): Promise<Result<boolean, WooError>> {\n    try {\n      const result = await this.get(key);\n      return result.success ? Ok(result.data !== null) : result;\n    } catch (error) {\n      return Err(ErrorFactory.cacheError('Failed to check memory cache', error));\n    }\n  }\n\n  async size(): Promise<Result<number, WooError>> {\n    try {\n      return Ok(this.cache.size);\n    } catch (error) {\n      return Err(ErrorFactory.cacheError('Failed to get memory cache size', error));\n    }\n  }\n\n  private estimateSize(value: unknown): number {\n    // Rough estimate of object size in bytes\n    return JSON.stringify(value).length * 2; // UTF-16 characters\n  }\n\n  private async evictIfNeeded(requiredSize: number): Promise<void> {\n    let currentSize = 0;\n    const entries = Array.from(this.cache.entries());\n\n    // Calculate current size\n    for (const [, entry] of entries) {\n      currentSize += this.estimateSize(entry.data);\n    }\n\n    // Evict oldest entries if needed (LRU)\n    if (currentSize + requiredSize > this.maxSize) {\n      const sortedEntries = entries.sort((a, b) => \n        (a[1] as CacheEntry<unknown>).timestamp - (b[1] as CacheEntry<unknown>).timestamp\n      );\n\n      for (const [key] of sortedEntries) {\n        this.cache.delete(key);\n        currentSize -= this.estimateSize(this.cache.get(key));\n        \n        if (currentSize + requiredSize <= this.maxSize) {\n          break;\n        }\n      }\n    }\n  }\n}\n\n/**\n * LocalStorage cache implementation (L2)\n */\nexport class LocalStorageCache implements CacheStorage {\n  private readonly prefix: string;\n  private readonly maxSize: number;\n\n  constructor(prefix = 'woo-cache', maxSizeMB = 10) {\n    this.prefix = prefix;\n    this.maxSize = maxSizeMB * 1024 * 1024;\n  }\n\n  async get<T>(key: string): Promise<Result<T | null, WooError>> {\n    try {\n      if (typeof window === 'undefined' || !window.localStorage) {\n        return Ok(null);\n      }\n\n      const item = localStorage.getItem(`${this.prefix}:${key}`);\n      if (!item) {\n        return Ok(null);\n      }\n\n      const entry = JSON.parse(item) as CacheEntry<T>;\n\n      // Check if expired\n      if (Date.now() > entry.timestamp + entry.ttl) {\n        localStorage.removeItem(`${this.prefix}:${key}`);\n        return Ok(null);\n      }\n\n      return Ok(entry.data);\n    } catch (error) {\n      return Err(ErrorFactory.cacheError('Failed to get from localStorage', error));\n    }\n  }\n\n  async set<T>(key: string, value: T, ttl: number): Promise<Result<void, WooError>> {\n    try {\n      if (typeof window === 'undefined' || !window.localStorage) {\n        return Ok(undefined);\n      }\n\n      const entry: CacheEntry<T> = {\n        data: value,\n        timestamp: Date.now(),\n        ttl,\n        key\n      };\n\n      const serialized = JSON.stringify(entry);\n      \n      // Check size limit\n      if (serialized.length > this.maxSize) {\n        return Err(ErrorFactory.cacheError('Value too large for localStorage'));\n      }\n\n      try {\n        localStorage.setItem(`${this.prefix}:${key}`, serialized);\n        return Ok(undefined);\n      } catch (e) {\n        // Handle quota exceeded\n        if (e instanceof Error && e.name === 'QuotaExceededError') {\n          await this.evictOldest();\n          localStorage.setItem(`${this.prefix}:${key}`, serialized);\n          return Ok(undefined);\n        }\n        throw e;\n      }\n    } catch (error) {\n      return Err(ErrorFactory.cacheError('Failed to set in localStorage', error));\n    }\n  }\n\n  async delete(key: string): Promise<Result<void, WooError>> {\n    try {\n      if (typeof window === 'undefined' || !window.localStorage) {\n        return Ok(undefined);\n      }\n\n      localStorage.removeItem(`${this.prefix}:${key}`);\n      return Ok(undefined);\n    } catch (error) {\n      return Err(ErrorFactory.cacheError('Failed to delete from localStorage', error));\n    }\n  }\n\n  async clear(): Promise<Result<void, WooError>> {\n    try {\n      if (typeof window === 'undefined' || !window.localStorage) {\n        return Ok(undefined);\n      }\n\n      const keys = Object.keys(localStorage);\n      for (const key of keys) {\n        if (key.startsWith(`${this.prefix}:`)) {\n          localStorage.removeItem(key);\n        }\n      }\n      return Ok(undefined);\n    } catch (error) {\n      return Err(ErrorFactory.cacheError('Failed to clear localStorage', error));\n    }\n  }\n\n  async has(key: string): Promise<Result<boolean, WooError>> {\n    try {\n      if (typeof window === 'undefined' || !window.localStorage) {\n        return Ok(false);\n      }\n\n      return Ok(localStorage.getItem(`${this.prefix}:${key}`) !== null);\n    } catch (error) {\n      return Err(ErrorFactory.cacheError('Failed to check localStorage', error));\n    }\n  }\n\n  async size(): Promise<Result<number, WooError>> {\n    try {\n      if (typeof window === 'undefined' || !window.localStorage) {\n        return Ok(0);\n      }\n\n      let count = 0;\n      const keys = Object.keys(localStorage);\n      for (const key of keys) {\n        if (key.startsWith(`${this.prefix}:`)) {\n          count++;\n        }\n      }\n      return Ok(count);\n    } catch (error) {\n      return Err(ErrorFactory.cacheError('Failed to get localStorage size', error));\n    }\n  }\n\n  private async evictOldest(): Promise<void> {\n    const entries: Array<[string, CacheEntry<unknown>]> = [];\n    const keys = Object.keys(localStorage);\n\n    for (const key of keys) {\n      if (key.startsWith(`${this.prefix}:`)) {\n        try {\n          const item = localStorage.getItem(key);\n          if (item) {\n            entries.push([key, JSON.parse(item)]);\n          }\n        } catch {\n          // Skip invalid entries\n        }\n      }\n    }\n\n    // Sort by timestamp (oldest first)\n    entries.sort((a, b) => a[1].timestamp - b[1].timestamp);\n\n    // Remove oldest 25% of entries\n    const removeCount = Math.ceil(entries.length * 0.25);\n    for (let i = 0; i < removeCount && i < entries.length; i++) {\n      const entry = entries[i];\n      if (entry && entry[0]) {\n        localStorage.removeItem(entry[0]);\n      }\n    }\n  }\n}\n\n/**\n * IndexedDB cache implementation (L3)\n */\nexport class IndexedDBCache implements CacheStorage {\n  private readonly dbName: string;\n  private readonly storeName = 'cache';\n  private readonly version = 1;\n  private db: IDBDatabase | null = null;\n\n  constructor(dbName = 'woo-cache-db') {\n    this.dbName = dbName;\n  }\n\n  private async initDB(): Promise<Result<IDBDatabase, WooError>> {\n    try {\n      if (typeof window === 'undefined' || !window.indexedDB) {\n        return Err(ErrorFactory.cacheError('IndexedDB not available'));\n      }\n\n      if (this.db) {\n        return Ok(this.db);\n      }\n\n      return new Promise((resolve) => {\n        const request = indexedDB.open(this.dbName, this.version);\n\n        request.onerror = () => {\n          resolve(Err(ErrorFactory.cacheError('Failed to open IndexedDB')));\n        };\n\n        request.onsuccess = () => {\n          this.db = request.result;\n          resolve(Ok(request.result));\n        };\n\n        request.onupgradeneeded = (event) => {\n          const db = (event.target as IDBOpenDBRequest).result;\n          if (!db.objectStoreNames.contains(this.storeName)) {\n            db.createObjectStore(this.storeName, { keyPath: 'key' });\n          }\n        };\n      });\n    } catch (error) {\n      return Err(ErrorFactory.cacheError('Failed to initialize IndexedDB', error));\n    }\n  }\n\n  async get<T>(key: string): Promise<Result<T | null, WooError>> {\n    try {\n      const dbResult = await this.initDB();\n      if (!dbResult.success) {\n        return Ok(null);\n      }\n\n      const db = dbResult.data;\n      const transaction = db.transaction([this.storeName], 'readonly');\n      const store = transaction.objectStore(this.storeName);\n\n      return new Promise((resolve) => {\n        const request = store.get(key);\n\n        request.onerror = () => {\n          resolve(Err(ErrorFactory.cacheError('Failed to get from IndexedDB')));\n        };\n\n        request.onsuccess = () => {\n          const entry = request.result as CacheEntry<T> | undefined;\n          \n          if (!entry) {\n            resolve(Ok(null));\n            return;\n          }\n\n          // Check if expired\n          if (Date.now() > entry.timestamp + entry.ttl) {\n            this.delete(key); // Clean up expired entry\n            resolve(Ok(null));\n            return;\n          }\n\n          resolve(Ok(entry.data));\n        };\n      });\n    } catch (error) {\n      return Err(ErrorFactory.cacheError('Failed to get from IndexedDB', error));\n    }\n  }\n\n  async set<T>(key: string, value: T, ttl: number): Promise<Result<void, WooError>> {\n    try {\n      const dbResult = await this.initDB();\n      if (!dbResult.success) {\n        return dbResult;\n      }\n\n      const db = dbResult.data;\n      const transaction = db.transaction([this.storeName], 'readwrite');\n      const store = transaction.objectStore(this.storeName);\n\n      const entry: CacheEntry<T> = {\n        data: value,\n        timestamp: Date.now(),\n        ttl,\n        key\n      };\n\n      return new Promise((resolve) => {\n        const request = store.put(entry);\n\n        request.onerror = () => {\n          resolve(Err(ErrorFactory.cacheError('Failed to set in IndexedDB')));\n        };\n\n        request.onsuccess = () => {\n          resolve(Ok(undefined));\n        };\n      });\n    } catch (error) {\n      return Err(ErrorFactory.cacheError('Failed to set in IndexedDB', error));\n    }\n  }\n\n  async delete(key: string): Promise<Result<void, WooError>> {\n    try {\n      const dbResult = await this.initDB();\n      if (!dbResult.success) {\n        return dbResult;\n      }\n\n      const db = dbResult.data;\n      const transaction = db.transaction([this.storeName], 'readwrite');\n      const store = transaction.objectStore(this.storeName);\n\n      return new Promise((resolve) => {\n        const request = store.delete(key);\n\n        request.onerror = () => {\n          resolve(Err(ErrorFactory.cacheError('Failed to delete from IndexedDB')));\n        };\n\n        request.onsuccess = () => {\n          resolve(Ok(undefined));\n        };\n      });\n    } catch (error) {\n      return Err(ErrorFactory.cacheError('Failed to delete from IndexedDB', error));\n    }\n  }\n\n  async clear(): Promise<Result<void, WooError>> {\n    try {\n      const dbResult = await this.initDB();\n      if (!dbResult.success) {\n        return dbResult;\n      }\n\n      const db = dbResult.data;\n      const transaction = db.transaction([this.storeName], 'readwrite');\n      const store = transaction.objectStore(this.storeName);\n\n      return new Promise((resolve) => {\n        const request = store.clear();\n\n        request.onerror = () => {\n          resolve(Err(ErrorFactory.cacheError('Failed to clear IndexedDB')));\n        };\n\n        request.onsuccess = () => {\n          resolve(Ok(undefined));\n        };\n      });\n    } catch (error) {\n      return Err(ErrorFactory.cacheError('Failed to clear IndexedDB', error));\n    }\n  }\n\n  async has(key: string): Promise<Result<boolean, WooError>> {\n    const result = await this.get(key);\n    return result.success ? Ok(result.data !== null) : result;\n  }\n\n  async size(): Promise<Result<number, WooError>> {\n    try {\n      const dbResult = await this.initDB();\n      if (!dbResult.success) {\n        return Ok(0);\n      }\n\n      const db = dbResult.data;\n      const transaction = db.transaction([this.storeName], 'readonly');\n      const store = transaction.objectStore(this.storeName);\n\n      return new Promise((resolve) => {\n        const request = store.count();\n\n        request.onerror = () => {\n          resolve(Err(ErrorFactory.cacheError('Failed to get IndexedDB size')));\n        };\n\n        request.onsuccess = () => {\n          resolve(Ok(request.result));\n        };\n      });\n    } catch (error) {\n      return Err(ErrorFactory.cacheError('Failed to get IndexedDB size', error));\n    }\n  }\n}\n\n/**\n * Multi-layer cache manager\n */\nexport class CacheManager {\n  private readonly layers: Map<string, CacheStorage> = new Map();\n  private readonly config: CacheConfig;\n\n  constructor(config: CacheConfig) {\n    this.config = config;\n    this.initializeLayers();\n  }\n\n  private initializeLayers(): void {\n    // Always include memory cache as L1\n    this.layers.set('memory', new MemoryCache(this.config.maxSize));\n\n    // Add persistent storage based on config\n    if (this.config.storage === 'localStorage') {\n      this.layers.set('localStorage', new LocalStorageCache(this.config.prefix, this.config.maxSize));\n    } else if (this.config.storage === 'sessionStorage') {\n      // SessionStorage implementation would be similar to LocalStorage\n      this.layers.set('localStorage', new LocalStorageCache(this.config.prefix, this.config.maxSize));\n    }\n\n    // Add IndexedDB for large data sets\n    if (typeof window !== 'undefined' && window.indexedDB) {\n      this.layers.set('indexedDB', new IndexedDBCache(this.config.prefix));\n    }\n  }\n\n  /**\n   * Get value from cache (checks all layers)\n   */\n  async get<T>(key: string): Promise<Result<T | null, WooError>> {\n    if (!this.config.enabled) {\n      return Ok(null);\n    }\n\n    // Check each layer in order\n    for (const [layerName, layer] of this.layers) {\n      const result = await layer.get<T>(key);\n      \n      if (result.success && result.data !== null) {\n        // Promote to higher layers\n        await this.promote(key, result.data, layerName);\n        return result;\n      }\n    }\n\n    return Ok(null);\n  }\n\n  /**\n   * Set value in cache (sets in all layers)\n   */\n  async set<T>(key: string, value: T, ttl?: number): Promise<Result<void, WooError>> {\n    if (!this.config.enabled) {\n      return Ok(undefined);\n    }\n\n    const finalTtl = ttl ?? this.config.ttl;\n    const errors: WooError[] = [];\n\n    // Set in all layers\n    for (const layer of this.layers.values()) {\n      const result = await layer.set(key, value, finalTtl);\n      if (!result.success) {\n        errors.push(result.error);\n      }\n    }\n\n    if (errors.length > 0) {\n      return Err(ErrorFactory.cacheError('Failed to set in some cache layers', errors));\n    }\n\n    return Ok(undefined);\n  }\n\n  /**\n   * Delete value from all cache layers\n   */\n  async delete(key: string): Promise<Result<void, WooError>> {\n    const errors: WooError[] = [];\n\n    for (const layer of this.layers.values()) {\n      const result = await layer.delete(key);\n      if (!result.success) {\n        errors.push(result.error);\n      }\n    }\n\n    if (errors.length > 0) {\n      return Err(ErrorFactory.cacheError('Failed to delete from some cache layers', errors));\n    }\n\n    return Ok(undefined);\n  }\n\n  /**\n   * Clear all cache layers\n   */\n  async clear(): Promise<Result<void, WooError>> {\n    const errors: WooError[] = [];\n\n    for (const layer of this.layers.values()) {\n      const result = await layer.clear();\n      if (!result.success) {\n        errors.push(result.error);\n      }\n    }\n\n    if (errors.length > 0) {\n      return Err(ErrorFactory.cacheError('Failed to clear some cache layers', errors));\n    }\n\n    return Ok(undefined);\n  }\n\n  /**\n   * Check if key exists in any cache layer\n   */\n  async has(key: string): Promise<Result<boolean, WooError>> {\n    if (!this.config.enabled) {\n      return Ok(false);\n    }\n\n    for (const layer of this.layers.values()) {\n      const result = await layer.has(key);\n      if (result.success && result.data) {\n        return Ok(true);\n      }\n    }\n\n    return Ok(false);\n  }\n\n  /**\n   * Get cache statistics\n   */\n  async getStats(): Promise<Result<Record<string, number>, WooError>> {\n    const stats: Record<string, number> = {};\n\n    for (const [layerName, layer] of this.layers) {\n      const sizeResult = await layer.size();\n      if (sizeResult.success) {\n        stats[layerName] = sizeResult.data;\n      }\n    }\n\n    return Ok(stats);\n  }\n\n  /**\n   * Promote value to higher cache layers\n   */\n  private async promote<T>(key: string, value: T, foundLayer: string): Promise<void> {\n    const layerOrder = ['memory', 'localStorage', 'indexedDB'];\n    const foundIndex = layerOrder.indexOf(foundLayer);\n\n    // Promote to all layers above where it was found\n    for (let i = 0; i < foundIndex; i++) {\n      const layerName = layerOrder[i];\n      if (layerName) {\n        const layer = this.layers.get(layerName);\n        if (layer) {\n          await layer.set(key, value, this.config.ttl);\n        }\n      }\n    }\n  }\n} ","/**\n * Product management module for WooCommerce Headless SDK\n * Following the enhanced unified-10x-dev framework\n */\n\nimport { HttpClient } from '../../core/client';\nimport { CacheManager } from '../../core/cache';\nimport { Result, Ok, Err, isOk } from '../../types/result';\nimport { WooError, ErrorFactory } from '../../types/errors';\nimport { \n  WooCommerceProduct, \n  ProductVariation,\n  ProductSchema,\n  isWooCommerceProduct \n} from '../../types/commerce';\nimport { PaginationConfig, SortConfig, Filter } from '../../types/config';\nimport { z } from 'zod';\n\n/**\n * Product list parameters\n */\nexport interface ProductListParams {\n  readonly page?: number;\n  readonly limit?: number;\n  readonly search?: string;\n  readonly category?: number | string;\n  readonly tag?: number | string;\n  readonly status?: 'draft' | 'pending' | 'private' | 'publish' | 'any';\n  readonly featured?: boolean;\n  readonly inStock?: boolean;\n  readonly onSale?: boolean;\n  readonly minPrice?: number;\n  readonly maxPrice?: number;\n  readonly orderby?: 'date' | 'id' | 'include' | 'title' | 'slug' | 'price' | 'popularity' | 'rating';\n  readonly order?: 'asc' | 'desc';\n  readonly include?: number[];\n  readonly exclude?: number[];\n  readonly parent?: number[];\n  readonly offset?: number;\n}\n\n/**\n * Product list response with pagination metadata\n */\nexport interface ProductListResponse {\n  readonly products: readonly WooCommerceProduct[];\n  readonly totalProducts: number;\n  readonly totalPages: number;\n  readonly currentPage: number;\n  readonly perPage: number;\n}\n\n/**\n * Variation list parameters\n */\nexport interface VariationListParams {\n  readonly page?: number;\n  readonly limit?: number;\n  readonly search?: string;\n  readonly status?: 'draft' | 'pending' | 'private' | 'publish' | 'any';\n  readonly minPrice?: number;\n  readonly maxPrice?: number;\n  readonly inStock?: boolean;\n  readonly onSale?: boolean;\n}\n\n/**\n * Product service class\n */\nexport class ProductService {\n  private readonly client: HttpClient;\n  private readonly cache: CacheManager;\n\n  constructor(client: HttpClient, cache: CacheManager) {\n    this.client = client;\n    this.cache = cache;\n  }\n\n  /**\n   * List products with filtering and pagination\n   */\n  async list(params: ProductListParams = {}): Promise<Result<ProductListResponse, WooError>> {\n    try {\n      // Validate parameters\n      const validationResult = this.validateListParams(params);\n      if (!validationResult.success) {\n        return validationResult;\n      }\n\n      // Build query parameters\n      const queryParams = this.buildQueryParams(params);\n      const cacheKey = `products:list:${JSON.stringify(queryParams)}`;\n\n      // Check cache\n      const cachedResult = await this.cache.get<ProductListResponse>(cacheKey);\n      if (cachedResult.success && cachedResult.data) {\n        return Ok(cachedResult.data);\n      }\n\n      // Make API request\n      const response = await this.client.get<WooCommerceProduct[]>(\n        `/products?${new URLSearchParams(queryParams as any).toString()}`\n      );\n\n      if (!response.success) {\n        return response;\n      }\n\n      // Extract pagination from headers\n      const totalProducts = parseInt(response.data.headers['x-wp-total'] || '0');\n      const totalPages = parseInt(response.data.headers['x-wp-totalpages'] || '0');\n\n      // Validate response data\n      const products: WooCommerceProduct[] = [];\n      for (const product of response.data.data) {\n        try {\n          const validated = ProductSchema.parse(product);\n          products.push(validated as WooCommerceProduct);\n        } catch (error) {\n          // Skip invalid product but continue\n          // In production, this would be logged via the debug config\n        }\n      }\n\n      const result: ProductListResponse = {\n        products,\n        totalProducts,\n        totalPages,\n        currentPage: params.page || 1,\n        perPage: params.limit || 10\n      };\n\n      // Cache the result\n      await this.cache.set(cacheKey, result);\n\n      return Ok(result);\n    } catch (error) {\n      return Err(ErrorFactory.apiError(\n        'Failed to list products',\n        500,\n        error\n      ));\n    }\n  }\n\n  /**\n   * Get a single product by ID\n   */\n  async get(productId: number): Promise<Result<WooCommerceProduct, WooError>> {\n    try {\n      // Validate product ID\n      if (!productId || productId <= 0) {\n        return Err(ErrorFactory.validationError('Invalid product ID'));\n      }\n\n      const cacheKey = `products:single:${productId}`;\n\n      // Check cache\n      const cachedResult = await this.cache.get<WooCommerceProduct>(cacheKey);\n      if (cachedResult.success && cachedResult.data) {\n        return Ok(cachedResult.data);\n      }\n\n      // Make API request\n      const response = await this.client.get<WooCommerceProduct>(`/products/${productId}`);\n\n      if (!response.success) {\n        // Transform 404 to specific product not found error\n        if (response.error.statusCode === 404) {\n          return Err(ErrorFactory.productNotFoundError(productId));\n        }\n        return response;\n      }\n\n      // Validate response\n      try {\n        const validated = ProductSchema.parse(response.data.data);\n        const product = validated as WooCommerceProduct;\n\n        // Cache the result\n        await this.cache.set(cacheKey, product);\n\n        return Ok(product);\n      } catch (error) {\n        return Err(ErrorFactory.validationError(\n          'Invalid product data received from API',\n          error\n        ));\n      }\n    } catch (error) {\n      return Err(ErrorFactory.apiError(\n        'Failed to get product',\n        500,\n        error\n      ));\n    }\n  }\n\n  /**\n   * Get product by slug\n   */\n  async getBySlug(slug: string): Promise<Result<WooCommerceProduct, WooError>> {\n    try {\n      // Validate slug\n      if (!slug || slug.trim().length === 0) {\n        return Err(ErrorFactory.validationError('Invalid product slug'));\n      }\n\n      const result = await this.list({ \n        search: slug,\n        limit: 1 \n      });\n\n      if (!result.success) {\n        return result;\n      }\n\n      const product = result.data.products.find(p => p.slug === slug);\n      if (!product) {\n        return Err(ErrorFactory.productNotFoundError(slug));\n      }\n\n      return Ok(product);\n    } catch (error) {\n      return Err(ErrorFactory.apiError(\n        'Failed to get product by slug',\n        500,\n        error\n      ));\n    }\n  }\n\n  /**\n   * Get product variations\n   */\n  async getVariations(\n    productId: number, \n    params: VariationListParams = {}\n  ): Promise<Result<ProductVariation[], WooError>> {\n    try {\n      // Validate product ID\n      if (!productId || productId <= 0) {\n        return Err(ErrorFactory.validationError('Invalid product ID'));\n      }\n\n      const queryParams = this.buildVariationQueryParams(params);\n      const cacheKey = `products:${productId}:variations:${JSON.stringify(queryParams)}`;\n\n      // Check cache\n      const cachedResult = await this.cache.get<ProductVariation[]>(cacheKey);\n      if (cachedResult.success && cachedResult.data) {\n        return Ok(cachedResult.data);\n      }\n\n      // Make API request\n      const response = await this.client.get<ProductVariation[]>(\n        `/products/${productId}/variations?${new URLSearchParams(queryParams as any).toString()}`\n      );\n\n      if (!response.success) {\n        return response;\n      }\n\n      // Cache the result\n      await this.cache.set(cacheKey, response.data.data);\n\n      return Ok(response.data.data);\n    } catch (error) {\n      return Err(ErrorFactory.apiError(\n        'Failed to get product variations',\n        500,\n        error\n      ));\n    }\n  }\n\n  /**\n   * Search products by keyword\n   */\n  async search(\n    query: string, \n    params: Omit<ProductListParams, 'search'> = {}\n  ): Promise<Result<ProductListResponse, WooError>> {\n    if (!query || query.trim().length === 0) {\n      return Err(ErrorFactory.validationError('Search query cannot be empty'));\n    }\n\n    return this.list({ ...params, search: query });\n  }\n\n  /**\n   * Get products by category\n   */\n  async getByCategory(\n    categoryId: number | string,\n    params: Omit<ProductListParams, 'category'> = {}\n  ): Promise<Result<ProductListResponse, WooError>> {\n    return this.list({ ...params, category: categoryId });\n  }\n\n  /**\n   * Get featured products\n   */\n  async getFeatured(\n    params: Omit<ProductListParams, 'featured'> = {}\n  ): Promise<Result<ProductListResponse, WooError>> {\n    return this.list({ ...params, featured: true });\n  }\n\n  /**\n   * Get on-sale products\n   */\n  async getOnSale(\n    params: Omit<ProductListParams, 'onSale'> = {}\n  ): Promise<Result<ProductListResponse, WooError>> {\n    return this.list({ ...params, onSale: true });\n  }\n\n  /**\n   * Validate list parameters\n   */\n  private validateListParams(params: ProductListParams): Result<void, WooError> {\n    // Validate pagination\n    if (params.page !== undefined && params.page < 1) {\n      return Err(ErrorFactory.validationError('Page must be greater than 0'));\n    }\n\n    if (params.limit !== undefined && (params.limit < 1 || params.limit > 100)) {\n      return Err(ErrorFactory.validationError('Limit must be between 1 and 100'));\n    }\n\n    // Validate price range\n    if (params.minPrice !== undefined && params.minPrice < 0) {\n      return Err(ErrorFactory.validationError('Min price cannot be negative'));\n    }\n\n    if (params.maxPrice !== undefined && params.maxPrice < 0) {\n      return Err(ErrorFactory.validationError('Max price cannot be negative'));\n    }\n\n    if (\n      params.minPrice !== undefined && \n      params.maxPrice !== undefined && \n      params.minPrice > params.maxPrice\n    ) {\n      return Err(ErrorFactory.validationError('Min price cannot be greater than max price'));\n    }\n\n    return Ok(undefined);\n  }\n\n  /**\n   * Build query parameters for product list\n   */\n  private buildQueryParams(params: ProductListParams): Record<string, string> {\n    const queryParams: Record<string, string> = {};\n\n    if (params.page) queryParams.page = params.page.toString();\n    if (params.limit) queryParams.per_page = params.limit.toString();\n    if (params.search) queryParams.search = params.search;\n    if (params.category) queryParams.category = params.category.toString();\n    if (params.tag) queryParams.tag = params.tag.toString();\n    if (params.status) queryParams.status = params.status;\n    if (params.featured !== undefined) queryParams.featured = params.featured.toString();\n    if (params.onSale !== undefined) queryParams.on_sale = params.onSale.toString();\n    if (params.orderby) queryParams.orderby = params.orderby;\n    if (params.order) queryParams.order = params.order;\n    if (params.offset) queryParams.offset = params.offset.toString();\n\n    // Handle stock status\n    if (params.inStock !== undefined) {\n      queryParams.stock_status = params.inStock ? 'instock' : 'outofstock';\n    }\n\n    // Handle price filters (requires custom handling in WooCommerce)\n    if (params.minPrice !== undefined) {\n      queryParams.min_price = params.minPrice.toString();\n    }\n    if (params.maxPrice !== undefined) {\n      queryParams.max_price = params.maxPrice.toString();\n    }\n\n    // Handle array parameters\n    if (params.include?.length) {\n      queryParams.include = params.include.join(',');\n    }\n    if (params.exclude?.length) {\n      queryParams.exclude = params.exclude.join(',');\n    }\n    if (params.parent?.length) {\n      queryParams.parent = params.parent.join(',');\n    }\n\n    return queryParams;\n  }\n\n  /**\n   * Build query parameters for variation list\n   */\n  private buildVariationQueryParams(params: VariationListParams): Record<string, string> {\n    const queryParams: Record<string, string> = {};\n\n    if (params.page) queryParams.page = params.page.toString();\n    if (params.limit) queryParams.per_page = params.limit.toString();\n    if (params.search) queryParams.search = params.search;\n    if (params.status) queryParams.status = params.status;\n    if (params.onSale !== undefined) queryParams.on_sale = params.onSale.toString();\n\n    if (params.inStock !== undefined) {\n      queryParams.stock_status = params.inStock ? 'instock' : 'outofstock';\n    }\n\n    if (params.minPrice !== undefined) {\n      queryParams.min_price = params.minPrice.toString();\n    }\n    if (params.maxPrice !== undefined) {\n      queryParams.max_price = params.maxPrice.toString();\n    }\n\n    return queryParams;\n  }\n} ","/**\n * Cart-related TypeScript types for WooCommerce Headless SDK\n * Following the enhanced unified-10x-dev framework\n */\n\nimport { z } from 'zod';\n\n/**\n * Cart item quantity limits\n */\nexport interface CartQuantityLimits {\n  readonly min: number;\n  readonly max: number;\n  readonly step: number;\n}\n\n/**\n * Cart item metadata\n */\nexport interface CartItemMeta {\n  readonly key: string;\n  readonly value: string;\n  readonly displayKey?: string;\n  readonly displayValue?: string;\n}\n\n/**\n * Cart item interface\n */\nexport interface CartItem {\n  readonly key: string; // Unique identifier for cart item\n  readonly productId: number;\n  readonly variationId: number | undefined; // Allow undefined explicitly\n  readonly quantity: number;\n  readonly name: string;\n  readonly price: number; // Unit price\n  readonly regularPrice: number;\n  readonly salePrice: number | undefined; // Allow undefined explicitly\n  readonly totalPrice: number; // price * quantity\n  readonly total: number; // alias for totalPrice\n  readonly sku: string | undefined; // Allow undefined explicitly\n  readonly weight: number | undefined; // Allow undefined explicitly\n  readonly dimensions?: {\n    readonly length: string;\n    readonly width: string;\n    readonly height: string;\n  };\n  readonly image?: {\n    readonly id: number;\n    readonly src: string;\n    readonly alt: string;\n  };\n  readonly stockQuantity: number | undefined; // Allow undefined explicitly\n  readonly stockStatus: 'instock' | 'outofstock' | 'onbackorder';\n  readonly backorders: 'no' | 'notify' | 'yes';\n  readonly quantityLimits?: CartQuantityLimits;\n  readonly meta?: readonly CartItemMeta[];\n  readonly attributes?: Record<string, string>;\n  readonly addedAt: Date;\n  readonly updatedAt: Date;\n  readonly backordersAllowed: boolean;\n  readonly soldIndividually: boolean;\n  readonly downloadable: boolean;\n  readonly virtual: boolean;\n}\n\n/**\n * Cart totals breakdown\n */\nexport interface CartTotals {\n  readonly subtotal: number;\n  readonly subtotalTax: number;\n  readonly shippingTotal: number;\n  readonly shippingTax: number;\n  readonly discountTotal: number;\n  readonly discountTax: number;\n  readonly cartContentsTotal: number;\n  readonly cartContentsTax: number;\n  readonly feeTotal: number;\n  readonly feeTax: number;\n  readonly total: number;\n  readonly totalTax: number;\n  // Legacy aliases for backward compatibility and validation code\n  readonly tax: number; // alias for totalTax\n  readonly shipping: number; // alias for shippingTotal  \n  readonly fees: number; // alias for feeTotal\n  readonly discount: number; // alias for discountTotal\n}\n\n/**\n * Applied coupon information\n */\nexport interface AppliedCoupon {\n  readonly code: string;\n  readonly discountType: 'percent' | 'fixed_cart' | 'fixed_product';\n  readonly amount: number;\n  readonly description?: string;\n  readonly freeShipping: boolean;\n  readonly expiryDate?: Date;\n  readonly usageLimit?: number;\n  readonly usageCount: number;\n  readonly individualUse: boolean;\n  readonly productIds?: readonly number[];\n  readonly excludedProductIds?: readonly number[];\n  readonly categoryIds?: readonly number[];\n  readonly excludedCategoryIds?: readonly number[];\n  readonly minimumAmount?: number;\n  readonly maximumAmount?: number;\n}\n\n/**\n * Shipping method option\n */\nexport interface ShippingMethod {\n  readonly id: string;\n  readonly title: string;\n  readonly cost: number;\n  readonly taxable: boolean;\n  readonly taxes?: readonly {\n    readonly id: number;\n    readonly total: number;\n  }[];\n  readonly methodId: string;\n  readonly instanceId?: number;\n  readonly metaData?: readonly CartItemMeta[];\n}\n\n/**\n * Cart fees (additional charges)\n */\nexport interface CartFee {\n  readonly id: string;\n  readonly name: string;\n  readonly amount: number;\n  readonly taxable: boolean;\n  readonly taxClass?: string;\n  readonly taxes?: readonly {\n    readonly id: number;\n    readonly total: number;\n  }[];\n}\n\n/**\n * Main cart interface\n */\nexport interface Cart {\n  readonly items: readonly CartItem[];\n  readonly itemCount: number;\n  readonly totals: CartTotals;\n  readonly appliedCoupons: readonly AppliedCoupon[];\n  readonly shippingMethods: readonly ShippingMethod[];\n  readonly chosenShippingMethods: readonly string[];\n  readonly fees: readonly CartFee[];\n  readonly needsShipping: boolean;\n  readonly needsPayment: boolean;\n  readonly hasCalculatedShipping: boolean;\n  readonly currency: string;\n  readonly currencySymbol: string;\n  readonly pricesIncludeTax: boolean;\n  readonly taxDisplayMode: 'incl' | 'excl';\n  readonly crossSells: readonly number[]; // Product IDs for cross-sell suggestions\n  readonly isEmpty: boolean;\n  readonly createdAt: Date;\n  readonly updatedAt: Date;\n  readonly expiresAt?: Date; // Cart expiration for abandoned cart recovery\n  readonly customerId?: number;\n  readonly sessionId: string;\n}\n\n/**\n * Cart update request\n */\nexport interface CartUpdateRequest {\n  readonly productId: number;\n  readonly variationId?: number;\n  readonly quantity: number;\n  readonly attributes?: Record<string, string>;\n  readonly meta?: readonly CartItemMeta[];\n}\n\n/**\n * Cart add item request\n */\nexport interface CartAddItemRequest {\n  readonly productId: number;\n  readonly variationId: number | undefined; // Allow undefined explicitly\n  readonly quantity: number;\n  readonly attributes?: Record<string, string>;\n  readonly meta?: readonly CartItemMeta[];\n  readonly replace?: boolean; // Replace existing item instead of adding to quantity\n}\n\n/**\n * Cart validation result\n */\nexport interface CartValidationResult {\n  readonly isValid: boolean;\n  readonly errors: readonly {\n    readonly itemKey: string;\n    readonly code: 'OUT_OF_STOCK' | 'INSUFFICIENT_STOCK' | 'INVALID_QUANTITY' | 'PRODUCT_NOT_FOUND' | 'VARIATION_NOT_FOUND';\n    readonly message: string;\n    readonly currentStock?: number;\n    readonly requestedQuantity?: number;\n  }[];\n  readonly warnings: readonly {\n    readonly itemKey: string;\n    readonly code: 'LOW_STOCK' | 'BACKORDER' | 'PRICE_CHANGED';\n    readonly message: string;\n    readonly details?: Record<string, unknown>;\n  }[];\n}\n\n/**\n * Cart persistence options\n */\nexport interface CartPersistenceConfig {\n  readonly strategy: 'localStorage' | 'sessionStorage' | 'indexedDB' | 'server' | 'none';\n  readonly key?: string;\n  readonly encryption?: boolean;\n  readonly expirationDays?: number;\n  readonly syncToServer?: boolean;\n}\n\n/**\n * Cart synchronization status\n */\nexport type CartSyncStatus = 'idle' | 'syncing' | 'synced' | 'failed' | 'conflict';\n\n/**\n * Cart sync conflict resolution strategy\n */\nexport type CartSyncStrategy = \n  | 'merge_smart'        // Intelligent merging (recommended)\n  | 'local_wins'         // Local cart takes precedence\n  | 'server_wins'        // Server cart takes precedence\n  | 'merge_quantities'   // Merge quantities for same items\n  | 'prompt_user';       // Ask user to resolve conflicts\n\n/**\n * Cart sync configuration\n */\nexport interface CartSyncConfig {\n  readonly enabled: boolean;\n  readonly strategy: CartSyncStrategy;\n  readonly syncIntervalMs: number;        // Auto-sync interval in milliseconds\n  readonly conflictResolution: CartSyncStrategy;\n  readonly maxRetries: number;\n  readonly retryDelayMs: number;\n  readonly syncOnAuth: boolean;           // Sync immediately when user authenticates\n  readonly syncOnCartChange: boolean;     // Sync on every cart modification\n  readonly backgroundSync: boolean;       // Enable background sync\n  readonly offlineQueueSize: number;      // Max offline actions to queue\n}\n\n/**\n * Cart sync conflict information\n */\nexport interface CartSyncConflict {\n  readonly type: 'item_quantity' | 'item_missing' | 'coupon_conflict' | 'total_mismatch';\n  readonly itemKey?: string;\n  readonly localValue: unknown;\n  readonly serverValue: unknown;\n  readonly message: string;\n  readonly suggestion: string;\n}\n\n/**\n * Cart sync result\n */\nexport interface CartSyncResult {\n  readonly success: boolean;\n  readonly status: CartSyncStatus;\n  readonly conflicts: readonly CartSyncConflict[];\n  readonly mergedCart?: Cart;\n  readonly syncedAt: Date;\n  readonly changes: {\n    readonly itemsAdded: number;\n    readonly itemsUpdated: number;\n    readonly itemsRemoved: number;\n    readonly couponsAdded: number;\n    readonly couponsRemoved: number;\n  };\n}\n\n/**\n * Cart sync metadata\n */\nexport interface CartSyncMetadata {\n  readonly deviceId: string;\n  readonly lastSyncAt: Date;\n  readonly syncVersion: number;\n  readonly userId: string;\n  readonly sessionId: string;\n  readonly source: 'local' | 'server' | 'merged';\n}\n\n/**\n * Server cart data structure\n */\nexport interface ServerCartData {\n  readonly cart: Cart;\n  readonly metadata: CartSyncMetadata;\n  readonly conflicts?: readonly CartSyncConflict[];\n}\n\n/**\n * Cart configuration\n */\nexport interface CartConfig {\n  readonly persistence: CartPersistenceConfig;\n  readonly autoCalculateTotals: boolean;\n  readonly validateStock: boolean;\n  readonly allowBackorders: boolean;\n  readonly sessionTimeout: number; // minutes\n  readonly maxItems: number;\n  readonly maxQuantityPerItem: number;\n  readonly enableCoupons: boolean;\n  readonly enableShipping: boolean;\n  readonly enableFees: boolean;\n  readonly enableCrossSells: boolean;\n  readonly taxCalculation: {\n    readonly enabled: boolean;\n    readonly pricesIncludeTax: boolean;\n    readonly displayMode: 'incl' | 'excl' | 'both';\n    readonly roundAtSubtotal: boolean;\n  };\n}\n\n// Zod schemas for validation\nexport const CartItemMetaSchema = z.object({\n  key: z.string(),\n  value: z.string(),\n  displayKey: z.string().optional(),\n  displayValue: z.string().optional(),\n});\n\nexport const CartQuantityLimitsSchema = z.object({\n  min: z.number().min(0),\n  max: z.number().min(1),\n  step: z.number().min(1),\n});\n\nexport const CartItemSchema = z.object({\n  key: z.string(),\n  productId: z.number().positive(),\n  variationId: z.number().positive().optional(),\n  quantity: z.number().positive(),\n  name: z.string(),\n  price: z.number().min(0),\n  regularPrice: z.number().min(0),\n  salePrice: z.number().min(0).optional(),\n  totalPrice: z.number().min(0),\n  total: z.number().min(0),\n  sku: z.string().optional(),\n  weight: z.number().min(0).optional(),\n  dimensions: z.object({\n    length: z.string(),\n    width: z.string(),\n    height: z.string(),\n  }).optional(),\n  image: z.object({\n    id: z.number().positive(),\n    src: z.string().url(),\n    alt: z.string(),\n  }).optional(),\n  stockQuantity: z.number().min(0).optional(),\n  stockStatus: z.enum(['instock', 'outofstock', 'onbackorder']),\n  backorders: z.enum(['no', 'notify', 'yes']),\n  quantityLimits: CartQuantityLimitsSchema.optional(),\n  meta: z.array(CartItemMetaSchema).optional(),\n  attributes: z.record(z.string()).optional(),\n  addedAt: z.date(),\n  updatedAt: z.date(),\n});\n\nexport const CartTotalsSchema = z.object({\n  subtotal: z.number().min(0),\n  subtotalTax: z.number().min(0),\n  shippingTotal: z.number().min(0),\n  shippingTax: z.number().min(0),\n  discountTotal: z.number().min(0),\n  discountTax: z.number().min(0),\n  cartContentsTotal: z.number().min(0),\n  cartContentsTax: z.number().min(0),\n  feeTotal: z.number().min(0),\n  feeTax: z.number().min(0),\n  total: z.number().min(0),\n  totalTax: z.number().min(0),\n});\n\nexport const AppliedCouponSchema = z.object({\n  code: z.string(),\n  discountType: z.enum(['percent', 'fixed_cart', 'fixed_product']),\n  amount: z.number().min(0),\n  description: z.string().optional(),\n  freeShipping: z.boolean(),\n  expiryDate: z.date().optional(),\n  usageLimit: z.number().positive().optional(),\n  usageCount: z.number().min(0),\n  individualUse: z.boolean(),\n  productIds: z.array(z.number().positive()).optional(),\n  excludedProductIds: z.array(z.number().positive()).optional(),\n  categoryIds: z.array(z.number().positive()).optional(),\n  excludedCategoryIds: z.array(z.number().positive()).optional(),\n  minimumAmount: z.number().min(0).optional(),\n  maximumAmount: z.number().min(0).optional(),\n});\n\nexport const CartSchema = z.object({\n  items: z.array(CartItemSchema),\n  itemCount: z.number().min(0),\n  totals: CartTotalsSchema,\n  appliedCoupons: z.array(AppliedCouponSchema),\n  shippingMethods: z.array(z.any()), // TODO: Define shipping method schema\n  chosenShippingMethods: z.array(z.string()),\n  fees: z.array(z.any()), // TODO: Define fee schema\n  needsShipping: z.boolean(),\n  needsPayment: z.boolean(),\n  hasCalculatedShipping: z.boolean(),\n  currency: z.string(),\n  currencySymbol: z.string(),\n  pricesIncludeTax: z.boolean(),\n  taxDisplayMode: z.enum(['incl', 'excl']),\n  crossSells: z.array(z.number().positive()),\n  isEmpty: z.boolean(),\n  createdAt: z.date(),\n  updatedAt: z.date(),\n  expiresAt: z.date().optional(),\n  customerId: z.number().positive().optional(),\n  sessionId: z.string(),\n});\n\nexport const CartAddItemRequestSchema = z.object({\n  productId: z.number().positive(),\n  variationId: z.number().positive().optional(),\n  quantity: z.number().positive(),\n  attributes: z.record(z.string()).optional(),\n  meta: z.array(CartItemMetaSchema).optional(),\n  replace: z.boolean().optional(),\n});\n\nexport const CartUpdateRequestSchema = z.object({\n  productId: z.number().positive(),\n  variationId: z.number().positive().optional(), \n  quantity: z.number().positive(),\n  attributes: z.record(z.string()).optional(),\n  meta: z.array(CartItemMetaSchema).optional(),\n});\n\n// Type guards\nexport function isCartItem(obj: unknown): obj is CartItem {\n  try {\n    CartItemSchema.parse(obj);\n    return true;\n  } catch {\n    return false;\n  }\n}\n\nexport function isCart(obj: unknown): obj is Cart {\n  try {\n    CartSchema.parse(obj);\n    return true;\n  } catch {\n    return false;\n  }\n}\n\nexport function isCartAddItemRequest(obj: unknown): obj is CartAddItemRequest {\n  try {\n    CartAddItemRequestSchema.parse(obj);\n    return true;\n  } catch {\n    return false;\n  }\n} ","/**\n * Test utilities for WooCommerce Headless SDK\n * Following the enhanced unified-10x-dev framework\n */\n\nimport { WooCommerceProduct, WooCommerceOrder, WooCommerceCustomer } from '../types/commerce';\nimport { WooConfig, ResolvedWooConfig, DEFAULT_CONFIG } from '../types/config';\nimport { Result, Ok, Err } from '../types/result';\nimport { WooError, ErrorFactory } from '../types/errors';\n\n/**\n * Create a mock product\n */\nexport function createMockProduct(overrides: Partial<WooCommerceProduct> = {}): WooCommerceProduct {\n  return {\n    id: 1,\n    name: 'Test Product',\n    slug: 'test-product',\n    permalink: 'https://example.com/product/test-product',\n    date_created: '2024-01-01T00:00:00',\n    date_created_gmt: '2024-01-01T00:00:00',\n    date_modified: '2024-01-01T00:00:00',\n    date_modified_gmt: '2024-01-01T00:00:00',\n    type: 'simple',\n    status: 'publish',\n    featured: false,\n    catalog_visibility: 'visible',\n    description: 'Test product description',\n    short_description: 'Test short description',\n    sku: 'TEST-001',\n    price: '99.99',\n    regular_price: '99.99',\n    sale_price: '',\n    price_html: '<span>$99.99</span>',\n    on_sale: false,\n    purchasable: true,\n    total_sales: 0,\n    virtual: false,\n    downloadable: false,\n    downloads: [],\n    download_limit: -1,\n    download_expiry: -1,\n    external_url: '',\n    button_text: '',\n    tax_status: 'taxable',\n    tax_class: '',\n    manage_stock: false,\n    stock_status: 'instock',\n    backorders: 'no',\n    backorders_allowed: false,\n    backordered: false,\n    sold_individually: false,\n    weight: '',\n    dimensions: {\n      length: '',\n      width: '',\n      height: ''\n    },\n    shipping_required: true,\n    shipping_taxable: true,\n    shipping_class: '',\n    shipping_class_id: 0,\n    reviews_allowed: true,\n    average_rating: '0.00',\n    rating_count: 0,\n    related_ids: [],\n    upsell_ids: [],\n    cross_sell_ids: [],\n    parent_id: 0,\n    purchase_note: '',\n    categories: [],\n    tags: [],\n    images: [],\n    attributes: [],\n    default_attributes: [],\n    variations: [],\n    grouped_products: [],\n    menu_order: 0,\n    meta_data: [],\n    ...overrides\n  };\n}\n\n/**\n * Create a mock order\n */\nexport function createMockOrder(overrides: Partial<WooCommerceOrder> = {}): WooCommerceOrder {\n  return {\n    id: 1,\n    parent_id: 0,\n    status: 'processing',\n    currency: 'USD',\n    version: '8.0.0',\n    prices_include_tax: false,\n    date_created: '2024-01-01T00:00:00',\n    date_modified: '2024-01-01T00:00:00',\n    discount_total: '0.00',\n    discount_tax: '0.00',\n    shipping_total: '10.00',\n    shipping_tax: '0.00',\n    cart_tax: '0.00',\n    total: '109.99',\n    total_tax: '0.00',\n    customer_id: 1,\n    order_key: 'wc_order_abc123',\n    billing: {\n      first_name: 'John',\n      last_name: 'Doe',\n      company: '',\n      address_1: '123 Main St',\n      address_2: '',\n      city: 'New York',\n      state: 'NY',\n      postcode: '10001',\n      country: 'US',\n      email: 'john@example.com',\n      phone: '555-1234'\n    },\n    shipping: {\n      first_name: 'John',\n      last_name: 'Doe',\n      company: '',\n      address_1: '123 Main St',\n      address_2: '',\n      city: 'New York',\n      state: 'NY',\n      postcode: '10001',\n      country: 'US'\n    },\n    payment_method: 'stripe',\n    payment_method_title: 'Credit Card',\n    transaction_id: '',\n    customer_ip_address: '127.0.0.1',\n    customer_user_agent: 'Mozilla/5.0',\n    created_via: 'rest-api',\n    customer_note: '',\n    cart_hash: 'abc123',\n    number: '1',\n    meta_data: [],\n    line_items: [\n      {\n        id: 1,\n        name: 'Test Product',\n        product_id: 1,\n        variation_id: 0,\n        quantity: 1,\n        tax_class: '',\n        subtotal: '99.99',\n        subtotal_tax: '0.00',\n        total: '99.99',\n        total_tax: '0.00',\n        taxes: [],\n        meta_data: [],\n        sku: 'TEST-001',\n        price: '99.99'\n      }\n    ],\n    tax_lines: [],\n    shipping_lines: [],\n    fee_lines: [],\n    coupon_lines: [],\n    refunds: [],\n    set_paid: false,\n    ...overrides\n  };\n}\n\n/**\n * Create a mock customer\n */\nexport function createMockCustomer(overrides: Partial<WooCommerceCustomer> = {}): WooCommerceCustomer {\n  return {\n    id: 1,\n    date_created: '2024-01-01T00:00:00',\n    date_created_gmt: '2024-01-01T00:00:00',\n    date_modified: '2024-01-01T00:00:00',\n    date_modified_gmt: '2024-01-01T00:00:00',\n    email: 'customer@example.com',\n    first_name: 'John',\n    last_name: 'Doe',\n    role: 'customer',\n    username: 'johndoe',\n    billing: {\n      first_name: 'John',\n      last_name: 'Doe',\n      company: '',\n      address_1: '123 Main St',\n      address_2: '',\n      city: 'New York',\n      state: 'NY',\n      postcode: '10001',\n      country: 'US',\n      email: 'customer@example.com',\n      phone: '555-1234'\n    },\n    shipping: {\n      first_name: 'John',\n      last_name: 'Doe',\n      company: '',\n      address_1: '123 Main St',\n      address_2: '',\n      city: 'New York',\n      state: 'NY',\n      postcode: '10001',\n      country: 'US'\n    },\n    is_paying_customer: true,\n    avatar_url: 'https://secure.gravatar.com/avatar/55502f40dc8b7c769880b10874abc9d0',\n    meta_data: [],\n    ...overrides\n  };\n}\n\n/**\n * Create a mock configuration\n */\nexport function createMockConfig(overrides: Partial<WooConfig> = {}): WooConfig {\n  return {\n    baseURL: 'https://example.com',\n    consumerKey: 'ck_test123',\n    consumerSecret: 'cs_test456',\n    ...overrides\n  };\n}\n\n/**\n * Create a resolved mock configuration\n */\nexport function createResolvedMockConfig(overrides: Partial<ResolvedWooConfig> = {}): ResolvedWooConfig {\n  const baseConfig = createMockConfig();\n  return {\n    ...baseConfig,\n    version: DEFAULT_CONFIG.version,\n    environment: DEFAULT_CONFIG.environment,\n    cache: DEFAULT_CONFIG.cache,\n    auth: DEFAULT_CONFIG.auth,\n    http: DEFAULT_CONFIG.http,\n    search: DEFAULT_CONFIG.search,\n    analytics: DEFAULT_CONFIG.analytics,\n    i18n: DEFAULT_CONFIG.i18n,\n    debug: DEFAULT_CONFIG.debug,\n    ...overrides\n  };\n}\n\n/**\n * Create a mock fetch response\n */\nexport function createMockFetchResponse<T>(\n  data: T,\n  options: {\n    status?: number;\n    statusText?: string;\n    headers?: Record<string, string>;\n  } = {}\n): Response {\n  const { status = 200, statusText = 'OK', headers = {} } = options;\n  \n  return {\n    ok: status >= 200 && status < 300,\n    status,\n    statusText,\n    headers: new Headers(headers),\n    json: async () => data,\n    text: async () => JSON.stringify(data),\n    blob: async () => new Blob([JSON.stringify(data)], { type: 'application/json' }),\n    arrayBuffer: async () => new ArrayBuffer(0),\n    formData: async () => new FormData(),\n    clone: () => createMockFetchResponse(data, options),\n    body: null,\n    bodyUsed: false,\n    redirected: false,\n    type: 'basic',\n    url: 'https://example.com/api'\n  } as Response;\n}\n\n/**\n * Create a mock successful result\n */\nexport function createSuccessResult<T>(data: T): Result<T, WooError> {\n  return Ok(data);\n}\n\n/**\n * Create a mock error result\n */\nexport function createErrorResult(code: string, message: string): Result<any, WooError> {\n  switch (code) {\n    case 'NETWORK_ERROR':\n      return Err(ErrorFactory.networkError(message));\n    case 'AUTH_ERROR':\n      return Err(ErrorFactory.authError(message));\n    case 'VALIDATION_ERROR':\n      return Err(ErrorFactory.validationError(message));\n    case 'API_ERROR':\n      return Err(ErrorFactory.apiError(message, 400));\n    case 'TIMEOUT_ERROR':\n      return Err(ErrorFactory.timeoutError(message, 30000));\n    default:\n      return Err(ErrorFactory.networkError(message));\n  }\n}\n\n/**\n * Wait for a specified amount of time\n */\nexport function wait(ms: number): Promise<void> {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n\n/**\n * Create a mock abort controller\n */\nexport function createMockAbortController(): AbortController {\n  const controller = new AbortController();\n  return controller;\n}\n\n/**\n * Assert that a result is successful\n */\nexport function assertSuccess<T, E>(result: Result<T, E>): asserts result is { success: true; data: T } {\n  if (!result.success) {\n    throw new Error(`Expected success but got error: ${JSON.stringify(result.error)}`);\n  }\n}\n\n/**\n * Assert that a result is an error\n */\nexport function assertError<T, E>(result: Result<T, E>): asserts result is { success: false; error: E } {\n  if (result.success) {\n    throw new Error(`Expected error but got success: ${JSON.stringify(result.data)}`);\n  }\n}\n\n/**\n * Generate a unique ID for testing purposes\n */\nexport function generateId(): string {\n  return Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);\n} ","/**\n * Cart Synchronization Manager for WooCommerce Headless SDK\n * Handles cross-device cart synchronization with intelligent conflict resolution\n * Following the enhanced unified-10x-dev framework\n */\n\nimport { \n  Cart, \n  CartItem, \n  CartSyncConfig, \n  CartSyncStatus, \n  CartSyncStrategy,\n  CartSyncResult,\n  CartSyncConflict,\n  CartSyncMetadata,\n  ServerCartData \n} from '../../types/cart';\nimport { UserAuthContext } from '../../types/user';\nimport { Result, Ok, Err } from '../../types/result';\nimport { CartError, ErrorFactory } from '../../types/errors';\nimport { HttpClient } from '../../core/client';\n\n/**\n * Cart synchronization event handler\n */\nexport interface CartSyncEventHandler {\n  onSyncStart: () => void;\n  onSyncComplete: (result: CartSyncResult) => void;\n  onSyncError: (error: CartError) => void;\n  onConflictDetected: (conflicts: readonly CartSyncConflict[]) => void;\n}\n\n/**\n * Cart synchronization queue item\n */\nexport interface CartSyncQueueItem {\n  readonly id: string;\n  readonly action: 'add' | 'update' | 'remove' | 'clear' | 'apply_coupon' | 'remove_coupon';\n  readonly data: unknown;\n  readonly timestamp: Date;\n  readonly retryCount: number;\n}\n\n/**\n * Cart synchronization manager\n */\nexport class CartSyncManager {\n  private readonly config: CartSyncConfig;\n  private readonly httpClient: HttpClient;\n  private readonly deviceId: string;\n  \n  private syncStatus: CartSyncStatus = 'idle';\n  private lastSyncAt?: Date;\n  private backgroundSyncTimer: NodeJS.Timeout | undefined = undefined;\n  private isOnline = true;\n  private syncQueue: CartSyncQueueItem[] = [];\n  private eventHandlers: CartSyncEventHandler[] = [];\n\n  constructor(\n    config: CartSyncConfig,\n    httpClient: HttpClient,\n    deviceId?: string\n  ) {\n    this.config = config;\n    this.httpClient = httpClient;\n    this.deviceId = deviceId ?? this.generateDeviceId();\n    \n    this.setupNetworkMonitoring();\n    this.setupBackgroundSync();\n  }\n\n  /**\n   * Get current sync status\n   */\n  getStatus(): CartSyncStatus {\n    return this.syncStatus;\n  }\n\n  /**\n   * Get last sync timestamp\n   */\n  getLastSyncAt(): Date | undefined {\n    return this.lastSyncAt;\n  }\n\n  /**\n   * Add event handler\n   */\n  addEventHandler(handler: CartSyncEventHandler): void {\n    this.eventHandlers.push(handler);\n  }\n\n  /**\n   * Remove event handler\n   */\n  removeEventHandler(handler: CartSyncEventHandler): void {\n    const index = this.eventHandlers.indexOf(handler);\n    if (index > -1) {\n      this.eventHandlers.splice(index, 1);\n    }\n  }\n\n  /**\n   * Sync cart with server\n   */\n  async syncCart(\n    localCart: Cart,\n    authContext: UserAuthContext\n  ): Promise<Result<CartSyncResult, CartError>> {\n    if (!this.config.enabled) {\n      return Ok({\n        success: true,\n        status: 'idle',\n        conflicts: [],\n        syncedAt: new Date(),\n        changes: {\n          itemsAdded: 0,\n          itemsUpdated: 0,\n          itemsRemoved: 0,\n          couponsAdded: 0,\n          couponsRemoved: 0\n        }\n      });\n    }\n\n    if (!authContext.isAuthenticated || !authContext.userId) {\n      return Err(ErrorFactory.cartError(\n        'User must be authenticated for cart synchronization',\n        { context: 'sync_cart' }\n      ));\n    }\n\n    this.setSyncStatus('syncing');\n    this.notifyEventHandlers('onSyncStart');\n\n    try {\n      // Fetch server cart\n      const serverCartResult = await this.fetchServerCart(authContext.userId);\n      if (!serverCartResult.success) {\n        this.setSyncStatus('failed');\n        this.notifyEventHandlers('onSyncError', serverCartResult.error);\n        return serverCartResult;\n      }\n\n      const serverCartData = serverCartResult.data;\n      \n      // If no server cart exists, upload local cart\n      if (!serverCartData) {\n        const uploadResult = await this.uploadCart(localCart, authContext);\n        if (!uploadResult.success) {\n          this.setSyncStatus('failed');\n          this.notifyEventHandlers('onSyncError', uploadResult.error);\n          return uploadResult;\n        }\n\n        const result: CartSyncResult = {\n          success: true,\n          status: 'synced',\n          conflicts: [],\n          mergedCart: localCart,\n          syncedAt: new Date(),\n          changes: {\n            itemsAdded: 0,\n            itemsUpdated: 0,\n            itemsRemoved: 0,\n            couponsAdded: 0,\n            couponsRemoved: 0\n          }\n        };\n\n        this.setSyncStatus('synced');\n        this.lastSyncAt = new Date();\n        this.notifyEventHandlers('onSyncComplete', result);\n        return Ok(result);\n      }\n\n      // Merge carts with conflict detection\n      const mergeResult = await this.mergeCarts(localCart, serverCartData.cart);\n      if (!mergeResult.success) {\n        this.setSyncStatus('failed');\n        this.notifyEventHandlers('onSyncError', mergeResult.error);\n        return mergeResult;\n      }\n\n      const { mergedCart, conflicts, changes } = mergeResult.data;\n\n      // Handle conflicts if any\n      if (conflicts.length > 0) {\n        this.setSyncStatus('conflict');\n        this.notifyEventHandlers('onConflictDetected', conflicts);\n        \n        // Auto-resolve conflicts based on strategy\n        const resolveResult = await this.resolveConflicts(\n          localCart,\n          serverCartData.cart,\n          conflicts,\n          this.config.conflictResolution\n        );\n        \n        if (!resolveResult.success) {\n          this.setSyncStatus('failed');\n          this.notifyEventHandlers('onSyncError', resolveResult.error);\n          return resolveResult;\n        }\n      }\n\n      // Upload merged cart to server\n      const uploadResult = await this.uploadCart(mergedCart, authContext);\n      if (!uploadResult.success) {\n        this.setSyncStatus('failed');\n        this.notifyEventHandlers('onSyncError', uploadResult.error);\n        return uploadResult;\n      }\n\n      const result: CartSyncResult = {\n        success: true,\n        status: 'synced',\n        conflicts,\n        mergedCart,\n        syncedAt: new Date(),\n        changes\n      };\n\n      this.setSyncStatus('synced');\n      this.lastSyncAt = new Date();\n      this.notifyEventHandlers('onSyncComplete', result);\n\n      return Ok(result);\n    } catch (error) {\n      const cartError = ErrorFactory.cartError(\n        'Cart synchronization failed',\n        { error: error instanceof Error ? error.message : 'Unknown error' }\n      );\n      \n      this.setSyncStatus('failed');\n      this.notifyEventHandlers('onSyncError', cartError);\n      return Err(cartError);\n    }\n  }\n\n  /**\n   * Queue cart action for offline sync\n   */\n  queueAction(\n    action: CartSyncQueueItem['action'],\n    data: unknown\n  ): void {\n    if (!this.config.enabled || this.isOnline) {\n      return;\n    }\n\n    const queueItem: CartSyncQueueItem = {\n      id: this.generateId(),\n      action,\n      data,\n      timestamp: new Date(),\n      retryCount: 0\n    };\n\n    this.syncQueue.push(queueItem);\n\n    // Limit queue size\n    if (this.syncQueue.length > this.config.offlineQueueSize) {\n      this.syncQueue.shift(); // Remove oldest item\n    }\n  }\n\n  /**\n   * Process offline sync queue\n   */\n  async processQueue(\n    localCart: Cart,\n    authContext: UserAuthContext\n  ): Promise<Result<void, CartError>> {\n    if (!this.config.enabled || !authContext.isAuthenticated || this.syncQueue.length === 0) {\n      return Ok(undefined);\n    }\n\n    const failedItems: CartSyncQueueItem[] = [];\n\n    for (const item of this.syncQueue) {\n      try {\n        // Process each queued action\n        await this.processQueueItem(item, localCart, authContext);\n      } catch (error) {\n        item.retryCount++;\n        if (item.retryCount < this.config.maxRetries) {\n          failedItems.push(item);\n        }\n      }\n    }\n\n    // Update queue with failed items\n    this.syncQueue = failedItems;\n    \n    return Ok(undefined);\n  }\n\n  /**\n   * Enable cart synchronization\n   */\n  enable(): void {\n    this.config = {\n      ...this.config,\n      enabled: true\n    };\n    this.setupBackgroundSync();\n  }\n\n  /**\n   * Disable cart synchronization\n   */\n  disable(): void {\n    this.config = {\n      ...this.config,\n      enabled: false\n    };\n    this.stopBackgroundSync();\n  }\n\n  /**\n   * Clean up resources\n   */\n  destroy(): void {\n    this.stopBackgroundSync();\n    this.eventHandlers.length = 0;\n    this.syncQueue.length = 0;\n  }\n\n  // PRIVATE METHODS\n\n  /**\n   * Fetch cart from server\n   */\n  private async fetchServerCart(userId: string): Promise<Result<ServerCartData | null, CartError>> {\n    try {\n      const response = await this.httpClient.get(`/cart/sync/${userId}`);\n      \n      if (response.status === 404) {\n        return Ok(null); // No server cart exists\n      }\n\n      if (!response.success) {\n        return Err(ErrorFactory.cartError(\n          'Failed to fetch server cart',\n          { status: response.status, error: response.error }\n        ));\n      }\n\n      return Ok(response.data as ServerCartData);\n    } catch (error) {\n      return Err(ErrorFactory.cartError(\n        'Network error while fetching server cart',\n        { error: error instanceof Error ? error.message : 'Unknown error' }\n      ));\n    }\n  }\n\n  /**\n   * Upload cart to server\n   */\n  private async uploadCart(\n    cart: Cart,\n    authContext: UserAuthContext\n  ): Promise<Result<void, CartError>> {\n    if (!authContext.isAuthenticated || !authContext.userId) {\n      return Err(ErrorFactory.cartError(\n        'User must be authenticated to upload cart',\n        { context: 'upload_cart' }\n      ));\n    }\n\n    const metadata: CartSyncMetadata = {\n      deviceId: this.deviceId,\n      lastSyncAt: new Date(),\n      syncVersion: 1,\n      userId: authContext.userId,\n      sessionId: cart.sessionId,\n      source: 'local'\n    };\n\n    const serverCartData: ServerCartData = {\n      cart,\n      metadata\n    };\n\n    try {\n      const response = await this.httpClient.put(`/cart/sync/${authContext.userId}`, serverCartData);\n      \n      if (!response.success) {\n        return Err(ErrorFactory.cartError(\n          'Failed to upload cart to server',\n          { status: response.status, error: response.error }\n        ));\n      }\n\n      return Ok(undefined);\n    } catch (error) {\n      return Err(ErrorFactory.cartError(\n        'Network error while uploading cart',\n        { error: error instanceof Error ? error.message : 'Unknown error' }\n      ));\n    }\n  }\n\n  /**\n   * Merge local and server carts with conflict detection\n   */\n  private async mergeCarts(\n    localCart: Cart,\n    serverCart: Cart\n  ): Promise<Result<{\n    mergedCart: Cart;\n    conflicts: CartSyncConflict[];\n    changes: CartSyncResult['changes'];\n  }, CartError>> {\n    const conflicts: CartSyncConflict[] = [];\n    const changes = {\n      itemsAdded: 0,\n      itemsUpdated: 0,\n      itemsRemoved: 0,\n      couponsAdded: 0,\n      couponsRemoved: 0\n    };\n\n    try {\n      // Merge items using the configured strategy\n      const itemMergeResult = await this.mergeCartItems(\n        localCart.items,\n        serverCart.items,\n        this.config.strategy\n      );\n      \n      if (!itemMergeResult.success) {\n        return itemMergeResult;\n      }\n\n      const { mergedItems, itemConflicts } = itemMergeResult.data;\n      conflicts.push(...itemConflicts);\n\n      // Count changes\n      changes.itemsAdded = mergedItems.filter(item => \n        !localCart.items.some(local => local.key === item.key)\n      ).length;\n      \n      changes.itemsUpdated = mergedItems.filter(item => {\n        const localItem = localCart.items.find(local => local.key === item.key);\n        return localItem && localItem.quantity !== item.quantity;\n      }).length;\n\n      changes.itemsRemoved = localCart.items.filter(item =>\n        !mergedItems.some(merged => merged.key === item.key)\n      ).length;\n\n      // Merge coupons\n      const couponMergeResult = this.mergeCoupons(\n        localCart.appliedCoupons,\n        serverCart.appliedCoupons\n      );\n      \n      conflicts.push(...couponMergeResult.conflicts);\n      changes.couponsAdded = couponMergeResult.couponsAdded;\n      changes.couponsRemoved = couponMergeResult.couponsRemoved;\n\n      // Create merged cart\n      const mergedCart: Cart = {\n        ...localCart,\n        items: mergedItems,\n        appliedCoupons: couponMergeResult.mergedCoupons,\n        itemCount: mergedItems.reduce((sum, item) => sum + item.quantity, 0),\n        updatedAt: new Date()\n      };\n\n      return Ok({\n        mergedCart,\n        conflicts,\n        changes\n      });\n    } catch (error) {\n      return Err(ErrorFactory.cartError(\n        'Failed to merge carts',\n        { error: error instanceof Error ? error.message : 'Unknown error' }\n      ));\n    }\n  }\n\n  /**\n   * Merge cart items with conflict detection\n   */\n  private async mergeCartItems(\n    localItems: readonly CartItem[],\n    serverItems: readonly CartItem[],\n    strategy: CartSyncStrategy\n  ): Promise<Result<{\n    mergedItems: CartItem[];\n    itemConflicts: CartSyncConflict[];\n  }, CartError>> {\n    const mergedItems: CartItem[] = [];\n    const itemConflicts: CartSyncConflict[] = [];\n    const processedKeys = new Set<string>();\n\n    try {\n      // Process local items\n      for (const localItem of localItems) {\n        const serverItem = serverItems.find(item => item.key === localItem.key);\n        processedKeys.add(localItem.key);\n\n        if (!serverItem) {\n          // Item only exists locally\n          mergedItems.push(localItem);\n        } else if (localItem.quantity === serverItem.quantity) {\n          // No conflict, use local item (more recent updates)\n          mergedItems.push(localItem);\n        } else {\n          // Quantity conflict detected\n          const conflict: CartSyncConflict = {\n            type: 'item_quantity',\n            itemKey: localItem.key,\n            localValue: localItem.quantity,\n            serverValue: serverItem.quantity,\n            message: `Quantity mismatch for ${localItem.name}`,\n            suggestion: this.getQuantityMergeSuggestion(strategy, localItem.quantity, serverItem.quantity)\n          };\n          \n          itemConflicts.push(conflict);\n\n          // Auto-resolve based on strategy\n          const resolvedQuantity = this.resolveQuantityConflict(\n            strategy,\n            localItem.quantity,\n            serverItem.quantity\n          );\n\n          mergedItems.push({\n            ...localItem,\n            quantity: resolvedQuantity,\n            totalPrice: localItem.price * resolvedQuantity,\n            updatedAt: new Date()\n          });\n        }\n      }\n\n      // Process server items not in local cart\n      for (const serverItem of serverItems) {\n        if (!processedKeys.has(serverItem.key)) {\n          mergedItems.push(serverItem);\n        }\n      }\n\n      return Ok({\n        mergedItems,\n        itemConflicts\n      });\n    } catch (error) {\n      return Err(ErrorFactory.cartError(\n        'Failed to merge cart items',\n        { error: error instanceof Error ? error.message : 'Unknown error' }\n      ));\n    }\n  }\n\n  /**\n   * Merge applied coupons\n   */\n  private mergeCoupons(\n    localCoupons: readonly Cart['appliedCoupons'][0][],\n    serverCoupons: readonly Cart['appliedCoupons'][0][]\n  ): {\n    mergedCoupons: Cart['appliedCoupons'][0][];\n    conflicts: CartSyncConflict[];\n    couponsAdded: number;\n    couponsRemoved: number;\n  } {\n    const mergedCoupons: Cart['appliedCoupons'][0][] = [];\n    const conflicts: CartSyncConflict[] = [];\n    const processedCodes = new Set<string>();\n\n    let couponsAdded = 0;\n    let couponsRemoved = 0;\n\n    // Add local coupons\n    for (const localCoupon of localCoupons) {\n      processedCodes.add(localCoupon.code);\n      mergedCoupons.push(localCoupon);\n    }\n\n    // Add server coupons that don't exist locally\n    for (const serverCoupon of serverCoupons) {\n      if (!processedCodes.has(serverCoupon.code)) {\n        mergedCoupons.push(serverCoupon);\n        couponsAdded++;\n      }\n    }\n\n    // Count removed coupons\n    couponsRemoved = serverCoupons.filter(coupon => \n      !localCoupons.some(local => local.code === coupon.code)\n    ).length;\n\n    return {\n      mergedCoupons,\n      conflicts,\n      couponsAdded,\n      couponsRemoved\n    };\n  }\n\n  /**\n   * Resolve conflicts based on strategy\n   */\n  private async resolveConflicts(\n    localCart: Cart,\n    serverCart: Cart,\n    conflicts: readonly CartSyncConflict[],\n    strategy: CartSyncStrategy\n  ): Promise<Result<Cart, CartError>> {\n    // For now, conflicts are auto-resolved during merge\n    // In the future, this could prompt the user or apply more sophisticated resolution\n    return Ok(localCart);\n  }\n\n  /**\n   * Resolve quantity conflict based on strategy\n   */\n  private resolveQuantityConflict(\n    strategy: CartSyncStrategy,\n    localQuantity: number,\n    serverQuantity: number\n  ): number {\n    switch (strategy) {\n      case 'local_wins':\n        return localQuantity;\n      case 'server_wins':\n        return serverQuantity;\n      case 'merge_quantities':\n        return localQuantity + serverQuantity;\n      case 'merge_smart':\n      default:\n        // Use the higher quantity (assumes user wants more items)\n        return Math.max(localQuantity, serverQuantity);\n    }\n  }\n\n  /**\n   * Get quantity merge suggestion for conflict\n   */\n  private getQuantityMergeSuggestion(\n    strategy: CartSyncStrategy,\n    localQuantity: number,\n    serverQuantity: number\n  ): string {\n    switch (strategy) {\n      case 'local_wins':\n        return `Keep local quantity: ${localQuantity}`;\n      case 'server_wins':\n        return `Use server quantity: ${serverQuantity}`;\n      case 'merge_quantities':\n        return `Add quantities: ${localQuantity + serverQuantity}`;\n      case 'merge_smart':\n      default:\n        return `Use higher quantity: ${Math.max(localQuantity, serverQuantity)}`;\n    }\n  }\n\n  /**\n   * Process individual queue item\n   */\n  private async processQueueItem(\n    item: CartSyncQueueItem,\n    localCart: Cart,\n    authContext: UserAuthContext\n  ): Promise<void> {\n    // This is a placeholder for processing offline actions\n    // In a real implementation, this would replay the action on the server\n    console.warn('Cart sync queue processing not yet implemented for action:', item.action);\n  }\n\n  /**\n   * Set sync status and notify handlers\n   */\n  private setSyncStatus(status: CartSyncStatus): void {\n    this.syncStatus = status;\n  }\n\n  /**\n   * Notify event handlers\n   */\n  private notifyEventHandlers(\n    event: keyof CartSyncEventHandler,\n    ...args: unknown[]\n  ): void {\n    for (const handler of this.eventHandlers) {\n      try {\n        switch (event) {\n          case 'onSyncStart':\n            handler.onSyncStart();\n            break;\n          case 'onSyncComplete':\n            handler.onSyncComplete(args[0] as CartSyncResult);\n            break;\n          case 'onSyncError':\n            handler.onSyncError(args[0] as CartError);\n            break;\n          case 'onConflictDetected':\n            handler.onConflictDetected(args[0] as readonly CartSyncConflict[]);\n            break;\n        }\n      } catch (error) {\n        console.error('Error in cart sync event handler:', error);\n      }\n    }\n  }\n\n  /**\n   * Setup network monitoring\n   */\n  private setupNetworkMonitoring(): void {\n    if (typeof navigator !== 'undefined' && 'onLine' in navigator) {\n      this.isOnline = navigator.onLine;\n      \n      window.addEventListener('online', () => {\n        this.isOnline = true;\n      });\n      \n      window.addEventListener('offline', () => {\n        this.isOnline = false;\n      });\n    }\n  }\n\n  /**\n   * Setup background sync timer\n   */  \n  private setupBackgroundSync(): void {\n    if (!this.config.enabled || !this.config.backgroundSync) {\n      return;\n    }\n\n    this.stopBackgroundSync();\n    \n    this.backgroundSyncTimer = setInterval(() => {\n      // Background sync will be triggered by the cart service\n      // when it has access to the current cart and auth context\n    }, this.config.syncIntervalMs);\n  }\n\n  /**\n   * Stop background sync timer\n   */\n  private stopBackgroundSync(): void {\n    if (this.backgroundSyncTimer) {\n      clearInterval(this.backgroundSyncTimer);\n      this.backgroundSyncTimer = undefined;\n    }\n  }\n\n  /**\n   * Generate unique device ID\n   */\n  private generateDeviceId(): string {\n    if (typeof crypto !== 'undefined' && crypto.randomUUID) {\n      return crypto.randomUUID();\n    }\n    \n    // Fallback for environments without crypto.randomUUID\n    return 'device-' + Math.random().toString(36).substring(2, 15) + \n           Math.random().toString(36).substring(2, 15);\n  }\n\n  /**\n   * Generate unique ID\n   */\n  private generateId(): string {\n    return Date.now().toString(36) + Math.random().toString(36).substring(2);\n  }\n} ","/**\n * Cart management module for WooCommerce Headless SDK\n * Following the enhanced unified-10x-dev framework\n */\n\nimport { HttpClient } from '../../core/client';\nimport { CacheManager } from '../../core/cache';\nimport { Result, Ok, Err, isErr, unwrap } from '../../types/result';\nimport { WooError, ErrorFactory } from '../../types/errors';\nimport { \n  WooCommerceProduct,\n  WooCommerceCoupon\n} from '../../types/commerce';\nimport {\n  Cart,\n  CartItem,\n  CartAddItemRequest,\n  CartTotals,\n  CartValidationResult,\n  CartPersistenceConfig,\n  AppliedCoupon,\n  ShippingMethod,\n  CartFee,\n  CartAddItemRequestSchema,\n  CartSyncResult,\n  CartSyncStatus,\n  isCart\n} from '../../types/cart';\nimport { CartConfig } from '../../types/config';\nimport { UserAuthContext } from '../../types/user';\nimport { generateId } from '../../test/utils';\nimport { CartSyncManager, CartSyncEventHandler } from './sync';\n\n/**\n * Cart persistence manager for handling cart storage\n */\nclass CartPersistenceManager {\n  private readonly config: CartPersistenceConfig;\n\n  constructor(config: CartPersistenceConfig) {\n    this.config = config;\n  }\n\n  /**\n   * Save cart to persistent storage\n   */\n  async save(cart: Cart): Promise<Result<void, WooError>> {\n    try {\n      const serialized = JSON.stringify(cart, (key, value) => {\n        // Convert dates to ISO strings for serialization\n        if (value instanceof Date) {\n          return value.toISOString();\n        }\n        return value;\n      });\n\n      switch (this.config.strategy) {\n        case 'localStorage':\n          if (typeof localStorage !== 'undefined') {\n            localStorage.setItem(this.getStorageKey(), serialized);\n          }\n          break;\n\n        case 'sessionStorage':\n          if (typeof sessionStorage !== 'undefined') {\n            sessionStorage.setItem(this.getStorageKey(), serialized);\n          }\n          break;\n\n        case 'indexedDB':\n          return this.saveToIndexedDB(cart);\n\n        case 'server':\n          return this.saveToServer(cart);\n\n        case 'none':\n          // No persistence\n          break;\n\n        default:\n          return Err(ErrorFactory.configurationError('Invalid persistence strategy'));\n      }\n\n      return Ok(undefined);\n    } catch (error) {\n      return Err(ErrorFactory.persistenceError(\n        'Failed to save cart',\n        error\n      ));\n    }\n  }\n\n  /**\n   * Load cart from persistent storage\n   */\n  async load(): Promise<Result<Cart | null, WooError>> {\n    try {\n      let serialized: string | null = null;\n\n      switch (this.config.strategy) {\n        case 'localStorage':\n          if (typeof localStorage !== 'undefined') {\n            serialized = localStorage.getItem(this.getStorageKey());\n          }\n          break;\n\n        case 'sessionStorage':\n          if (typeof sessionStorage !== 'undefined') {\n            serialized = sessionStorage.getItem(this.getStorageKey());\n          }\n          break;\n\n        case 'indexedDB':\n          return this.loadFromIndexedDB();\n\n        case 'server':\n          return this.loadFromServer();\n\n        case 'none':\n          return Ok(null);\n\n        default:\n          return Err(ErrorFactory.configurationError('Invalid persistence strategy'));\n      }\n\n      if (!serialized) {\n        return Ok(null);\n      }\n\n      const parsed = JSON.parse(serialized, (key, value) => {\n        // Convert ISO strings back to dates\n        if (typeof value === 'string' && /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}/.test(value)) {\n          return new Date(value);\n        }\n        return value;\n      });\n\n      // Validate the parsed cart\n      if (isCart(parsed)) {\n        return Ok(parsed);\n      } else {\n        return Err(ErrorFactory.validationError('Invalid cart data in storage'));\n      }\n    } catch (error) {\n      return Err(ErrorFactory.persistenceError(\n        'Failed to load cart',\n        error\n      ));\n    }\n  }\n\n  /**\n   * Clear cart from persistent storage\n   */\n  async clear(): Promise<Result<void, WooError>> {\n    try {\n      switch (this.config.strategy) {\n        case 'localStorage':\n          if (typeof localStorage !== 'undefined') {\n            localStorage.removeItem(this.getStorageKey());\n          }\n          break;\n\n        case 'sessionStorage':\n          if (typeof sessionStorage !== 'undefined') {\n            sessionStorage.removeItem(this.getStorageKey());\n          }\n          break;\n\n        case 'indexedDB':\n          return this.clearFromIndexedDB();\n\n        case 'server':\n          return this.clearFromServer();\n\n        case 'none':\n          // No persistence to clear\n          break;\n\n        default:\n          return Err(ErrorFactory.configurationError('Invalid persistence strategy'));\n      }\n\n      return Ok(undefined);\n    } catch (error) {\n      return Err(ErrorFactory.persistenceError(\n        'Failed to clear cart',\n        error\n      ));\n    }\n  }\n\n  private getStorageKey(): string {\n    return this.config.key || 'woo-headless-cart';\n  }\n\n  private async saveToIndexedDB(cart: Cart): Promise<Result<void, WooError>> {\n    try {\n      if (typeof window === 'undefined' || !window.indexedDB) {\n        return Err(ErrorFactory.persistenceError('IndexedDB not available'));\n      }\n\n      const db = await this.openIndexedDB();\n      const transaction = db.transaction(['carts'], 'readwrite');\n      const store = transaction.objectStore('carts');\n      \n      await new Promise<void>((resolve, reject) => {\n        const request = store.put({\n          id: this.getStorageKey(),\n          cart: cart,\n          timestamp: Date.now(),\n          expiresAt: this.config.expirationDays ? \n            Date.now() + (this.config.expirationDays * 24 * 60 * 60 * 1000) : \n            null\n        });\n        \n        request.onsuccess = () => resolve();\n        request.onerror = () => reject(request.error);\n      });\n\n      db.close();\n      return Ok(undefined);\n    } catch (error) {\n      return Err(ErrorFactory.persistenceError(\n        'Failed to save cart to IndexedDB',\n        error\n      ));\n    }\n  }\n\n  private async loadFromIndexedDB(): Promise<Result<Cart | null, WooError>> {\n    try {\n      if (typeof window === 'undefined' || !window.indexedDB) {\n        return Ok(null);\n      }\n\n      const db = await this.openIndexedDB();\n      const transaction = db.transaction(['carts'], 'readonly');\n      const store = transaction.objectStore('carts');\n      \n      const result = await new Promise<any>((resolve, reject) => {\n        const request = store.get(this.getStorageKey());\n        request.onsuccess = () => resolve(request.result);\n        request.onerror = () => reject(request.error);\n      });\n\n      db.close();\n\n      if (!result) {\n        return Ok(null);\n      }\n\n      // Check expiration\n      if (result.expiresAt && Date.now() > result.expiresAt) {\n        await this.clearFromIndexedDB();\n        return Ok(null);\n      }\n\n      // Validate the loaded cart\n      if (isCart(result.cart)) {\n        return Ok(result.cart);\n      } else {\n        return Err(ErrorFactory.validationError('Invalid cart data in IndexedDB'));\n      }\n    } catch (error) {\n      return Err(ErrorFactory.persistenceError(\n        'Failed to load cart from IndexedDB',\n        error\n      ));\n    }\n  }\n\n  private async clearFromIndexedDB(): Promise<Result<void, WooError>> {\n    try {\n      if (typeof window === 'undefined' || !window.indexedDB) {\n        return Ok(undefined);\n      }\n\n      const db = await this.openIndexedDB();\n      const transaction = db.transaction(['carts'], 'readwrite');\n      const store = transaction.objectStore('carts');\n      \n      await new Promise<void>((resolve, reject) => {\n        const request = store.delete(this.getStorageKey());\n        request.onsuccess = () => resolve();\n        request.onerror = () => reject(request.error);\n      });\n\n      db.close();\n      return Ok(undefined);\n    } catch (error) {\n      return Err(ErrorFactory.persistenceError(\n        'Failed to clear cart from IndexedDB',\n        error\n      ));\n    }\n  }\n\n  private async openIndexedDB(): Promise<IDBDatabase> {\n    return new Promise((resolve, reject) => {\n      const request = indexedDB.open('WooHeadlessCart', 1);\n      \n      request.onerror = () => reject(request.error);\n      request.onsuccess = () => resolve(request.result);\n      \n      request.onupgradeneeded = (event) => {\n        const db = (event.target as IDBOpenDBRequest).result;\n        if (!db.objectStoreNames.contains('carts')) {\n          const store = db.createObjectStore('carts', { keyPath: 'id' });\n          store.createIndex('timestamp', 'timestamp', { unique: false });\n          store.createIndex('expiresAt', 'expiresAt', { unique: false });\n        }\n      };\n    });\n  }\n\n  private async saveToServer(cart: Cart): Promise<Result<void, WooError>> {\n    try {\n      if (!this.config.syncToServer) {\n        return Err(ErrorFactory.configurationError(\n          'Server sync is disabled',\n          'Enable syncToServer in cart persistence config'\n        ));\n      }\n\n      // This would integrate with your server-side cart API\n      // For now, we'll implement a basic HTTP client integration\n      const cartData = {\n        sessionId: cart.sessionId,\n        customerId: cart.customerId,\n        items: cart.items,\n        totals: cart.totals,\n        appliedCoupons: cart.appliedCoupons,\n        updatedAt: cart.updatedAt.toISOString(),\n        expiresAt: cart.expiresAt?.toISOString()\n      };\n\n      // TODO: This should use the HttpClient instance from the service\n      // For now, we'll use a placeholder that developers can implement\n      console.warn('Server-side cart persistence requires custom implementation');\n      console.log('Cart data to sync:', cartData);\n      \n      return Ok(undefined);\n    } catch (error) {\n      return Err(ErrorFactory.persistenceError(\n        'Failed to save cart to server',\n        error\n      ));\n    }\n  }\n\n  private async loadFromServer(): Promise<Result<Cart | null, WooError>> {\n    try {\n      if (!this.config.syncToServer) {\n        return Ok(null);\n      }\n\n      // This would integrate with your server-side cart API\n      // Developers should implement their own server integration\n      console.warn('Server-side cart persistence requires custom implementation');\n      \n      // Return null for now - developers can override this method\n      return Ok(null);\n    } catch (error) {\n      return Err(ErrorFactory.persistenceError(\n        'Failed to load cart from server',\n        error\n      ));\n    }\n  }\n\n  private async clearFromServer(): Promise<Result<void, WooError>> {\n    try {\n      if (!this.config.syncToServer) {\n        return Ok(undefined);\n      }\n\n      // This would integrate with your server-side cart API\n      console.warn('Server-side cart persistence requires custom implementation');\n      \n      return Ok(undefined);\n    } catch (error) {\n      return Err(ErrorFactory.persistenceError(\n        'Failed to clear cart from server',\n        error\n      ));\n    }\n  }\n}\n\n/**\n * Advanced cart totals calculator with comprehensive tax, shipping, and discount handling\n */\nclass CartTotalsCalculator {\n  private readonly config: CartConfig;\n\n  constructor(config: CartConfig) {\n    this.config = config;\n  }\n\n  /**\n   * Calculate comprehensive cart totals\n   */\n  calculate(\n    items: readonly CartItem[], \n    appliedCoupons: readonly AppliedCoupon[] = [],\n    shippingMethods: readonly ShippingMethod[] = [],\n    fees: readonly CartFee[] = [],\n    customerData?: { taxRate?: number; country?: string; state?: string }\n  ): CartTotals {\n    // Step 1: Calculate item subtotals\n    const subtotal = this.calculateSubtotal(items);\n    const subtotalTax = this.calculateSubtotalTax(items, customerData);\n\n    // Step 2: Calculate discount amounts\n    const { discountTotal, discountTax } = this.calculateDiscounts(items, appliedCoupons, customerData);\n\n    // Step 3: Calculate cart contents after discounts\n    const cartContentsTotal = Math.max(0, subtotal - discountTotal);\n    const cartContentsTax = Math.max(0, subtotalTax - discountTax);\n\n    // Step 4: Calculate shipping\n    const { shippingTotal, shippingTax } = this.calculateShipping(shippingMethods, cartContentsTotal, customerData);\n\n    // Step 5: Calculate fees\n    const { feeTotal, feeTax } = this.calculateFees(fees, cartContentsTotal, customerData);\n\n    // Step 6: Calculate final totals\n    const totalTax = cartContentsTax + shippingTax + feeTax;\n    const total = this.calculateFinalTotal(cartContentsTotal, shippingTotal, feeTotal, totalTax);\n\n    return {\n      subtotal: this.roundTotal(subtotal),\n      subtotalTax: this.roundTotal(subtotalTax),\n      tax: this.roundTotal(totalTax),\n      shipping: this.roundTotal(shippingTotal),\n      shippingTotal: this.roundTotal(shippingTotal), // alias for shipping\n      shippingTax: this.roundTotal(shippingTax),\n      discount: this.roundTotal(discountTotal),\n      discountTotal: this.roundTotal(discountTotal), // alias for discount\n      discountTax: this.roundTotal(discountTax),\n      fees: this.roundTotal(feeTotal),\n      feeTotal: this.roundTotal(feeTotal), // alias for fees\n      feeTax: this.roundTotal(feeTax),\n      total: this.roundTotal(total),\n      totalTax: this.roundTotal(totalTax),\n      cartContentsTotal: this.roundTotal(cartContentsTotal),\n      cartContentsTax: this.roundTotal(cartContentsTax)\n    };\n  }\n\n  private calculateSubtotal(items: readonly CartItem[]): number {\n    return items.reduce((sum, item) => {\n      if (this.config.taxCalculation.pricesIncludeTax) {\n        // If prices include tax, use the item price directly\n        return sum + item.totalPrice;\n      } else {\n        // Use regular price without tax\n        return sum + (item.regularPrice * item.quantity);\n      }\n    }, 0);\n  }\n\n  private calculateSubtotalTax(\n    items: readonly CartItem[], \n    customerData?: { taxRate?: number; country?: string; state?: string }\n  ): number {\n    if (!this.config.taxCalculation.enabled) {\n      return 0;\n    }\n\n    const taxRate = customerData?.taxRate || this.getDefaultTaxRate(customerData?.country, customerData?.state);\n    \n    return items.reduce((sum, item) => {\n      const itemSubtotal = item.regularPrice * item.quantity;\n      \n      if (this.config.taxCalculation.pricesIncludeTax) {\n        // Extract tax from price that includes tax\n        return sum + (itemSubtotal * taxRate / (1 + taxRate));\n      } else {\n        // Calculate tax on price that excludes tax\n        return sum + (itemSubtotal * taxRate);\n      }\n    }, 0);\n  }\n\n  private calculateDiscounts(\n    items: readonly CartItem[], \n    coupons: readonly AppliedCoupon[],\n    customerData?: { taxRate?: number; country?: string; state?: string }\n  ): { discountTotal: number; discountTax: number } {\n    let discountTotal = 0;\n    let discountTax = 0;\n\n    for (const coupon of coupons) {\n      const discount = this.calculateSingleCouponDiscount(items, coupon);\n      discountTotal += discount;\n\n      // Calculate tax on discount if applicable\n      if (this.config.taxCalculation.enabled && !this.config.taxCalculation.pricesIncludeTax) {\n        const taxRate = customerData?.taxRate || this.getDefaultTaxRate(customerData?.country, customerData?.state);\n        discountTax += discount * taxRate;\n      }\n    }\n\n    return { discountTotal, discountTax };\n  }\n\n  private calculateSingleCouponDiscount(items: readonly CartItem[], coupon: AppliedCoupon): number {\n    // Filter items that the coupon applies to\n    const applicableItems = items.filter(item => this.couponAppliesToItem(item, coupon));\n    \n    if (applicableItems.length === 0) {\n      return 0;\n    }\n\n    const applicableSubtotal = applicableItems.reduce((sum, item) => sum + item.totalPrice, 0);\n\n    switch (coupon.discountType) {\n      case 'fixed_cart':\n        // Fixed cart discount applies to the whole cart\n        return Math.min(coupon.amount, applicableSubtotal);\n      \n      case 'percent':\n        // Percentage discount\n        const percentDiscount = applicableSubtotal * (coupon.amount / 100);\n        return coupon.maximumAmount ? Math.min(percentDiscount, coupon.maximumAmount) : percentDiscount;\n      \n      case 'fixed_product':\n        // Fixed amount per product\n        return Math.min(\n          applicableItems.reduce((sum, item) => sum + (coupon.amount * item.quantity), 0),\n          applicableSubtotal\n        );\n      \n      default:\n        return 0;\n    }\n  }\n\n  private couponAppliesToItem(item: CartItem, coupon: AppliedCoupon): boolean {\n    // Check if coupon is restricted to specific products\n    if (coupon.productIds && coupon.productIds.length > 0) {\n      if (!coupon.productIds.includes(item.productId)) {\n        return false;\n      }\n    }\n\n    // Check if product is excluded\n    if (coupon.excludedProductIds && coupon.excludedProductIds.includes(item.productId)) {\n      return false;\n    }\n\n    // Check category restrictions (would require product category data)\n    // This would be implemented based on your product data structure\n\n    return true;\n  }\n\n  private calculateShipping(\n    shippingMethods: readonly ShippingMethod[], \n    cartTotal: number,\n    customerData?: { taxRate?: number; country?: string; state?: string }\n  ): { shippingTotal: number; shippingTax: number } {\n    if (!this.config.enableShipping || shippingMethods.length === 0) {\n      return { shippingTotal: 0, shippingTax: 0 };\n    }\n\n    // Use the first shipping method for now (in practice, user would choose)\n    const selectedMethod = shippingMethods[0];\n    if (!selectedMethod) {\n      return { shippingTotal: 0, shippingTax: 0 };\n    }\n    \n    const shippingTotal = selectedMethod.cost;\n\n    let shippingTax = 0;\n    if (this.config.taxCalculation.enabled && selectedMethod.taxable) {\n      const taxRate = customerData?.taxRate || this.getDefaultTaxRate(customerData?.country, customerData?.state);\n      shippingTax = selectedMethod.taxes?.reduce((sum, tax) => sum + tax.total, 0) || (shippingTotal * taxRate);\n    }\n\n    return { shippingTotal, shippingTax };\n  }\n\n  private calculateFees(\n    fees: readonly CartFee[], \n    cartTotal: number,\n    customerData?: { taxRate?: number; country?: string; state?: string }\n  ): { feeTotal: number; feeTax: number } {\n    if (!this.config.enableFees || fees.length === 0) {\n      return { feeTotal: 0, feeTax: 0 };\n    }\n\n    const feeTotal = fees.reduce((sum, fee) => sum + fee.amount, 0);\n\n    let feeTax = 0;\n    if (this.config.taxCalculation.enabled) {\n      const taxRate = customerData?.taxRate || this.getDefaultTaxRate(customerData?.country, customerData?.state);\n      \n      feeTax = fees.reduce((sum, fee) => {\n        if (fee.taxable) {\n          return sum + (fee.taxes?.reduce((taxSum, tax) => taxSum + tax.total, 0) || (fee.amount * taxRate));\n        }\n        return sum;\n      }, 0);\n    }\n\n    return { feeTotal, feeTax };\n  }\n\n  private calculateFinalTotal(\n    cartContentsTotal: number, \n    shippingTotal: number, \n    feeTotal: number, \n    totalTax: number\n  ): number {\n    if (this.config.taxCalculation.pricesIncludeTax) {\n      // Prices include tax, so just add shipping and fees\n      return cartContentsTotal + shippingTotal + feeTotal;\n    } else {\n      // Add tax to the total\n      return cartContentsTotal + shippingTotal + feeTotal + totalTax;\n    }\n  }\n\n  private getDefaultTaxRate(country?: string, state?: string): number {\n    // Default tax rates by country/state\n    // In a real implementation, this would come from a tax service or database\n    const defaultRates: Record<string, number> = {\n      'US': 0.0875, // Average US sales tax\n      'CA': 0.13,   // Average Canadian tax\n      'GB': 0.20,   // UK VAT\n      'DE': 0.19,   // Germany VAT\n      'FR': 0.20,   // France VAT\n      'AU': 0.10,   // Australia GST\n    };\n\n    return defaultRates[country || 'US'] || 0.10; // Default 10%\n  }\n\n  private roundTotal(amount: number): number {\n    if (this.config.taxCalculation.roundAtSubtotal) {\n      return Math.round(amount * 100) / 100;\n    }\n    return Math.round(amount * 10000) / 10000; // Round to 4 decimal places for intermediate calculations\n  }\n}\n\n/**\n * Main cart service class\n */\nexport class CartService {\n  private readonly client: HttpClient;\n  private readonly cache: CacheManager;\n  private readonly config: CartConfig;\n  private readonly persistence: CartPersistenceManager;\n  private readonly calculator: CartTotalsCalculator;\n  private readonly syncManager: CartSyncManager;\n  private currentCart: Cart | null = null;\n  private authContext: UserAuthContext | null = null;\n\n  constructor(\n    client: HttpClient, \n    cache: CacheManager, \n    config: CartConfig\n  ) {\n    this.client = client;\n    this.cache = cache;\n    this.config = config;\n    this.persistence = new CartPersistenceManager(config.persistence);\n    this.calculator = new CartTotalsCalculator(config);\n    this.syncManager = new CartSyncManager(config.sync, client);\n  }\n\n  /**\n   * Get current cart\n   */\n  async getCart(): Promise<Result<Cart, WooError>> {\n    try {\n      if (!this.currentCart) {\n        const loadResult = await this.persistence.load();\n        if (!loadResult.success) {\n          return loadResult;\n        }\n\n        this.currentCart = loadResult.data || this.createEmptyCart();\n      }\n\n      return Ok(this.currentCart);\n    } catch (error) {\n      return Err(ErrorFactory.cartError(\n        'Failed to get cart',\n        error\n      ));\n    }\n  }\n\n  /**\n   * Add item to cart\n   */\n  async addItem(request: CartAddItemRequest): Promise<Result<Cart, WooError>> {\n    try {\n      // Validate request\n      const validationResult = this.validateAddItemRequest(request);\n      if (!validationResult.success) {\n        return validationResult;\n      }\n\n      // Get current cart\n      const cartResult = await this.getCart();\n      if (!cartResult.success) {\n        return cartResult;\n      }\n\n      const cart = cartResult.data;\n\n      // Fetch product data for validation and cart item creation\n      const productResult = await this.fetchProductData(request);\n      if (!productResult.success) {\n        return productResult;\n      }\n\n      const product = productResult.data;\n\n      // Validate stock if enabled\n      if (this.config.validateStock) {\n        const stockValidation = this.validateStock(product, request.quantity);\n        if (!stockValidation.success) {\n          return stockValidation;\n        }\n      }\n\n      // Generate cart item key\n      const itemKey = this.generateCartItemKey(request);\n\n      // Check if item already exists\n      const existingItemIndex = cart.items.findIndex(item => item.key === itemKey);\n\n      let updatedItems: CartItem[];\n\n      if (existingItemIndex >= 0) {\n        if (request.replace) {\n          // Replace existing item\n          updatedItems = [...cart.items];\n          updatedItems[existingItemIndex] = this.createCartItem(product, request, itemKey);\n        } else {\n          // Update quantity\n          const existingItem = cart.items[existingItemIndex];\n          if (!existingItem) {\n            return Err(ErrorFactory.cartError('Cart item not found'));\n          }\n          \n          const newQuantity = existingItem.quantity + request.quantity;\n\n          // Validate new quantity\n          if (newQuantity > this.config.maxQuantityPerItem) {\n            return Err(ErrorFactory.validationError(\n              `Maximum quantity per item is ${this.config.maxQuantityPerItem}`\n            ));\n          }\n\n          const updatedItem: CartItem = {\n            key: existingItem.key,\n            productId: existingItem.productId,\n            variationId: existingItem.variationId,\n            quantity: newQuantity,\n            name: existingItem.name,\n            price: existingItem.price,\n            regularPrice: existingItem.regularPrice,\n            salePrice: existingItem.salePrice,\n            totalPrice: existingItem.price * newQuantity,\n            total: existingItem.price * newQuantity, // alias for totalPrice\n            sku: existingItem.sku,\n            weight: existingItem.weight,\n            ...(existingItem.dimensions && { dimensions: existingItem.dimensions }),\n            ...(existingItem.image && { image: existingItem.image }),\n            stockQuantity: existingItem.stockQuantity,\n            stockStatus: existingItem.stockStatus,\n            backorders: existingItem.backorders,\n            ...(existingItem.quantityLimits && { quantityLimits: existingItem.quantityLimits }),\n            ...(existingItem.meta && { meta: existingItem.meta }),\n            ...(existingItem.attributes && { attributes: existingItem.attributes }),\n            addedAt: existingItem.addedAt,\n            updatedAt: new Date(),\n            backordersAllowed: existingItem.backordersAllowed,\n            soldIndividually: existingItem.soldIndividually,\n            downloadable: existingItem.downloadable,\n            virtual: existingItem.virtual\n          };\n\n          updatedItems = [...cart.items];\n          updatedItems[existingItemIndex] = updatedItem;\n        }\n      } else {\n        // Add new item\n        if (cart.items.length >= this.config.maxItems) {\n          return Err(ErrorFactory.validationError(\n            `Maximum ${this.config.maxItems} items allowed in cart`\n          ));\n        }\n\n        const newItem = this.createCartItem(product, request, itemKey);\n        updatedItems = [...cart.items, newItem];\n      }\n\n      // Create updated cart\n      const updatedCart = this.updateCartWithItems(cart, updatedItems);\n\n      // Save cart\n      const saveResult = await this.persistence.save(updatedCart);\n      if (!saveResult.success) {\n        return saveResult;\n      }\n\n      this.currentCart = updatedCart;\n      return Ok(updatedCart);\n\n    } catch (error) {\n      return Err(ErrorFactory.cartError(\n        'Failed to add item to cart',\n        error\n      ));\n    }\n  }\n\n  /**\n   * Update item quantity in cart\n   */\n  async updateItem(itemKey: string, quantity: number): Promise<Result<Cart, WooError>> {\n    try {\n      if (quantity <= 0) {\n        const removeResult = await this.removeItem(itemKey);\n        if (!removeResult.success) {\n          return removeResult;\n        }\n        // Return updated cart after removal\n        return this.getCart();\n      }\n\n      // Get current cart\n      const cartResult = await this.getCart();\n      if (!cartResult.success) {\n        return cartResult;\n      }\n\n      const cart = cartResult.data;\n      const itemIndex = cart.items.findIndex(item => item.key === itemKey);\n\n      if (itemIndex === -1) {\n        return Err(ErrorFactory.cartError(\n          'Item not found in cart',\n          { itemKey }\n        ));\n      }\n\n      if (quantity > this.config.maxQuantityPerItem) {\n        return Err(ErrorFactory.validationError(\n          `Maximum quantity per item is ${this.config.maxQuantityPerItem}`\n        ));\n      }\n\n      const item = cart.items[itemIndex];\n      if (!item) {\n        return Err(ErrorFactory.cartError('Cart item not found'));\n      }\n\n      // Validate stock if enabled\n      if (this.config.validateStock) {\n        if (item.stockStatus === 'outofstock') {\n          return Err(ErrorFactory.validationError('Product is out of stock'));\n        }\n\n        if (item.stockQuantity !== undefined && quantity > item.stockQuantity) {\n          return Err(ErrorFactory.validationError(\n            `Only ${item.stockQuantity} items available in stock`\n          ));\n        }\n      }\n\n      // Update item with explicit type\n      const updatedItem: CartItem = {\n        key: item.key,\n        productId: item.productId,\n        variationId: item.variationId,\n        quantity,\n        name: item.name,\n        price: item.price,\n        regularPrice: item.regularPrice,\n        salePrice: item.salePrice,\n        totalPrice: item.price * quantity,\n        total: item.price * quantity, // alias for totalPrice\n        sku: item.sku,\n        weight: item.weight,\n        ...(item.dimensions && { dimensions: item.dimensions }),\n        ...(item.image && { image: item.image }),\n        stockQuantity: item.stockQuantity,\n        stockStatus: item.stockStatus,\n        backorders: item.backorders,\n        ...(item.quantityLimits && { quantityLimits: item.quantityLimits }),\n        ...(item.meta && { meta: item.meta }),\n        ...(item.attributes && { attributes: item.attributes }),\n        addedAt: item.addedAt,\n        updatedAt: new Date(),\n        backordersAllowed: item.backordersAllowed,\n        soldIndividually: item.soldIndividually,\n        downloadable: item.downloadable,\n        virtual: item.virtual\n      };\n\n      const updatedItems = [...cart.items];\n      updatedItems[itemIndex] = updatedItem;\n\n      // Create updated cart\n      const updatedCart = this.updateCartWithItems(cart, updatedItems);\n\n      // Save cart\n      const saveResult = await this.persistence.save(updatedCart);\n      if (!saveResult.success) {\n        return saveResult;\n      }\n\n      this.currentCart = updatedCart;\n      return Ok(updatedCart);\n\n    } catch (error) {\n      return Err(ErrorFactory.cartError(\n        'Failed to update cart item',\n        error\n      ));\n    }\n  }\n\n  /**\n   * Remove item from cart\n   */\n  async removeItem(itemKey: string): Promise<Result<void, WooError>> {\n    try {\n      const cart = await this.getCart();\n      if (isErr(cart)) {\n        return cart;\n      }\n\n      const cartData = unwrap(cart);\n      const itemIndex = cartData.items.findIndex(item => item.key === itemKey);\n      \n      if (itemIndex === -1) {\n        return Err(ErrorFactory.validationError('Cart item not found'));\n      }\n\n      // Remove item from items array\n      const updatedItems = cartData.items.filter((_, index) => index !== itemIndex);\n      \n      // Calculate new totals\n      const newTotals = this.calculator.calculate(updatedItems, cartData.appliedCoupons, cartData.shippingMethods, cartData.fees);\n      \n      const updatedCart: Cart = {\n        ...cartData,\n        items: updatedItems,\n        totals: newTotals,\n        isEmpty: updatedItems.length === 0,\n        itemCount: updatedItems.reduce((sum, item) => sum + item.quantity, 0),\n        updatedAt: new Date()\n      };\n\n      // Save the updated cart\n      const saveResult = await this.persistence.save(updatedCart);\n      if (!saveResult.success) {\n        return saveResult;\n      }\n      \n      this.currentCart = updatedCart;\n      return Ok(undefined);\n    } catch (error) {\n      return Err(ErrorFactory.networkError(\n        error instanceof Error ? error.message : 'Failed to remove cart item'\n      ));\n    }\n  }\n\n  /**\n   * Clear entire cart\n   */\n  async clearCart(): Promise<Result<Cart, WooError>> {\n    try {\n      const emptyCart = this.createEmptyCart();\n\n      // Save empty cart\n      const saveResult = await this.persistence.save(emptyCart);\n      if (!saveResult.success) {\n        return saveResult;\n      }\n\n      this.currentCart = emptyCart;\n      return Ok(emptyCart);\n\n    } catch (error) {\n      return Err(ErrorFactory.cartError(\n        'Failed to clear cart',\n        error\n      ));\n    }\n  }\n\n  /**\n   * Comprehensive cart validation with stock, availability, and business rules\n   */\n  async validateCart(): Promise<Result<CartValidationResult, WooError>> {\n    try {\n      const cartResult = await this.getCart();\n      if (!cartResult.success) {\n        return cartResult;\n      }\n\n      const cart = cartResult.data;\n      // Create mutable arrays for building validation results\n      const mutableErrors: Array<{\n        readonly itemKey: string;\n        readonly code: 'PRODUCT_NOT_FOUND' | 'OUT_OF_STOCK' | 'INSUFFICIENT_STOCK' | 'INVALID_QUANTITY' | 'VARIATION_NOT_FOUND';\n        readonly message: string;\n        readonly currentStock?: number;\n        readonly requestedQuantity?: number;\n      }> = [];\n      \n      const mutableWarnings: Array<{\n        readonly itemKey: string;\n        readonly code: 'LOW_STOCK' | 'BACKORDER' | 'PRICE_CHANGED';\n        readonly message: string;\n        readonly details?: Record<string, unknown>;\n      }> = [];\n\n      // Validate each cart item\n      for (const item of cart.items) {\n        await this.validateCartItem(item, mutableErrors, mutableWarnings);\n      }\n\n      // Validate cart-level constraints\n      const constraintErrors: Array<{\n        readonly itemKey: string;\n        readonly code: 'INVALID_QUANTITY';\n        readonly message: string;\n      }> = [];\n      const constraintWarnings: Array<{\n        readonly itemKey: string;\n        readonly code: 'MINIMUM_ORDER_NOT_MET' | 'HIGH_QUANTITY' | 'EMPTY_CART';\n        readonly message: string;\n        readonly details?: Record<string, unknown>;\n      }> = [];\n      await this.validateCartConstraints(cart, constraintErrors, constraintWarnings);\n      mutableErrors.push(...constraintErrors);\n      constraintWarnings.forEach(w => mutableWarnings.push({\n        itemKey: w.itemKey,\n        code: 'PRICE_CHANGED', // Map constraint warnings to general type\n        message: w.message,\n        ...(w.details && { details: w.details })\n      }));\n\n      // Validate applied coupons\n      const couponErrors: Array<{\n        readonly itemKey: string;\n        readonly code: 'COUPON_EXPIRED' | 'COUPON_USAGE_LIMIT_EXCEEDED' | 'COUPON_MINIMUM_NOT_MET' | 'COUPON_MAXIMUM_EXCEEDED' | 'COUPON_INDIVIDUAL_USE';\n        readonly message: string;\n      }> = [];\n      const couponWarnings: Array<{\n        readonly itemKey: string;\n        readonly code: 'COUPON_VALIDATION_ERROR';\n        readonly message: string;\n        readonly details: Record<string, unknown>;\n      }> = [];\n      await this.validateAppliedCoupons(cart, couponErrors, couponWarnings);\n      couponWarnings.forEach(w => mutableWarnings.push({\n        itemKey: w.itemKey,\n        code: 'PRICE_CHANGED', // Map coupon warnings to general type\n        message: w.message,\n        details: w.details\n      }));\n      // Convert coupon errors to general errors\n      couponErrors.forEach(e => mutableErrors.push({\n        itemKey: e.itemKey,\n        code: 'INVALID_QUANTITY', // Map coupon errors to general type\n        message: e.message\n      }));\n\n      // Validate cart totals integrity\n      const totalsWarnings: Array<{\n        readonly itemKey: string;\n        readonly code: 'TOTALS_MISMATCH' | 'TOTALS_VALIDATION_ERROR';\n        readonly message: string;\n        readonly details: Record<string, unknown>;\n      }> = [];\n      await this.validateCartTotals(cart, totalsWarnings);\n      // Convert totals warnings to general warnings\n      totalsWarnings.forEach(w => mutableWarnings.push({\n        itemKey: w.itemKey,\n        code: 'PRICE_CHANGED', // Map totals warnings to general type\n        message: w.message,\n        details: w.details\n      }));\n\n      // Return readonly arrays\n      return Ok({\n        isValid: mutableErrors.length === 0,\n        errors: mutableErrors as readonly typeof mutableErrors[0][],\n        warnings: mutableWarnings as readonly typeof mutableWarnings[0][]\n      });\n\n    } catch (error) {\n      return Err(ErrorFactory.cartError(\n        'Cart validation failed',\n        error\n      ));\n    }\n  }\n\n  /**\n   * Validate individual cart item\n   */\n  private async validateCartItem(\n    item: CartItem, \n    errors: Array<{\n      readonly itemKey: string;\n      readonly code: 'PRODUCT_NOT_FOUND' | 'OUT_OF_STOCK' | 'INSUFFICIENT_STOCK' | 'INVALID_QUANTITY' | 'VARIATION_NOT_FOUND';\n      readonly message: string;\n      readonly currentStock?: number;\n      readonly requestedQuantity?: number;\n    }>, \n    warnings: Array<{\n      readonly itemKey: string;\n      readonly code: 'LOW_STOCK' | 'BACKORDER' | 'PRICE_CHANGED';\n      readonly message: string;\n      readonly details?: Record<string, unknown>;\n    }>\n  ): Promise<void> {\n    try {\n      // 1. Fetch current product data\n      const productResult = await this.fetchProductData({\n        productId: item.productId,\n        variationId: item.variationId,\n        quantity: item.quantity\n      });\n\n      if (isErr(productResult)) {\n        errors.push({\n          itemKey: item.key,\n          code: 'PRODUCT_NOT_FOUND',\n          message: `Product with ID ${item.productId} not found`,\n          currentStock: 0,\n          requestedQuantity: item.quantity\n        });\n        return;\n      }\n\n      const product = unwrap(productResult);\n\n      // 2. Validate product availability\n      if (product.status !== 'publish') {\n        errors.push({\n          itemKey: item.key,\n          code: 'PRODUCT_NOT_FOUND',\n          message: `Product ${item.name} is no longer available`\n        });\n        return;\n      }\n\n      // 3. Validate stock levels\n      const stockErrors: Array<{\n        readonly itemKey: string;\n        readonly code: 'OUT_OF_STOCK' | 'INSUFFICIENT_STOCK';\n        readonly message: string;\n        readonly currentStock?: number;\n        readonly requestedQuantity?: number;\n      }> = [];\n      const stockWarnings: Array<{\n        readonly itemKey: string;\n        readonly code: 'LOW_STOCK' | 'BACKORDER';\n        readonly message: string;\n        readonly details?: Record<string, unknown>;\n      }> = [];\n      await this.validateItemStock(item, product, stockErrors, stockWarnings);\n      stockErrors.forEach(e => errors.push({ ...e, code: e.code as any }));\n      stockWarnings.forEach(w => warnings.push({ ...w, code: w.code as any }));\n\n      // 4. Validate quantity limits\n      const quantityErrors: Array<{\n        readonly itemKey: string;\n        readonly code: 'INVALID_QUANTITY';\n        readonly message: string;\n        readonly requestedQuantity: number;\n      }> = [];\n      const quantityWarnings: Array<{\n        readonly itemKey: string;\n        readonly code: 'INVALID_QUANTITY';\n        readonly message: string;\n        readonly requestedQuantity: number;\n      }> = [];\n      this.validateItemQuantityLimits(item, product, quantityErrors, quantityWarnings);\n      quantityErrors.forEach(e => errors.push({ ...e, code: e.code as any }));\n\n      // 5. Validate price changes\n      const priceWarnings: Array<{\n        readonly itemKey: string;\n        readonly code: 'PRICE_CHANGED';\n        readonly message: string;\n        readonly details: Record<string, unknown>;\n      }> = [];\n      this.validateItemPriceChanges(item, product, priceWarnings);\n      priceWarnings.forEach(w => warnings.push({ ...w, code: w.code as any }));\n\n      // 6. Validate product variations (if applicable)\n      if (item.variationId && product.type === 'variable') {\n        const variationErrors: Array<{\n          readonly itemKey: string;\n          readonly code: 'VARIATION_NOT_FOUND';\n          readonly message: string;\n        }> = [];\n        await this.validateProductVariation(item, product, variationErrors);\n        variationErrors.forEach(e => errors.push({ ...e, code: e.code as any }));\n      }\n\n    } catch (error) {\n      warnings.push({\n        itemKey: item.key,\n        code: 'LOW_STOCK',\n        message: `Could not validate item: ${error instanceof Error ? error.message : 'Unknown error'}`,\n        details: { error }\n      });\n    }\n  }\n\n  /**\n   * Validate item stock levels\n   */\n  private async validateItemStock(\n    item: CartItem,\n    currentProduct: WooCommerceProduct,\n    errors: Array<{\n      readonly itemKey: string;\n      readonly code: 'OUT_OF_STOCK' | 'INSUFFICIENT_STOCK';\n      readonly message: string;\n      readonly currentStock?: number;\n      readonly requestedQuantity?: number;\n    }>,\n    warnings: Array<{\n      readonly itemKey: string;\n      readonly code: 'LOW_STOCK' | 'BACKORDER';\n      readonly message: string;\n      readonly details?: Record<string, unknown>;\n    }>\n  ): Promise<void> {\n    // Check stock status\n    if (currentProduct.stock_status === 'outofstock') {\n      errors.push({\n        itemKey: item.key,\n        code: 'OUT_OF_STOCK',\n        message: `${item.name} is currently out of stock`,\n        currentStock: 0,\n        requestedQuantity: item.quantity\n      });\n      return;\n    }\n\n    // Check specific stock quantity\n    if (currentProduct.manage_stock && currentProduct.stock_quantity !== null) {\n      const availableStock = currentProduct.stock_quantity;\n      \n      if (item.quantity > availableStock) {\n        if (availableStock === 0) {\n          errors.push({\n            itemKey: item.key,\n            code: 'OUT_OF_STOCK',\n            message: `${item.name} is out of stock`,\n            currentStock: availableStock,\n            requestedQuantity: item.quantity\n          });\n        } else {\n          errors.push({\n            itemKey: item.key,\n            code: 'INSUFFICIENT_STOCK',\n            message: `Only ${availableStock} units of ${item.name} available, but ${item.quantity} requested`,\n            currentStock: availableStock ?? 0,\n            requestedQuantity: item.quantity\n          });\n        }\n        return;\n      }\n\n      // Warn about low stock\n              const lowStockThreshold = Math.max(5, Math.ceil((availableStock ?? 0) * 0.1)); // 10% or 5, whichever is higher\n              if (availableStock != null && availableStock <= lowStockThreshold && availableStock > item.quantity) {\n        warnings.push({\n          itemKey: item.key,\n          code: 'LOW_STOCK',\n          message: `Only ${availableStock ?? 0} units of ${item.name} remaining`,\n          details: { availableStock: availableStock ?? 0, threshold: lowStockThreshold }\n        });\n      }\n    }\n\n    // Check backorder status\n    if (currentProduct.stock_status === 'onbackorder') {\n      if (currentProduct.backorders === 'no') {\n        errors.push({\n          itemKey: item.key,\n          code: 'OUT_OF_STOCK',\n          message: `${item.name} is temporarily unavailable`,\n          currentStock: 0,\n          requestedQuantity: item.quantity\n        });\n      } else {\n        warnings.push({\n          itemKey: item.key,\n          code: 'BACKORDER',\n          message: `${item.name} is on backorder and may take longer to ship`,\n          details: { backorderNotify: currentProduct.backorders === 'notify' }\n        });\n      }\n    }\n  }\n\n  /**\n   * Validate quantity limits for cart item\n   */\n  private validateItemQuantityLimits(\n    item: CartItem,\n    currentProduct: WooCommerceProduct,\n    errors: Array<{\n      readonly itemKey: string;\n      readonly code: 'INVALID_QUANTITY';\n      readonly message: string;\n      readonly requestedQuantity: number;\n    }>,\n    warnings: Array<{\n      readonly itemKey: string;\n      readonly code: 'INVALID_QUANTITY';\n      readonly message: string;\n      readonly requestedQuantity: number;\n    }>\n  ): void {\n    // Check configured quantity limits\n    if (item.quantityLimits) {\n      const { min, max, step } = item.quantityLimits;\n      \n      if (item.quantity < min) {\n        errors.push({\n          itemKey: item.key,\n          code: 'INVALID_QUANTITY',\n          message: `Minimum quantity for ${item.name} is ${min}`,\n          requestedQuantity: item.quantity\n        });\n      }\n      \n      if (item.quantity > max) {\n        errors.push({\n          itemKey: item.key,\n          code: 'INVALID_QUANTITY',\n          message: `Maximum quantity for ${item.name} is ${max}`,\n          requestedQuantity: item.quantity\n        });\n      }\n      \n      if ((item.quantity - min) % step !== 0) {\n        errors.push({\n          itemKey: item.key,\n          code: 'INVALID_QUANTITY',\n          message: `${item.name} must be ordered in multiples of ${step}`,\n          requestedQuantity: item.quantity\n        });\n      }\n    }\n\n    // Validate against global config limits\n    if (item.quantity > this.config.maxQuantityPerItem) {\n      errors.push({\n        itemKey: item.key,\n        code: 'INVALID_QUANTITY',\n        message: `Maximum quantity per item is ${this.config.maxQuantityPerItem}`,\n        requestedQuantity: item.quantity\n      });\n    }\n  }\n\n  /**\n   * Validate price changes since item was added\n   */\n  private validateItemPriceChanges(\n    item: CartItem,\n    currentProduct: WooCommerceProduct,\n    warnings: Array<{\n      readonly itemKey: string;\n      readonly code: 'PRICE_CHANGED';\n      readonly message: string;\n      readonly details: Record<string, unknown>;\n    }>\n  ): void {\n    const currentRegularPrice = parseFloat(currentProduct.regular_price);\n    const currentSalePrice = currentProduct.sale_price ? parseFloat(currentProduct.sale_price) : undefined;\n\n    // Check if regular price has changed\n    if (Math.abs(item.regularPrice - currentRegularPrice) > 0.01) {\n      warnings.push({\n        itemKey: item.key,\n        code: 'PRICE_CHANGED',\n        message: `Price for ${item.name} has changed from $${item.regularPrice.toFixed(2)} to $${currentRegularPrice.toFixed(2)}`,\n        details: { \n          previousPrice: item.regularPrice, \n          currentPrice: currentRegularPrice,\n          priceIncrease: currentRegularPrice > item.regularPrice\n        }\n      });\n    }\n\n    // Check if sale price has changed\n    const itemSalePrice = item.salePrice || null;\n    if ((itemSalePrice !== null && currentSalePrice === undefined) ||\n        (itemSalePrice === null && currentSalePrice !== undefined) ||\n        (itemSalePrice !== null && currentSalePrice !== undefined && Math.abs(itemSalePrice - currentSalePrice) > 0.01)) {\n      warnings.push({\n        itemKey: item.key,\n        code: 'PRICE_CHANGED',\n        message: `Sale price for ${item.name} has changed`,\n        details: { \n          previousSalePrice: itemSalePrice, \n          currentSalePrice: currentSalePrice \n        }\n      });\n    }\n  }\n\n  /**\n   * Validate product variation\n   */\n  private async validateProductVariation(\n    item: CartItem,\n    currentProduct: WooCommerceProduct,\n    errors: Array<{\n      readonly itemKey: string;\n      readonly code: 'VARIATION_NOT_FOUND';\n      readonly message: string;\n    }>\n  ): Promise<void> {\n    try {\n      // In a real implementation, you would fetch variation data from the API\n      // For now, we'll do basic validation\n      if (!item.variationId) {\n        errors.push({\n          itemKey: item.key,\n          code: 'VARIATION_NOT_FOUND',\n          message: `Product variation is required for ${item.name}`\n        });\n        return;\n      }\n\n      // Validate variation attributes match what was selected\n      if (item.attributes) {\n        for (const [attributeName, attributeValue] of Object.entries(item.attributes)) {\n          // In a real implementation, validate against available variations\n          // This is a placeholder for variation validation logic\n          if (!attributeValue || attributeValue.trim() === '') {\n            errors.push({\n              itemKey: item.key,\n              code: 'VARIATION_NOT_FOUND',\n              message: `Invalid variation attribute ${attributeName} for ${item.name}`\n            });\n          }\n        }\n      }\n    } catch (error) {\n      errors.push({\n        itemKey: item.key,\n        code: 'VARIATION_NOT_FOUND',\n        message: `Could not validate product variation for ${item.name}`\n      });\n    }\n  }\n\n  /**\n   * Validate cart-level constraints\n   */\n  private async validateCartConstraints(\n    cart: Cart,\n    errors: Array<{\n      readonly itemKey: string;\n      readonly code: 'INVALID_QUANTITY';\n      readonly message: string;\n    }>,\n    warnings: Array<{\n      readonly itemKey: string;\n      readonly code: 'HIGH_QUANTITY' | 'EMPTY_CART' | 'MINIMUM_ORDER_NOT_MET';\n      readonly message: string;\n      readonly details?: Record<string, unknown>;\n    }>\n  ): void {\n    // Validate maximum number of items\n    if (cart.items.length > this.config.maxItems) {\n      errors.push({\n        itemKey: '',\n        code: 'INVALID_QUANTITY',\n        message: `Cart cannot contain more than ${this.config.maxItems} items`\n      });\n    }\n\n    // Validate total item count\n    const totalQuantity = cart.items.reduce((sum, item) => sum + item.quantity, 0);\n    const maxTotalQuantity = this.config.maxItems * this.config.maxQuantityPerItem;\n    \n    if (totalQuantity > maxTotalQuantity) {\n      warnings.push({\n        itemKey: '',\n        code: 'HIGH_QUANTITY',\n        message: `Cart contains ${totalQuantity} items, which may affect performance`,\n        details: { totalQuantity, maxRecommended: maxTotalQuantity }\n      });\n    }\n\n    // Validate cart is not empty\n    if (cart.items.length === 0) {\n      warnings.push({\n        itemKey: '',\n        code: 'EMPTY_CART',\n        message: 'Cart is empty'\n      });\n    }\n\n    // Validate cart total constraints (if any)\n    const minOrderAmount = 0; // This could be configurable\n    if (minOrderAmount > 0 && cart.totals.total < minOrderAmount) {\n      errors.push({\n        itemKey: '',\n        code: 'INVALID_QUANTITY',\n        message: `Minimum order amount is $${minOrderAmount.toFixed(2)}`\n      });\n    }\n  }\n\n  /**\n   * Validate applied coupons\n   */\n  private async validateAppliedCoupons(\n    cart: Cart,\n    errors: Array<{\n      readonly itemKey: string;\n      readonly code: 'COUPON_EXPIRED' | 'COUPON_USAGE_LIMIT_EXCEEDED' | 'COUPON_MINIMUM_NOT_MET' | 'COUPON_MAXIMUM_EXCEEDED' | 'COUPON_INDIVIDUAL_USE';\n      readonly message: string;\n    }>,\n    warnings: Array<{\n      readonly itemKey: string;\n      readonly code: 'COUPON_VALIDATION_ERROR';\n      readonly message: string;\n      readonly details: Record<string, unknown>;\n    }>\n  ): void {\n    for (const coupon of cart.appliedCoupons) {\n      try {\n        // Validate coupon expiry\n        if (coupon.expiryDate && coupon.expiryDate < new Date()) {\n          errors.push({\n            itemKey: '',\n            code: 'COUPON_EXPIRED',\n            message: `Coupon ${coupon.code} has expired`\n          });\n          continue;\n        }\n\n        // Validate usage limits\n        if (coupon.usageLimit && coupon.usageCount >= coupon.usageLimit) {\n          errors.push({\n            itemKey: '',\n            code: 'COUPON_USAGE_LIMIT_EXCEEDED',\n            message: `Coupon ${coupon.code} has reached its usage limit`\n          });\n          continue;\n        }\n\n        // Validate minimum amount\n        if (coupon.minimumAmount && cart.totals.subtotal < coupon.minimumAmount) {\n          errors.push({\n            itemKey: '',\n            code: 'COUPON_MINIMUM_NOT_MET',\n            message: `Coupon ${coupon.code} requires a minimum order of $${coupon.minimumAmount.toFixed(2)}`\n          });\n          continue;\n        }\n\n        // Validate maximum amount\n        if (coupon.maximumAmount && cart.totals.subtotal > coupon.maximumAmount) {\n          warnings.push({\n            itemKey: '',\n            code: 'COUPON_VALIDATION_ERROR',\n            message: `Coupon ${coupon.code} is only valid for orders up to $${coupon.maximumAmount.toFixed(2)}`,\n            details: { couponCode: coupon.code, maximumAmount: coupon.maximumAmount }\n          });\n        }\n\n        // Validate individual use coupons\n        if (coupon.individualUse && cart.appliedCoupons.length > 1) {\n          errors.push({\n            itemKey: '',\n            code: 'COUPON_INDIVIDUAL_USE',\n            message: `Coupon ${coupon.code} cannot be combined with other coupons`\n          });\n        }\n\n      } catch (error) {\n        warnings.push({\n          itemKey: '',\n          code: 'COUPON_VALIDATION_ERROR',\n          message: `Could not validate coupon ${coupon.code}`,\n          details: { couponCode: coupon.code, error }\n        });\n      }\n    }\n  }\n\n  /**\n   * Validate cart totals integrity\n   */\n  private async validateCartTotals(\n    cart: Cart,\n    warnings: Array<{\n      readonly itemKey: string;\n      readonly code: 'TOTALS_MISMATCH' | 'TOTALS_VALIDATION_ERROR';\n      readonly message: string;\n      readonly details: Record<string, unknown>;\n    }>\n  ): Promise<void> {\n    try {\n      // Recalculate totals and compare with stored totals\n      const recalculatedTotals = this.calculator.calculate(\n        cart.items,\n        cart.appliedCoupons,\n        cart.shippingMethods,\n        cart.fees\n      );\n\n      const tolerance = 0.01; // 1 cent tolerance for rounding differences\n\n      if (Math.abs(cart.totals.total - recalculatedTotals.total) > tolerance) {\n        warnings.push({\n          itemKey: '',\n          code: 'TOTALS_MISMATCH',\n          message: 'Cart totals may be outdated and need recalculation',\n          details: { \n            storedTotal: cart.totals.total, \n            calculatedTotal: recalculatedTotals.total,\n            difference: Math.abs(cart.totals.total - recalculatedTotals.total)\n          }\n        });\n      }\n\n    } catch (error) {\n      warnings.push({\n        itemKey: '',\n        code: 'TOTALS_VALIDATION_ERROR',\n        message: 'Could not validate cart totals',\n        details: { error }\n      });\n    }\n  }\n\n  /**\n   * Apply coupon to cart\n   */\n  async applyCoupon(couponCode: string): Promise<Result<Cart, WooError>> {\n    try {\n      const cart = await this.getCart();\n      if (isErr(cart)) {\n        return cart;\n      }\n\n      const cartData = unwrap(cart);\n      \n      // Check if coupon is already applied\n      const alreadyApplied = cartData.appliedCoupons.some(coupon => coupon.code === couponCode);\n      if (alreadyApplied) {\n        return Err(ErrorFactory.validationError('Coupon is already applied'));\n      }\n\n      // Validate coupon\n      const validation = await this.validateCoupon(couponCode);\n      if (isErr(validation)) {\n        return validation;\n      }\n\n      const validationResult = unwrap(validation);\n      if (!validationResult.valid) {\n        return Err(ErrorFactory.validationError(validationResult.reason || 'Invalid coupon'));\n      }\n\n      // Apply coupon and recalculate totals\n      const updatedCart = await this.recalculateWithCoupon(cartData, validationResult.coupon!);\n      return Ok(updatedCart);\n    } catch (error) {\n      return Err(ErrorFactory.networkError(\n        error instanceof Error ? error.message : 'Failed to apply coupon'\n      ));\n    }\n  }\n\n  /**\n   * Remove coupon from cart\n   */\n  async removeCoupon(couponCode: string): Promise<Result<Cart, WooError>> {\n    try {\n      if (!this.config.enableCoupons) {\n        return Err(ErrorFactory.configurationError('Coupons are disabled'));\n      }\n\n      if (!couponCode || couponCode.trim() === '') {\n        return Err(ErrorFactory.validationError('Coupon code is required'));\n      }\n\n      // Get current cart\n      const cartResult = await this.getCart();\n      if (!cartResult.success) {\n        return cartResult;\n      }\n\n      const cart = cartResult.data;\n      const normalizedCode = couponCode.trim().toUpperCase();\n\n      // Check if coupon is applied\n      const couponExists = cart.appliedCoupons.some(c => c.code === normalizedCode);\n      if (!couponExists) {\n        return Err(ErrorFactory.validationError(`Coupon ${normalizedCode} is not applied to this cart`));\n      }\n\n      // Remove the coupon\n      const updatedAppliedCoupons = cart.appliedCoupons.filter(c => c.code !== normalizedCode);\n\n      // Recalculate totals without the coupon\n      const updatedTotals = this.calculator.calculate(\n        cart.items,\n        updatedAppliedCoupons,\n        cart.shippingMethods,\n        cart.fees\n      );\n\n      // Create updated cart\n      const updatedCart: Cart = {\n        ...cart,\n        appliedCoupons: updatedAppliedCoupons,\n        totals: updatedTotals,\n        updatedAt: new Date()\n      };\n\n      // Save cart\n      const saveResult = await this.persistence.save(updatedCart);\n      if (!saveResult.success) {\n        return saveResult;\n      }\n\n      this.currentCart = updatedCart;\n      return Ok(updatedCart);\n\n    } catch (error) {\n      return Err(ErrorFactory.cartError(\n        'Failed to remove coupon',\n        error\n      ));\n    }\n  }\n\n  /**\n   * Get available coupons for current cart\n   */\n  async getAvailableCoupons(): Promise<Result<WooCommerceCoupon[], WooError>> {\n    try {\n      if (!this.config.enableCoupons) {\n        return Err(ErrorFactory.configurationError('Coupons are disabled'));\n      }\n\n      // Get current cart for context\n      const cartResult = await this.getCart();\n      if (!cartResult.success) {\n        return cartResult;\n      }\n\n      const cart = cartResult.data;\n\n      // Fetch available coupons from API\n      const response = await this.client.get<WooCommerceCoupon[]>('/coupons', {\n        status: 'publish',\n        per_page: 100, // Adjust as needed\n        orderby: 'date',\n        order: 'desc'\n      });\n\n      if (!response.success) {\n        return response;\n      }\n\n      // Filter coupons based on cart eligibility\n      const availableCoupons: WooCommerceCoupon[] = [];\n      \n      for (const coupon of response.data.data) {\n        const isEligible = await this.isCouponEligibleForCart(coupon, cart);\n        if (isEligible) {\n          availableCoupons.push(coupon);\n        }\n      }\n\n      return Ok(availableCoupons);\n\n    } catch (error) {\n      return Err(ErrorFactory.cartError(\n        'Failed to get available coupons',\n        error\n      ));\n    }\n  }\n\n  /**\n   * Validate coupon code without applying it\n   */\n  async validateCoupon(couponCode: string): Promise<Result<{ valid: boolean; coupon?: WooCommerceCoupon; reason?: string }, WooError>> {\n    try {\n      if (!this.config.enableCoupons) {\n        return Ok({ valid: false, reason: 'Coupons are disabled' });\n      }\n\n      if (!couponCode || couponCode.trim() === '') {\n        return Ok({ valid: false, reason: 'Coupon code is required' });\n      }\n\n      const normalizedCode = couponCode.trim().toUpperCase();\n\n      // Fetch coupon data\n      const couponResult = await this.fetchCouponData(normalizedCode);\n      if (!couponResult.success) {\n        return Ok({ valid: false, reason: 'Coupon not found' });\n      }\n\n      const couponData = couponResult.data;\n\n      // Get current cart for validation\n      const cartResult = await this.getCart();\n      if (!cartResult.success) {\n        return cartResult;\n      }\n\n      const cart = cartResult.data;\n\n      // Validate coupon eligibility\n      const validationResult = await this.validateCouponEligibility(couponData, cart);\n      if (!validationResult.success) {\n        return Ok({ \n          valid: false, \n          coupon: couponData,\n          reason: validationResult.error.message \n        });\n      }\n\n      return Ok({ \n        valid: true, \n        coupon: couponData \n      });\n\n    } catch (error) {\n      return Err(ErrorFactory.cartError(\n        'Failed to validate coupon',\n        error\n      ));\n    }\n  }\n\n  // Private helper methods\n\n  /**\n   * Fetch coupon data from WooCommerce API\n   */\n  private async fetchCouponData(couponCode: string): Promise<Result<WooCommerceCoupon, WooError>> {\n    try {\n      // Use cache first\n      const cacheKey = `coupons:${couponCode}`;\n      const cachedResult = await this.cache.get<WooCommerceCoupon>(cacheKey);\n      \n      if (cachedResult.success && cachedResult.data) {\n        return Ok(cachedResult.data);\n      }\n\n      // Fetch from API - try by code first\n      const response = await this.client.get<WooCommerceCoupon[]>('/coupons', {\n        code: couponCode,\n        status: 'publish'\n      });\n\n      if (!response.success) {\n        return Err(ErrorFactory.validationError('Coupon not found'));\n      }\n\n      const coupons = response.data.data;\n      if (!coupons || coupons.length === 0) {\n        return Err(ErrorFactory.validationError('Coupon not found'));\n      }\n\n      const coupon = coupons[0];\n      \n      if (!coupon) {\n        return Err(ErrorFactory.validationError(`Coupon ${couponCode} not found`));\n      }\n\n      // Cache the result\n      await this.cache.set(cacheKey, coupon, 300); // 5 minutes cache\n\n      return Ok(coupon);\n\n    } catch (error) {\n      return Err(ErrorFactory.cartError(\n        'Failed to fetch coupon data',\n        error\n      ));\n    }\n  }\n\n  /**\n   * Validate if coupon is eligible for the current cart\n   */\n  private async validateCouponEligibility(coupon: WooCommerceCoupon, cart: Cart): Promise<Result<void, WooError>> {\n    try {\n      // Check expiry date\n      if (coupon.date_expires) {\n        const expiryDate = new Date(coupon.date_expires);\n        if (expiryDate < new Date()) {\n          return Err(ErrorFactory.validationError(`Coupon ${coupon.code} has expired`));\n        }\n      }\n\n      // Check usage limits\n      if (coupon.usage_limit && coupon.usage_count >= coupon.usage_limit) {\n        return Err(ErrorFactory.validationError(`Coupon ${coupon.code} has reached its usage limit`));\n      }\n\n      // Check minimum amount\n      if (coupon.minimum_amount) {\n        const minAmount = parseFloat(coupon.minimum_amount);\n        if (cart.totals.subtotal < minAmount) {\n          return Err(ErrorFactory.validationError(\n            `Coupon ${coupon.code} requires a minimum order of $${minAmount.toFixed(2)}`\n          ));\n        }\n      }\n\n      // Check maximum amount\n      if (coupon.maximum_amount) {\n        const maxAmount = parseFloat(coupon.maximum_amount);\n        if (cart.totals.subtotal > maxAmount) {\n          return Err(ErrorFactory.validationError(\n            `Coupon ${coupon.code} is only valid for orders up to $${maxAmount.toFixed(2)}`\n          ));\n        }\n      }\n\n      // Check product restrictions\n      if (coupon.product_ids && coupon.product_ids.length > 0) {\n        const hasEligibleProduct = cart.items.some(item => \n          coupon.product_ids!.includes(item.productId)\n        );\n        if (!hasEligibleProduct) {\n          return Err(ErrorFactory.validationError(\n            `Coupon ${coupon.code} is not valid for the products in your cart`\n          ));\n        }\n      }\n\n      // Check excluded products\n      if (coupon.excluded_product_ids && coupon.excluded_product_ids.length > 0) {\n        const hasExcludedProduct = cart.items.some(item => \n          coupon.excluded_product_ids!.includes(item.productId)\n        );\n        if (hasExcludedProduct) {\n          return Err(ErrorFactory.validationError(\n            `Coupon ${coupon.code} cannot be used with some products in your cart`\n          ));\n        }\n      }\n\n      // Check individual use restriction\n      if (coupon.individual_use && cart.appliedCoupons.length > 0) {\n        return Err(ErrorFactory.validationError(\n          `Coupon ${coupon.code} cannot be combined with other coupons`\n        ));\n      }\n\n      return Ok(undefined);\n\n    } catch (error) {\n      return Err(ErrorFactory.cartError(\n        'Failed to validate coupon eligibility',\n        error\n      ));\n    }\n  }\n\n  /**\n   * Check if a coupon is eligible for the current cart (simplified version)\n   */\n  private async isCouponEligibleForCart(coupon: WooCommerceCoupon, cart: Cart): Promise<boolean> {\n    try {\n      const validationResult = await this.validateCouponEligibility(coupon, cart);\n      return validationResult.success;\n    } catch {\n      return false;\n    }\n  }\n\n  private validateAddItemRequest(request: CartAddItemRequest): Result<void, WooError> {\n    try {\n      CartAddItemRequestSchema.parse(request);\n      return Ok(undefined);\n    } catch (error) {\n      return Err(ErrorFactory.validationError(\n        'Invalid add item request',\n        error\n      ));\n    }\n  }\n\n  private async fetchProductData(request: CartAddItemRequest): Promise<Result<WooCommerceProduct, WooError>> {\n    // Use cache first\n    const cacheKey = `products:single:${request.productId}`;\n    const cachedResult = await this.cache.get<WooCommerceProduct>(cacheKey);\n    \n    if (cachedResult.success && cachedResult.data) {\n      return Ok(cachedResult.data);\n    }\n\n    // Fetch from API\n    const response = await this.client.get<WooCommerceProduct>(`/products/${request.productId}`);\n    \n    if (!response.success) {\n      if (response.error.statusCode === 404) {\n        return Err(ErrorFactory.productNotFoundError(request.productId));\n      }\n      return response;\n    }\n\n    // Cache the result\n    await this.cache.set(cacheKey, response.data.data);\n    \n    return Ok(response.data.data);\n  }\n\n  private validateStock(product: WooCommerceProduct, requestedQuantity: number): Result<void, WooError> {\n    if (product.stock_status === 'outofstock') {\n      return Err(ErrorFactory.validationError('Product is out of stock'));\n    }\n\n    if (product.stock_quantity !== null && product.stock_quantity !== undefined && requestedQuantity > product.stock_quantity) {\n      return Err(ErrorFactory.validationError(\n        `Only ${product.stock_quantity} items available in stock`\n      ));\n    }\n\n    return Ok(undefined);\n  }\n\n  private generateCartItemKey(request: CartAddItemRequest): string {\n    let key = `${request.productId}`;\n    \n    if (request.variationId) {\n      key += `-${request.variationId}`;\n    }\n    \n    if (request.attributes) {\n      const sortedAttrs = Object.keys(request.attributes)\n        .sort()\n        .map(k => `${k}:${request.attributes![k]}`)\n        .join('|');\n      key += `-${sortedAttrs}`;\n    }\n    \n    return key;\n  }\n\n  private createCartItem(\n    product: WooCommerceProduct, \n    request: CartAddItemRequest, \n    itemKey: string\n  ): CartItem {\n    const now = new Date();\n    const price = parseFloat(product.price) || 0;\n    const regularPrice = parseFloat(product.regular_price) || 0;\n    const salePrice = product.sale_price ? parseFloat(product.sale_price) : undefined;\n    const totalPrice = price * request.quantity;\n\n    const cartItem: CartItem = {\n      key: itemKey,\n      productId: product.id,\n      variationId: request.variationId,\n      quantity: request.quantity,\n      name: product.name,\n      price,\n      regularPrice,\n      salePrice,\n      totalPrice,\n      total: totalPrice,\n      sku: product.sku || undefined,\n      weight: product.weight ? parseFloat(product.weight) : undefined,\n      stockQuantity: product.stock_quantity || undefined,\n      stockStatus: product.stock_status,\n      backordersAllowed: product.backorders_allowed || false,\n      soldIndividually: product.sold_individually || false,\n      downloadable: product.downloadable || false,\n      virtual: product.virtual || false,\n      meta: {},\n      addedAt: new Date(),\n      updatedAt: new Date()\n    };\n\n    return cartItem;\n  }\n\n  private createEmptyCart(): Cart {\n    const now = new Date();\n    const sessionId = generateId(); // Using test utility for now\n\n    return {\n      items: [],\n      itemCount: 0,\n      totals: this.calculator.calculate([]),\n      appliedCoupons: [],\n      shippingMethods: [],\n      chosenShippingMethods: [],\n      fees: [],\n      needsShipping: false,\n      needsPayment: false,\n      hasCalculatedShipping: false,\n      currency: 'USD', // TODO: Get from config/API\n      currencySymbol: '$',\n      pricesIncludeTax: this.config.taxCalculation.pricesIncludeTax,\n      taxDisplayMode: this.config.taxCalculation.displayMode === 'both' ? 'excl' : this.config.taxCalculation.displayMode,\n      crossSells: [],\n      isEmpty: true,\n      createdAt: now,\n      updatedAt: now,\n      sessionId\n    };\n  }\n\n  private updateCartWithItems(cart: Cart, items: readonly CartItem[]): Cart {\n    const itemCount = items.reduce((sum, item) => sum + item.quantity, 0);\n    const totals = this.calculator.calculate(items, cart.appliedCoupons);\n    \n    return {\n      ...cart,\n      items,\n      itemCount,\n      totals,\n      isEmpty: items.length === 0,\n      needsShipping: items.some(item => item.weight !== undefined || item.dimensions !== undefined),\n      needsPayment: totals.total > 0,\n      updatedAt: new Date()\n    };\n  }\n\n  // CART SYNCHRONIZATION METHODS\n\n  /**\n   * Set user authentication context for cart synchronization\n   */\n  setAuthContext(authContext: UserAuthContext | null): void {\n    this.authContext = authContext;\n    \n    // Trigger sync if user just authenticated and sync on auth is enabled\n    if (authContext?.isAuthenticated && this.config.sync.enabled && this.config.sync.syncOnAuth) {\n      this.syncCartWithServer().catch(error => {\n        console.error('Failed to sync cart on authentication:', error);\n      });\n    }\n  }\n\n  /**\n   * Get current authentication context\n   */\n  getAuthContext(): UserAuthContext | null {\n    return this.authContext;\n  }\n\n  /**\n   * Get cart synchronization status\n   */\n  getSyncStatus(): CartSyncStatus {\n    return this.syncManager.getStatus();\n  }\n\n  /**\n   * Get last sync timestamp\n   */\n  getLastSyncAt(): Date | undefined {\n    return this.syncManager.getLastSyncAt();\n  }\n\n  /**\n   * Add cart sync event handler\n   */\n  addSyncEventHandler(handler: CartSyncEventHandler): void {\n    this.syncManager.addEventHandler(handler);\n  }\n\n  /**\n   * Remove cart sync event handler\n   */\n  removeSyncEventHandler(handler: CartSyncEventHandler): void {\n    this.syncManager.removeEventHandler(handler);\n  }\n\n  /**\n   * Manually trigger cart synchronization\n   */\n  async syncCartWithServer(): Promise<Result<CartSyncResult, WooError>> {\n    if (!this.config.sync.enabled) {\n      return Ok({\n        success: true,\n        status: 'idle',\n        conflicts: [],\n        syncedAt: new Date(),\n        changes: {\n          itemsAdded: 0,\n          itemsUpdated: 0,\n          itemsRemoved: 0,\n          couponsAdded: 0,\n          couponsRemoved: 0\n        }\n      });\n    }\n\n    if (!this.authContext?.isAuthenticated) {\n      return Err(ErrorFactory.cartError(\n        'User must be authenticated for cart synchronization',\n        { context: 'manual_sync' }\n      ));\n    }\n\n    const cartResult = await this.getCart();\n    if (!cartResult.success) {\n      return cartResult;\n    }\n\n    const syncResult = await this.syncManager.syncCart(cartResult.data, this.authContext);\n    \n    if (syncResult.success && syncResult.data.mergedCart) {\n      // Update local cart with merged cart\n      this.currentCart = syncResult.data.mergedCart;\n      \n      // Save merged cart to local persistence\n      await this.persistence.save(syncResult.data.mergedCart);\n    }\n\n    return syncResult;\n  }\n\n  /**\n   * Enable cart synchronization\n   */\n  enableSync(): void {\n    this.syncManager.enable();\n  }\n\n  /**\n   * Disable cart synchronization\n   */\n  disableSync(): void {\n    this.syncManager.disable();\n  }\n\n  /**\n   * Process offline sync queue\n   */\n  async processOfflineQueue(): Promise<Result<void, WooError>> {\n    if (!this.authContext?.isAuthenticated) {\n      return Ok(undefined);\n    }\n\n    const cartResult = await this.getCart();\n    if (!cartResult.success) {\n      return cartResult;\n    }\n\n    return this.syncManager.processQueue(cartResult.data, this.authContext);\n  }\n\n  /**\n   * Clean up cart service resources\n   */\n  destroy(): void {\n    this.syncManager.destroy();\n    this.currentCart = null;\n    this.authContext = null;\n  }\n} ","/**\n * Advanced Search Engine types for WooCommerce Headless SDK\n * Following the enhanced unified-10x-dev framework\n */\n\nimport { z } from 'zod';\nimport { WooCommerceProduct } from './commerce';\n\n/**\n * Search operators for query building\n */\nexport type SearchOperator = 'AND' | 'OR' | 'NOT';\n\n/**\n * Filter operators for advanced filtering\n */\nexport type FilterOperator = \n  | 'eq'          // equals\n  | 'ne'          // not equals\n  | 'gt'          // greater than\n  | 'gte'         // greater than or equal\n  | 'lt'          // less than\n  | 'lte'         // less than or equal\n  | 'in'          // in array\n  | 'nin'         // not in array\n  | 'contains'    // string contains\n  | 'startswith'  // string starts with\n  | 'endswith'    // string ends with\n  | 'between'     // range between two values\n  | 'exists'      // field exists\n  | 'empty';      // field is empty\n\n/**\n * Sort direction\n */\nexport type SortDirection = 'asc' | 'desc';\n\n/**\n * Search result highlight\n */\nexport interface SearchHighlight {\n  readonly field: string;\n  readonly matches: readonly {\n    readonly text: string;\n    readonly indices: readonly [number, number][];\n  }[];\n}\n\n/**\n * Single search filter\n */\nexport interface SearchFilter {\n  readonly field: string;\n  readonly operator: FilterOperator;\n  readonly value: unknown;\n  readonly label?: string;\n}\n\n/**\n * Range filter for numeric/date values\n */\nexport interface RangeFilter {\n  readonly field: string;\n  readonly min?: number | string;\n  readonly max?: number | string;\n  readonly label?: string;\n}\n\n/**\n * Multi-select filter option\n */\nexport interface FilterOption {\n  readonly value: string | number;\n  readonly label: string;\n  readonly count: number;\n  readonly selected: boolean;\n}\n\n/**\n * Facet definition for filtering\n */\nexport interface SearchFacet {\n  readonly field: string;\n  readonly label: string;\n  readonly type: 'terms' | 'range' | 'date_range' | 'boolean';\n  readonly options: readonly FilterOption[];\n  readonly multiSelect: boolean;\n  readonly collapsed: boolean;\n}\n\n/**\n * Search suggestion\n */\nexport interface SearchSuggestion {\n  readonly text: string;\n  readonly type: 'query' | 'product' | 'category' | 'brand';\n  readonly score: number;\n  readonly metadata?: Record<string, unknown>;\n}\n\n/**\n * Search result item\n */\nexport interface SearchResultItem {\n  readonly item: WooCommerceProduct;\n  readonly score: number;\n  readonly highlights?: readonly SearchHighlight[];\n  readonly matchedFields: readonly string[];\n}\n\n/**\n * Search aggregation result\n */\nexport interface SearchAggregation {\n  readonly field: string;\n  readonly type: 'terms' | 'stats' | 'histogram';\n  readonly buckets?: readonly {\n    readonly key: string | number;\n    readonly count: number;\n    readonly selected: boolean;\n  }[];\n  readonly stats?: {\n    readonly min: number;\n    readonly max: number;\n    readonly avg: number;\n    readonly count: number;\n  };\n}\n\n/**\n * Search sorting configuration\n */\nexport interface SearchSort {\n  readonly field: string;\n  readonly direction: SortDirection;\n  readonly label?: string;\n}\n\n/**\n * Search pagination\n */\nexport interface SearchPagination {\n  readonly page: number;\n  readonly limit: number;\n  readonly offset: number;\n  readonly total: number;\n  readonly totalPages: number;\n}\n\n/**\n * Search query configuration\n */\nexport interface SearchQuery {\n  readonly text: string | undefined;\n  readonly filters: readonly SearchFilter[];\n  readonly rangeFilters: readonly RangeFilter[];\n  readonly categoryIds?: readonly number[];\n  readonly tagIds?: readonly number[];\n  readonly productIds?: readonly number[];\n  readonly excludeProductIds?: readonly number[];\n  readonly inStock: boolean | undefined;\n  readonly onSale: boolean | undefined;\n  readonly featured: boolean | undefined;\n  readonly minPrice: number | undefined;\n  readonly maxPrice: number | undefined;\n  readonly minRating: number | undefined;\n  readonly attributes?: Record<string, string | string[]>;\n  readonly sort: readonly SearchSort[];\n  readonly pagination: SearchPagination;\n  readonly operator: SearchOperator;\n  readonly fuzzy: boolean;\n  readonly highlight: boolean;\n  readonly facets: boolean;\n  readonly suggestions: boolean;\n}\n\n/**\n * Search results\n */\nexport interface SearchResults {\n  readonly query: SearchQuery;\n  readonly items: readonly SearchResultItem[];\n  readonly aggregations: readonly SearchAggregation[];\n  readonly facets: readonly SearchFacet[];\n  readonly suggestions: readonly SearchSuggestion[];\n  readonly pagination: SearchPagination;\n  readonly processingTime: number; // milliseconds\n  readonly totalHits: number;\n  readonly maxScore: number;\n  readonly debug?: {\n    readonly parsedQuery: Record<string, unknown>;\n    readonly executionStats: Record<string, unknown>;\n  };\n}\n\n/**\n * Search analytics event\n */\nexport interface SearchAnalyticsEvent {\n  readonly type: 'search' | 'filter' | 'sort' | 'paginate' | 'suggestion_click' | 'result_click';\n  readonly query: string | undefined;\n  readonly filters?: readonly SearchFilter[];\n  readonly resultPosition?: number;\n  readonly productId?: number;\n  readonly timestamp: Date;\n  readonly sessionId: string;\n  readonly userId?: string;\n  readonly metadata?: Record<string, unknown>;\n}\n\n/**\n * Search history entry\n */\nexport interface SearchHistoryEntry {\n  readonly query: string;\n  readonly timestamp: Date;\n  readonly resultCount: number;\n  readonly clickedResults: readonly number[]; // product IDs\n  readonly conversions: readonly number[]; // product IDs that led to purchase\n}\n\n/**\n * Search configuration\n */\nexport interface AdvancedSearchConfig {\n  readonly fuzzy: {\n    readonly enabled: boolean;\n    readonly threshold: number; // 0.0 = exact match, 1.0 = match anything\n    readonly distance: number; // maximum Levenshtein distance\n    readonly minMatchCharLength: number;\n    readonly includeScore: boolean;\n  };\n  readonly highlighting: {\n    readonly enabled: boolean;\n    readonly preTag: string;\n    readonly postTag: string;\n    readonly fragmentSize: number;\n    readonly maxFragments: number;\n  };\n  readonly suggestions: {\n    readonly enabled: boolean;\n    readonly maxSuggestions: number;\n    readonly minQueryLength: number;\n    readonly showPopular: boolean;\n    readonly showRecent: boolean;\n  };\n  readonly facets: {\n    readonly enabled: boolean;\n    readonly maxFacets: number;\n    readonly maxFacetValues: number;\n    readonly minDocumentCount: number;\n  };\n  readonly analytics: {\n    readonly enabled: boolean;\n    readonly trackQueries: boolean;\n    readonly trackFilters: boolean;\n    readonly trackClicks: boolean;\n    readonly trackConversions: boolean;\n    readonly sessionTimeout: number; // minutes\n  };\n  readonly caching: {\n    readonly enabled: boolean;\n    readonly ttl: number; // milliseconds\n    readonly maxCacheSize: number; // number of cached queries\n    readonly cacheKey: string;\n  };\n  readonly performance: {\n    readonly maxResults: number;\n    readonly searchTimeout: number; // milliseconds\n    readonly debounceDelay: number; // milliseconds for auto-complete\n    readonly prefetchResults: boolean;\n  };\n}\n\n/**\n * Search builder for constructing complex queries\n */\nexport interface SearchQueryBuilder {\n  text(query: string): SearchQueryBuilder;\n  filter(field: string, operator: FilterOperator, value: unknown): SearchQueryBuilder;\n  range(field: string, min?: number, max?: number): SearchQueryBuilder;\n  category(categoryId: number | number[]): SearchQueryBuilder;\n  tag(tagId: number | number[]): SearchQueryBuilder;\n  price(min?: number, max?: number): SearchQueryBuilder;\n  rating(min: number): SearchQueryBuilder;\n  inStock(inStock?: boolean): SearchQueryBuilder;\n  onSale(onSale?: boolean): SearchQueryBuilder;\n  featured(featured?: boolean): SearchQueryBuilder;\n  attribute(name: string, value: string | string[]): SearchQueryBuilder;\n  sort(field: string, direction?: SortDirection): SearchQueryBuilder;\n  page(page: number): SearchQueryBuilder;\n  limit(limit: number): SearchQueryBuilder;\n  fuzzy(enabled?: boolean): SearchQueryBuilder;\n  highlight(enabled?: boolean): SearchQueryBuilder;\n  facets(enabled?: boolean): SearchQueryBuilder;\n  suggestions(enabled?: boolean): SearchQueryBuilder;\n  build(): SearchQuery;\n  reset(): SearchQueryBuilder;\n}\n\n// Zod schemas for validation\nexport const SearchFilterSchema = z.object({\n  field: z.string(),\n  operator: z.enum(['eq', 'ne', 'gt', 'gte', 'lt', 'lte', 'in', 'nin', 'contains', 'startswith', 'endswith', 'between', 'exists', 'empty']),\n  value: z.unknown(),\n  label: z.string().optional(),\n});\n\nexport const RangeFilterSchema = z.object({\n  field: z.string(),\n  min: z.union([z.number(), z.string()]).optional(),\n  max: z.union([z.number(), z.string()]).optional(),\n  label: z.string().optional(),\n});\n\nexport const SearchSortSchema = z.object({\n  field: z.string(),\n  direction: z.enum(['asc', 'desc']),\n  label: z.string().optional(),\n});\n\nexport const SearchPaginationSchema = z.object({\n  page: z.number().min(1),\n  limit: z.number().min(1).max(100),\n  offset: z.number().min(0),\n  total: z.number().min(0),\n  totalPages: z.number().min(0),\n});\n\nexport const SearchQuerySchema = z.object({\n  text: z.string().optional(),\n  filters: z.array(SearchFilterSchema),\n  rangeFilters: z.array(RangeFilterSchema),\n  categoryIds: z.array(z.number().positive()).optional(),\n  tagIds: z.array(z.number().positive()).optional(),\n  productIds: z.array(z.number().positive()).optional(),\n  excludeProductIds: z.array(z.number().positive()).optional(),\n  inStock: z.boolean().optional(),\n  onSale: z.boolean().optional(),\n  featured: z.boolean().optional(),\n  minPrice: z.number().min(0).optional(),\n  maxPrice: z.number().min(0).optional(),\n  minRating: z.number().min(0).max(5).optional(),\n  attributes: z.record(z.union([z.string(), z.array(z.string())])).optional(),\n  sort: z.array(SearchSortSchema),\n  pagination: SearchPaginationSchema,\n  operator: z.enum(['AND', 'OR', 'NOT']),\n  fuzzy: z.boolean(),\n  highlight: z.boolean(),\n  facets: z.boolean(),\n  suggestions: z.boolean(),\n});\n\nexport const SearchAnalyticsEventSchema = z.object({\n  type: z.enum(['search', 'filter', 'sort', 'paginate', 'suggestion_click', 'result_click']),\n  query: z.string().optional(),\n  filters: z.array(SearchFilterSchema).optional(),\n  resultPosition: z.number().positive().optional(),\n  productId: z.number().positive().optional(),\n  timestamp: z.date(),\n  sessionId: z.string(),\n  userId: z.string().optional(),\n  metadata: z.record(z.unknown()).optional(),\n});\n\n// Type guards\nexport function isSearchQuery(obj: unknown): obj is SearchQuery {\n  try {\n    SearchQuerySchema.parse(obj);\n    return true;\n  } catch {\n    return false;\n  }\n}\n\nexport function isSearchFilter(obj: unknown): obj is SearchFilter {\n  try {\n    SearchFilterSchema.parse(obj);\n    return true;\n  } catch {\n    return false;\n  }\n}\n\nexport function isSearchAnalyticsEvent(obj: unknown): obj is SearchAnalyticsEvent {\n  try {\n    SearchAnalyticsEventSchema.parse(obj);\n    return true;\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Quick search parameters for simple searches\n */\nexport interface QuickSearchParams {\n  readonly query?: string;\n  readonly category?: number;\n  readonly minPrice?: number;\n  readonly maxPrice?: number;\n  readonly inStock?: boolean;\n  readonly onSale?: boolean;\n  readonly featured?: boolean;\n  readonly page?: number;\n  readonly limit?: number;\n  readonly sort?: string; // field:direction format, e.g., 'price:asc'\n}\n\n/**\n * Auto-complete request\n */\nexport interface AutoCompleteRequest {\n  readonly query: string;\n  readonly limit?: number;\n  readonly categories?: readonly number[];\n  readonly includeProducts?: boolean;\n  readonly includeCategories?: boolean;\n  readonly includeBrands?: boolean;\n}\n\n/**\n * Auto-complete response\n */\nexport interface AutoCompleteResponse {\n  readonly query: string;\n  readonly suggestions: readonly SearchSuggestion[];\n  readonly products: readonly WooCommerceProduct[];\n  readonly categories: readonly {\n    readonly id: number;\n    readonly name: string;\n    readonly count: number;\n  }[];\n  readonly processingTime: number;\n} ","/**\n * Advanced Search Engine for WooCommerce Headless SDK\n * Following the enhanced unified-10x-dev framework\n */\n\nimport Fuse from 'fuse.js';\nimport { HttpClient } from '../../core/client';\nimport { CacheManager } from '../../core/cache';\nimport { Result, Ok, Err } from '../../types/result';\nimport { WooError, ErrorFactory } from '../../types/errors';\nimport { WooCommerceProduct, ProductSchema } from '../../types/commerce';\nimport { AdvancedSearchConfig } from '../../types/config';\nimport {\n  SearchQuery,\n  SearchResults,\n  SearchResultItem,\n  SearchFilter,\n  RangeFilter,\n  SearchFacet,\n  SearchSuggestion,\n  SearchAggregation,\n  SearchPagination,\n  SearchAnalyticsEvent,\n  SearchHistoryEntry,\n  SearchQueryBuilder,\n  SearchHighlight,\n  QuickSearchParams,\n  AutoCompleteRequest,\n  AutoCompleteResponse,\n  FilterOperator,\n  SortDirection,\n  SearchSort,\n  SearchOperator,\n  SearchQuerySchema,\n  isSearchQuery\n} from '../../types/search';\nimport { generateId } from '../../test/utils';\n\n/**\n * Search analytics manager\n */\nclass SearchAnalyticsManager {\n  private readonly config: AdvancedSearchConfig;\n  private readonly cache: CacheManager;\n  private readonly sessionId: string;\n  private searchHistory: SearchHistoryEntry[] = [];\n\n  constructor(config: AdvancedSearchConfig, cache: CacheManager) {\n    this.config = config;\n    this.cache = cache;\n    this.sessionId = generateId();\n  }\n\n  /**\n   * Track search event\n   */\n  async trackEvent(event: SearchAnalyticsEvent): Promise<Result<void, WooError>> {\n    try {\n      if (!this.config.analytics.enabled) {\n        return Ok(undefined);\n      }\n\n      // Store event in cache for batching\n      const eventKey = `search-analytics:${event.type}:${Date.now()}`;\n      await this.cache.set(eventKey, event);\n\n      // Update search history for query events\n      if (event.type === 'search' && event.query) {\n        await this.updateSearchHistory(event.query, 0); // result count will be updated later\n      }\n\n      return Ok(undefined);\n    } catch (error) {\n      return Err(ErrorFactory.cacheError(\n        'Failed to track search event',\n        error\n      ));\n    }\n  }\n\n  /**\n   * Get search history\n   */\n  async getSearchHistory(limit: number = 10): Promise<Result<SearchHistoryEntry[], WooError>> {\n    try {\n      const cacheKey = 'search-history';\n      const cachedHistory = await this.cache.get<SearchHistoryEntry[]>(cacheKey);\n      \n      if (cachedHistory.success && cachedHistory.data) {\n        return Ok(cachedHistory.data.slice(0, limit));\n      }\n\n      return Ok([]);\n    } catch (error) {\n      return Err(ErrorFactory.cacheError(\n        'Failed to get search history',\n        error\n      ));\n    }\n  }\n\n  /**\n   * Update search history\n   */\n  private async updateSearchHistory(query: string, resultCount: number): Promise<void> {\n    const entry: SearchHistoryEntry = {\n      query,\n      timestamp: new Date(),\n      resultCount,\n      clickedResults: [],\n      conversions: []\n    };\n\n    this.searchHistory.unshift(entry);\n    this.searchHistory = this.searchHistory.slice(0, 50); // Keep last 50 searches\n\n    await this.cache.set('search-history', this.searchHistory);\n  }\n\n  /**\n   * Get session ID\n   */\n  getSessionId(): string {\n    return this.sessionId;\n  }\n}\n\n/**\n * Mutable query builder state interface\n */\ninterface MutableSearchQuery {\n  text?: string;\n  filters: SearchFilter[];\n  rangeFilters: RangeFilter[];\n  categoryIds?: number[];\n  tagIds?: number[];\n  productIds?: number[];\n  excludeProductIds?: number[];\n  inStock?: boolean;\n  onSale?: boolean;\n  featured?: boolean;\n  minPrice?: number;\n  maxPrice?: number;\n  minRating?: number;\n  attributes?: Record<string, string | string[]>;\n  sort: SearchSort[];\n  pagination: SearchPagination;\n  operator: SearchOperator;\n  fuzzy: boolean;\n  highlight: boolean;\n  facets: boolean;\n  suggestions: boolean;\n}\n\n/**\n * Search query builder implementation\n */\nclass SearchQueryBuilderImpl implements SearchQueryBuilder {\n  private query: MutableSearchQuery = {\n    filters: [],\n    rangeFilters: [],\n    sort: [],\n    operator: 'AND',\n    fuzzy: true,\n    highlight: true,\n    facets: true,\n    suggestions: true,\n    pagination: {\n      page: 1,\n      limit: 20,\n      offset: 0,\n      total: 0,\n      totalPages: 0\n    }\n  };\n\n  text(queryText: string): SearchQueryBuilder {\n    this.query.text = queryText;\n    return this;\n  }\n\n  filter(field: string, operator: FilterOperator, value: unknown): SearchQueryBuilder {\n    this.query.filters.push({ field, operator, value });\n    return this;\n  }\n\n  range(field: string, min?: number, max?: number): SearchQueryBuilder {\n    if (min !== undefined || max !== undefined) {\n      const rangeFilter: RangeFilter = { \n        field,\n        ...(min !== undefined && { min }),\n        ...(max !== undefined && { max })\n      };\n      this.query.rangeFilters.push(rangeFilter);\n    }\n    return this;\n  }\n\n  category(categoryId: number | number[]): SearchQueryBuilder {\n    this.query.categoryIds = Array.isArray(categoryId) ? categoryId : [categoryId];\n    return this;\n  }\n\n  tag(tagId: number | number[]): SearchQueryBuilder {\n    this.query.tagIds = Array.isArray(tagId) ? tagId : [tagId];\n    return this;\n  }\n\n  price(min?: number, max?: number): SearchQueryBuilder {\n    if (min !== undefined) this.query.minPrice = min;\n    if (max !== undefined) this.query.maxPrice = max;\n    return this;\n  }\n\n  rating(min: number): SearchQueryBuilder {\n    this.query.minRating = min;\n    return this;\n  }\n\n  inStock(inStock: boolean = true): SearchQueryBuilder {\n    this.query.inStock = inStock;\n    return this;\n  }\n\n  onSale(onSale: boolean = true): SearchQueryBuilder {\n    this.query.onSale = onSale;\n    return this;\n  }\n\n  featured(featured: boolean = true): SearchQueryBuilder {\n    this.query.featured = featured;\n    return this;\n  }\n\n  attribute(name: string, value: string | string[]): SearchQueryBuilder {\n    if (!this.query.attributes) {\n      this.query.attributes = {};\n    }\n    this.query.attributes[name] = value;\n    return this;\n  }\n\n  sort(field: string, direction: SortDirection = 'asc'): SearchQueryBuilder {\n    this.query.sort.push({ field, direction });\n    return this;\n  }\n\n  page(pageNum: number): SearchQueryBuilder {\n    this.query.pagination = {\n      ...this.query.pagination,\n      page: pageNum,\n      offset: (pageNum - 1) * this.query.pagination.limit\n    };\n    return this;\n  }\n\n  limit(limitNum: number): SearchQueryBuilder {\n    this.query.pagination = {\n      ...this.query.pagination,\n      limit: limitNum,\n      offset: (this.query.pagination.page - 1) * limitNum\n    };\n    return this;\n  }\n\n  fuzzy(enabled: boolean = true): SearchQueryBuilder {\n    this.query.fuzzy = enabled;\n    return this;\n  }\n\n  highlight(enabled: boolean = true): SearchQueryBuilder {\n    this.query.highlight = enabled;\n    return this;\n  }\n\n  facets(enabled: boolean = true): SearchQueryBuilder {\n    this.query.facets = enabled;\n    return this;\n  }\n\n  suggestions(enabled: boolean = true): SearchQueryBuilder {\n    this.query.suggestions = enabled;\n    return this;\n  }\n\n  build(): SearchQuery {\n    // Convert mutable query to readonly SearchQuery\n    const completeQuery: SearchQuery = {\n      text: this.query.text || '',\n      filters: [...this.query.filters],\n      rangeFilters: [...this.query.rangeFilters],\n      ...(this.query.categoryIds && { categoryIds: [...this.query.categoryIds] }),\n      ...(this.query.tagIds && { tagIds: [...this.query.tagIds] }),\n      ...(this.query.productIds && { productIds: [...this.query.productIds] }),\n      ...(this.query.excludeProductIds && { excludeProductIds: [...this.query.excludeProductIds] }),\n      inStock: this.query.inStock,\n      onSale: this.query.onSale,\n      featured: this.query.featured,\n      minPrice: this.query.minPrice,\n      maxPrice: this.query.maxPrice,\n      minRating: this.query.minRating,\n      attributes: this.query.attributes ? { ...this.query.attributes } : undefined,\n      sort: [...this.query.sort],\n      pagination: { ...this.query.pagination },\n      operator: this.query.operator,\n      fuzzy: this.query.fuzzy,\n      highlight: this.query.highlight,\n      facets: this.query.facets,\n      suggestions: this.query.suggestions\n    };\n\n    return completeQuery;\n  }\n\n  reset(): SearchQueryBuilder {\n    this.query = {\n      filters: [],\n      rangeFilters: [],\n      sort: [],\n      operator: 'AND',\n      fuzzy: true,\n      highlight: true,\n      facets: true,\n      suggestions: true,\n      pagination: {\n        page: 1,\n        limit: 20,\n        offset: 0,\n        total: 0,\n        totalPages: 0\n      }\n    };\n    return this;\n  }\n}\n\n/**\n * Main advanced search service\n */\nexport class SearchService {\n  private readonly client: HttpClient;\n  private readonly cache: CacheManager;\n  private readonly config: AdvancedSearchConfig;\n  private readonly analytics: SearchAnalyticsManager;\n  private fuseInstance: Fuse<WooCommerceProduct> | null = null;\n  private productsIndex: WooCommerceProduct[] = [];\n\n  constructor(\n    client: HttpClient,\n    cache: CacheManager,\n    config: AdvancedSearchConfig\n  ) {\n    this.client = client;\n    this.cache = cache;\n    this.config = config;\n    this.analytics = new SearchAnalyticsManager(config, cache);\n    this.initializeFuseInstance();\n  }\n\n  /**\n   * Initialize Fuse.js search index\n   */\n  private async initializeFuseInstance(): Promise<void> {\n    try {\n      // Try to load cached products index\n      const cachedIndex = await this.cache.get<WooCommerceProduct[]>('search-index');\n      if (cachedIndex.success && cachedIndex.data) {\n        this.productsIndex = cachedIndex.data;\n        this.createFuseInstance();\n      } else {\n        // Load initial products for index\n        await this.refreshSearchIndex();\n      }\n    } catch (error) {\n      console.warn('Failed to initialize search index:', error);\n    }\n  }\n\n  /**\n   * Create Fuse.js instance with configuration\n   */\n  private createFuseInstance(): void {\n    const fuseOptions: Fuse.IFuseOptions<WooCommerceProduct> = {\n      includeScore: this.config.fuzzy.includeScore,\n      includeMatches: this.config.highlighting.enabled,\n      threshold: this.config.fuzzy.threshold,\n      distance: this.config.fuzzy.distance,\n      minMatchCharLength: this.config.fuzzy.minMatchCharLength,\n      keys: [\n        { name: 'name', weight: 0.4 },\n        { name: 'description', weight: 0.2 },\n        { name: 'short_description', weight: 0.2 },\n        { name: 'sku', weight: 0.3 },\n        { name: 'categories.name', weight: 0.1 },\n        { name: 'tags.name', weight: 0.1 }\n      ]\n    };\n\n    this.fuseInstance = new Fuse(this.productsIndex, fuseOptions);\n  }\n\n  /**\n   * Refresh search index with latest products\n   */\n  async refreshSearchIndex(): Promise<Result<void, WooError>> {\n    try {\n      // Fetch all products for indexing (in chunks to avoid timeout)\n      const allProducts: WooCommerceProduct[] = [];\n      let page = 1;\n      const limit = 100;\n      let hasMore = true;\n\n      while (hasMore) {\n        const response = await this.client.get<WooCommerceProduct[]>(\n          `/products?page=${page}&per_page=${limit}&status=publish`\n        );\n\n        if (!response.success) {\n          return response;\n        }\n\n        const products = response.data.data;\n        if (products.length === 0) {\n          hasMore = false;\n        } else {\n          allProducts.push(...products);\n          page++;\n        }\n\n        // Prevent infinite loops\n        if (page > 50) {\n          break;\n        }\n      }\n\n      this.productsIndex = allProducts;\n      this.createFuseInstance();\n\n      // Cache the index\n      await this.cache.set('search-index', allProducts);\n\n      return Ok(undefined);\n    } catch (error) {\n      return Err(ErrorFactory.apiError(\n        'Failed to refresh search index',\n        500,\n        error\n      ));\n    }\n  }\n\n  /**\n   * Quick search with simple parameters\n   */\n  async quickSearch(params: QuickSearchParams): Promise<Result<SearchResults, WooError>> {\n    try {\n      const builder = this.createQueryBuilder();\n\n      if (params.query) {\n        builder.text(params.query);\n      }\n\n      if (params.category) {\n        builder.category(params.category);\n      }\n\n      if (params.minPrice !== undefined || params.maxPrice !== undefined) {\n        builder.price(params.minPrice, params.maxPrice);\n      }\n\n      if (params.inStock !== undefined) {\n        builder.inStock(params.inStock);\n      }\n\n      if (params.onSale !== undefined) {\n        builder.onSale(params.onSale);\n      }\n\n      if (params.featured !== undefined) {\n        builder.featured(params.featured);\n      }\n\n      if (params.page !== undefined) {\n        builder.page(params.page);\n      }\n\n      if (params.limit !== undefined) {\n        builder.limit(params.limit);\n      }\n\n      if (params.sort) {\n        const [field, direction] = params.sort.split(':');\n        builder.sort(field, (direction as SortDirection) || 'asc');\n      }\n\n      return this.search(builder.build());\n    } catch (error) {\n      return Err(ErrorFactory.apiError(\n        'Failed to perform quick search',\n        500,\n        error\n      ));\n    }\n  }\n\n  /**\n   * Advanced search with full query object\n   */\n  async search(query: SearchQuery): Promise<Result<SearchResults, WooError>> {\n    const startTime = performance.now();\n\n    try {\n      // Validate query\n      const validationResult = this.validateSearchQuery(query);\n      if (!validationResult.success) {\n        return validationResult;\n      }\n\n      // Check cache first\n      const cacheKey = this.generateCacheKey(query);\n      if (this.config.caching.enabled) {\n        const cachedResult = await this.cache.get<SearchResults>(cacheKey);\n        if (cachedResult.success && cachedResult.data) {\n          return Ok(cachedResult.data);\n        }\n      }\n\n      // Track search analytics\n      await this.analytics.trackEvent({\n        type: 'search',\n        query: query.text,\n        filters: query.filters,\n        timestamp: new Date(),\n        sessionId: this.analytics.getSessionId()\n      });\n\n      // Perform search\n      let searchResults: SearchResultItem[] = [];\n\n      if (query.text && this.fuseInstance) {\n        // Use Fuse.js for text search\n        const fuseResults = this.fuseInstance.search(query.text);\n        searchResults = fuseResults.map(result => ({\n          item: result.item,\n          score: result.score || 0,\n          highlights: this.extractHighlights(result),\n          matchedFields: this.extractMatchedFields(result)\n        }));\n      } else {\n        // Use all products if no text query\n        searchResults = this.productsIndex.map(product => ({\n          item: product,\n          score: 1.0,\n          highlights: [],\n          matchedFields: []\n        }));\n      }\n\n      // Apply filters\n      searchResults = this.applyFilters(searchResults, query);\n\n      // Apply sorting\n      searchResults = this.applySorting(searchResults, query.sort);\n\n      // Calculate totals\n      const totalHits = searchResults.length;\n      const maxScore = searchResults.length > 0 ? Math.max(...searchResults.map(r => r.score)) : 0;\n\n      // Apply pagination\n      const { paginatedResults, pagination } = this.applyPagination(searchResults, query.pagination);\n\n      // Generate facets and aggregations\n      const facets = query.facets ? this.generateFacets(searchResults, query) : [];\n      const aggregations = this.generateAggregations(searchResults, query);\n\n      // Generate suggestions\n      const suggestions = query.suggestions ? await this.generateSuggestions(query.text || '') : [];\n\n      const processingTime = performance.now() - startTime;\n\n      const results: SearchResults = {\n        query,\n        items: paginatedResults,\n        aggregations,\n        facets,\n        suggestions,\n        pagination,\n        processingTime,\n        totalHits,\n        maxScore,\n        debug: this.config.analytics.enabled ? {\n          parsedQuery: query,\n          executionStats: {\n            indexSize: this.productsIndex.length,\n            processingTime,\n            cacheHit: false\n          }\n        } : undefined\n      };\n\n      // Cache results\n      if (this.config.caching.enabled) {\n        await this.cache.set(cacheKey, results);\n      }\n\n      return Ok(results);\n\n    } catch (error) {\n      return Err(ErrorFactory.apiError(\n        'Search failed',\n        500,\n        error\n      ));\n    }\n  }\n\n  /**\n   * Auto-complete suggestions\n   */\n  async autoComplete(request: AutoCompleteRequest): Promise<Result<AutoCompleteResponse, WooError>> {\n    const startTime = performance.now();\n\n    try {\n      if (request.query.length < this.config.suggestions.minQueryLength) {\n        return Ok({\n          query: request.query,\n          suggestions: [],\n          products: [],\n          categories: [],\n          processingTime: performance.now() - startTime\n        });\n      }\n\n      const suggestions: SearchSuggestion[] = [];\n      const products: WooCommerceProduct[] = [];\n\n      if (this.fuseInstance && request.includeProducts) {\n        const fuseResults = this.fuseInstance.search(request.query, {\n          limit: request.limit || 5\n        });\n\n        products.push(...fuseResults.map(result => result.item));\n\n        // Generate query suggestions based on product matches\n        fuseResults.forEach(result => {\n          suggestions.push({\n            text: result.item.name,\n            type: 'product',\n            score: result.score || 0,\n            metadata: { productId: result.item.id }\n          });\n        });\n      }\n\n      // TODO: Add category suggestions\n      const categories: { id: number; name: string; count: number }[] = [];\n\n      const response: AutoCompleteResponse = {\n        query: request.query,\n        suggestions: suggestions.slice(0, request.limit || 10),\n        products,\n        categories,\n        processingTime: performance.now() - startTime\n      };\n\n      return Ok(response);\n\n    } catch (error) {\n      return Err(ErrorFactory.apiError(\n        'Auto-complete failed',\n        500,\n        error\n      ));\n    }\n  }\n\n  /**\n   * Create query builder\n   */\n  createQueryBuilder(): SearchQueryBuilder {\n    return new SearchQueryBuilderImpl();\n  }\n\n  /**\n   * Get search analytics\n   */\n  async getSearchHistory(limit?: number): Promise<Result<SearchHistoryEntry[], WooError>> {\n    return this.analytics.getSearchHistory(limit);\n  }\n\n  /**\n   * Track search result click\n   */\n  async trackResultClick(productId: number, position: number, query?: string): Promise<Result<void, WooError>> {\n    return this.analytics.trackEvent({\n      type: 'result_click',\n      query,\n      productId,\n      resultPosition: position,\n      timestamp: new Date(),\n      sessionId: this.analytics.getSessionId()\n    });\n  }\n\n  // Private helper methods\n\n  private validateSearchQuery(query: SearchQuery): Result<void, WooError> {\n    try {\n      SearchQuerySchema.parse(query);\n      return Ok(undefined);\n    } catch (error) {\n      return Err(ErrorFactory.validationError(\n        'Invalid search query',\n        error\n      ));\n    }\n  }\n\n  private generateCacheKey(query: SearchQuery): string {\n    const keyData = {\n      text: query.text,\n      filters: query.filters,\n      rangeFilters: query.rangeFilters,\n      sort: query.sort,\n      pagination: { page: query.pagination.page, limit: query.pagination.limit }\n    };\n    return `search:${btoa(JSON.stringify(keyData))}`;\n  }\n\n  private extractHighlights(fuseResult: Fuse.FuseResult<WooCommerceProduct>): SearchHighlight[] {\n    if (!this.config.highlighting.enabled || !fuseResult.matches) {\n      return [];\n    }\n\n    return fuseResult.matches.map(match => ({\n      field: match.key || '',\n      matches: [{\n        text: match.value || '',\n        indices: match.indices || []\n      }]\n    }));\n  }\n\n  private extractMatchedFields(fuseResult: Fuse.FuseResult<WooCommerceProduct>): string[] {\n    if (!fuseResult.matches) {\n      return [];\n    }\n\n    return fuseResult.matches.map(match => match.key || '').filter(Boolean);\n  }\n\n  private applyFilters(results: SearchResultItem[], query: SearchQuery): SearchResultItem[] {\n    let filteredResults = [...results];\n\n    // Apply basic filters\n    if (query.categoryIds && query.categoryIds.length > 0) {\n      filteredResults = filteredResults.filter(result =>\n        result.item.categories.some(cat => query.categoryIds!.includes(cat.id))\n      );\n    }\n\n    if (query.inStock !== undefined) {\n      filteredResults = filteredResults.filter(result =>\n        query.inStock ? result.item.stock_status === 'instock' : result.item.stock_status !== 'instock'\n      );\n    }\n\n    if (query.onSale !== undefined) {\n      filteredResults = filteredResults.filter(result =>\n        query.onSale ? result.item.on_sale : !result.item.on_sale\n      );\n    }\n\n    if (query.featured !== undefined) {\n      filteredResults = filteredResults.filter(result =>\n        query.featured ? result.item.featured : !result.item.featured\n      );\n    }\n\n    // Apply price filters\n    if (query.minPrice !== undefined || query.maxPrice !== undefined) {\n      filteredResults = filteredResults.filter(result => {\n        const price = parseFloat(result.item.price) || 0;\n        const minOk = query.minPrice === undefined || price >= query.minPrice;\n        const maxOk = query.maxPrice === undefined || price <= query.maxPrice;\n        return minOk && maxOk;\n      });\n    }\n\n    // Apply custom filters\n    query.filters.forEach(filter => {\n      filteredResults = this.applyCustomFilter(filteredResults, filter);\n    });\n\n    // Apply range filters\n    query.rangeFilters.forEach(filter => {\n      filteredResults = this.applyRangeFilter(filteredResults, filter);\n    });\n\n    return filteredResults;\n  }\n\n  private applyCustomFilter(results: SearchResultItem[], filter: SearchFilter): SearchResultItem[] {\n    // TODO: Implement custom filter logic based on filter.field and filter.operator\n    return results;\n  }\n\n  private applyRangeFilter(results: SearchResultItem[], filter: RangeFilter): SearchResultItem[] {\n    // TODO: Implement range filter logic\n    return results;\n  }\n\n  private applySorting(results: SearchResultItem[], sorts: readonly { field: string; direction: SortDirection }[]): SearchResultItem[] {\n    if (sorts.length === 0) {\n      // Default sort by relevance score\n      return results.sort((a, b) => b.score - a.score);\n    }\n\n    return results.sort((a, b) => {\n      for (const sort of sorts) {\n        let aValue: any;\n        let bValue: any;\n\n        switch (sort.field) {\n          case 'price':\n            aValue = parseFloat(a.item.price) || 0;\n            bValue = parseFloat(b.item.price) || 0;\n            break;\n          case 'name':\n            aValue = a.item.name;\n            bValue = b.item.name;\n            break;\n          case 'date':\n            aValue = new Date(a.item.date_created);\n            bValue = new Date(b.item.date_created);\n            break;\n          case 'rating':\n            aValue = parseFloat(a.item.average_rating) || 0;\n            bValue = parseFloat(b.item.average_rating) || 0;\n            break;\n          case 'popularity':\n            aValue = a.item.total_sales || 0;\n            bValue = b.item.total_sales || 0;\n            break;\n          default:\n            aValue = a.score;\n            bValue = b.score;\n        }\n\n        if (aValue < bValue) return sort.direction === 'asc' ? -1 : 1;\n        if (aValue > bValue) return sort.direction === 'asc' ? 1 : -1;\n      }\n      return 0;\n    });\n  }\n\n  private applyPagination(\n    results: SearchResultItem[], \n    pagination: SearchPagination\n  ): { paginatedResults: SearchResultItem[]; pagination: SearchPagination } {\n    const total = results.length;\n    const totalPages = Math.ceil(total / pagination.limit);\n    const offset = (pagination.page - 1) * pagination.limit;\n    const paginatedResults = results.slice(offset, offset + pagination.limit);\n\n    return {\n      paginatedResults,\n      pagination: {\n        ...pagination,\n        total,\n        totalPages,\n        offset\n      }\n    };\n  }\n\n  private generateFacets(results: SearchResultItem[], query: SearchQuery): SearchFacet[] {\n    const facets: SearchFacet[] = [];\n\n    // TODO: Generate facets based on product attributes, categories, etc.\n    // This would analyze the current result set and generate facet options\n\n    return facets;\n  }\n\n  private generateAggregations(results: SearchResultItem[], query: SearchQuery): SearchAggregation[] {\n    const aggregations: SearchAggregation[] = [];\n\n    // Price range aggregation\n    if (results.length > 0) {\n      const prices = results.map(r => parseFloat(r.item.price) || 0).filter(p => p > 0);\n      if (prices.length > 0) {\n        aggregations.push({\n          field: 'price',\n          type: 'stats',\n          stats: {\n            min: Math.min(...prices),\n            max: Math.max(...prices),\n            avg: prices.reduce((a, b) => a + b, 0) / prices.length,\n            count: prices.length\n          }\n        });\n      }\n    }\n\n    return aggregations;\n  }\n\n  private async generateSuggestions(query: string): Promise<SearchSuggestion[]> {\n    const suggestions: SearchSuggestion[] = [];\n\n    if (!query || query.length < this.config.suggestions.minQueryLength) {\n      return suggestions;\n    }\n\n    // Get recent search history for suggestions\n    const historyResult = await this.analytics.getSearchHistory(5);\n    if (historyResult.success) {\n      historyResult.data.forEach(entry => {\n        if (entry.query.toLowerCase().includes(query.toLowerCase())) {\n          suggestions.push({\n            text: entry.query,\n            type: 'query',\n            score: entry.resultCount / 100, // Simple scoring based on result count\n            metadata: { timestamp: entry.timestamp }\n          });\n        }\n      });\n    }\n\n    return suggestions.slice(0, this.config.suggestions.maxSuggestions);\n  }\n} ","/**\n * User Data Integration types for WooCommerce Headless SDK\n * Following the enhanced unified-10x-dev framework\n * Works with external authentication systems (e.g., Better Auth)\n */\n\nimport { z } from 'zod';\n\n/**\n * User roles in WordPress/WooCommerce\n */\nexport type UserRole = \n  | 'customer' \n  | 'shop_manager' \n  | 'administrator' \n  | 'editor' \n  | 'author' \n  | 'contributor' \n  | 'subscriber';\n\n/**\n * User account status\n */\nexport type UserStatus = 'active' | 'inactive' | 'pending' | 'suspended';\n\n/**\n * Gender options\n */\nexport type Gender = 'male' | 'female' | 'other' | 'prefer_not_to_say';\n\n/**\n * Address type\n */\nexport type AddressType = 'billing' | 'shipping';\n\n/**\n * User address information\n */\nexport interface UserAddress {\n  readonly type: AddressType;\n  readonly firstName: string;\n  readonly lastName: string;\n  readonly company?: string;\n  readonly address1: string;\n  readonly address2?: string;\n  readonly city: string;\n  readonly state: string;\n  readonly postcode: string;\n  readonly country: string; // ISO 3166-1 alpha-2 country code\n  readonly phone?: string;\n  readonly email?: string;\n  readonly isDefault: boolean;\n}\n\n/**\n * User preferences and settings\n */\nexport interface UserPreferences {\n  readonly language: string; // ISO 639-1 language code\n  readonly currency: string; // ISO 4217 currency code\n  readonly timezone: string; // IANA timezone identifier\n  readonly dateFormat: string;\n  readonly timeFormat: '12h' | '24h';\n  readonly emailNotifications: {\n    readonly orderUpdates: boolean;\n    readonly promotions: boolean;\n    readonly newsletter: boolean;\n    readonly wishlistReminders: boolean;\n    readonly backInStock: boolean;\n    readonly priceDrops: boolean;\n  };\n  readonly privacy: {\n    readonly profileVisibility: 'public' | 'private' | 'friends';\n    readonly showPurchaseHistory: boolean;\n    readonly allowRecommendations: boolean;\n    readonly dataSharing: boolean;\n  };\n}\n\n/**\n * User profile information\n */\nexport interface UserProfile {\n  readonly id: number;\n  readonly wordpressUserId: number; // WordPress user ID\n  readonly username: string;\n  readonly email: string;\n  readonly firstName: string;\n  readonly lastName: string;\n  readonly displayName: string;\n  readonly avatar?: string; // Avatar URL\n  readonly bio?: string;\n  readonly website?: string;\n  readonly phone?: string;\n  readonly dateOfBirth?: string; // ISO 8601 date\n  readonly gender?: Gender;\n  readonly roles: readonly UserRole[];\n  readonly status: UserStatus;\n  readonly dateRegistered: string; // ISO 8601 datetime\n  readonly lastLogin?: string; // ISO 8601 datetime\n  readonly isEmailVerified: boolean;\n  readonly isPhoneVerified: boolean;\n}\n\n/**\n * WooCommerce customer data\n */\nexport interface CustomerData {\n  readonly id: number;\n  readonly email: string;\n  readonly firstName: string;\n  readonly lastName: string;\n  readonly username: string;\n  readonly role: UserRole;\n  readonly billing: UserAddress;\n  readonly shipping: UserAddress;\n  readonly isPayingCustomer: boolean;\n  readonly ordersCount: number;\n  readonly totalSpent: string; // Monetary amount as string\n  readonly avatarUrl: string;\n  readonly dateCreated: string; // ISO 8601 datetime\n  readonly dateModified: string; // ISO 8601 datetime\n  readonly metaData: readonly {\n    readonly key: string;\n    readonly value: unknown;\n  }[];\n}\n\n/**\n * User's order summary\n */\nexport interface UserOrderSummary {\n  readonly id: number;\n  readonly orderNumber: string;\n  readonly status: string;\n  readonly currency: string;\n  readonly total: string;\n  readonly totalTax: string;\n  readonly subtotal: string;\n  readonly shippingTotal: string;\n  readonly dateCreated: string;\n  readonly dateModified: string;\n  readonly itemCount: number;\n  readonly paymentMethod: string;\n  readonly paymentMethodTitle: string;\n}\n\n/**\n * User wishlist item\n */\nexport interface WishlistItem {\n  readonly id: string;\n  readonly productId: number;\n  readonly variationId?: number;\n  readonly quantity: number;\n  readonly dateAdded: string;\n  readonly notes?: string;\n  readonly priority: 'low' | 'medium' | 'high';\n  readonly isPublic: boolean;\n}\n\n/**\n * User's complete wishlist\n */\nexport interface UserWishlist {\n  readonly id: string;\n  readonly userId: number;\n  readonly name: string;\n  readonly description?: string;\n  readonly items: readonly WishlistItem[];\n  readonly isPublic: boolean;\n  readonly shareToken?: string;\n  readonly dateCreated: string;\n  readonly dateModified: string;\n}\n\n/**\n * User activity log entry\n */\nexport interface UserActivity {\n  readonly id: string;\n  readonly userId: number;\n  readonly type: 'login' | 'logout' | 'order' | 'review' | 'wishlist' | 'profile_update' | 'address_update';\n  readonly description: string;\n  readonly metadata?: Record<string, unknown>;\n  readonly ipAddress?: string;\n  readonly userAgent?: string;\n  readonly timestamp: string; // ISO 8601 datetime\n}\n\n/**\n * User sync configuration\n */\nexport interface UserSyncConfig {\n  readonly enabled: boolean;\n  readonly syncInterval: number; // Sync interval in seconds\n  readonly syncOnLogin: boolean;\n  readonly syncProfile: boolean;\n  readonly syncAddresses: boolean;\n  readonly syncPreferences: boolean;\n  readonly syncOrderHistory: boolean;\n  readonly syncWishlist: boolean;\n  readonly maxOrderHistory: number; // Maximum orders to sync\n  readonly cacheUserData: boolean;\n  readonly cacheTtl: number; // Cache TTL in milliseconds\n}\n\n/**\n * User data sync request\n */\nexport interface UserSyncRequest {\n  readonly userId: number;\n  readonly externalUserId?: string; // ID from external auth system\n  readonly syncProfile?: boolean;\n  readonly syncAddresses?: boolean;\n  readonly syncPreferences?: boolean;\n  readonly syncOrderHistory?: boolean;\n  readonly syncWishlist?: boolean;\n  readonly forceRefresh?: boolean;\n}\n\n/**\n * User data sync response\n */\nexport interface UserSyncResponse {\n  readonly userId: number;\n  readonly syncedAt: string;\n  readonly profile?: UserProfile;\n  readonly customerData?: CustomerData;\n  readonly addresses?: readonly UserAddress[];\n  readonly preferences?: UserPreferences;\n  readonly orderHistory?: readonly UserOrderSummary[];\n  readonly wishlist?: UserWishlist;\n  readonly syncErrors?: readonly string[];\n}\n\n/**\n * User authentication context (from external auth system)\n */\nexport interface UserAuthContext {\n  readonly userId: number;\n  readonly externalUserId?: string; // ID from external auth (e.g., Better Auth)\n  readonly email: string;\n  readonly isAuthenticated: boolean;\n  readonly accessToken?: string; // If needed for API calls\n  readonly refreshToken?: string;\n  readonly tokenExpiry?: string;\n  readonly permissions?: readonly string[];\n  readonly sessionId?: string;\n}\n\n/**\n * User update request\n */\nexport interface UserUpdateRequest {\n  readonly profile?: Partial<Pick<UserProfile, 'firstName' | 'lastName' | 'displayName' | 'bio' | 'website' | 'phone' | 'dateOfBirth' | 'gender'>>;\n  readonly addresses?: readonly UserAddress[];\n  readonly preferences?: Partial<UserPreferences>;\n}\n\n/**\n * Address validation result\n */\nexport interface AddressValidationResult {\n  readonly isValid: boolean;\n  readonly errors: readonly string[];\n  readonly warnings: readonly string[];\n  readonly suggestedAddress?: UserAddress | undefined;\n}\n\n// Zod schemas for validation\nexport const UserAddressSchema = z.object({\n  type: z.enum(['billing', 'shipping']),\n  firstName: z.string().min(1),\n  lastName: z.string().min(1),\n  company: z.string().optional(),\n  address1: z.string().min(1),\n  address2: z.string().optional(),\n  city: z.string().min(1),\n  state: z.string().min(1),\n  postcode: z.string().min(1),\n  country: z.string().length(2), // ISO 3166-1 alpha-2\n  phone: z.string().optional(),\n  email: z.string().email().optional(),\n  isDefault: z.boolean(),\n});\n\nexport const UserPreferencesSchema = z.object({\n  language: z.string().length(2), // ISO 639-1\n  currency: z.string().length(3), // ISO 4217\n  timezone: z.string(),\n  dateFormat: z.string(),\n  timeFormat: z.enum(['12h', '24h']),\n  emailNotifications: z.object({\n    orderUpdates: z.boolean(),\n    promotions: z.boolean(),\n    newsletter: z.boolean(),\n    wishlistReminders: z.boolean(),\n    backInStock: z.boolean(),\n    priceDrops: z.boolean(),\n  }),\n  privacy: z.object({\n    profileVisibility: z.enum(['public', 'private', 'friends']),\n    showPurchaseHistory: z.boolean(),\n    allowRecommendations: z.boolean(),\n    dataSharing: z.boolean(),\n  }),\n});\n\nexport const UserProfileSchema = z.object({\n  id: z.number().positive(),\n  wordpressUserId: z.number().positive(),\n  username: z.string().min(1),\n  email: z.string().email(),\n  firstName: z.string().min(1),\n  lastName: z.string().min(1),\n  displayName: z.string().min(1),\n  avatar: z.string().url().optional(),\n  bio: z.string().optional(),\n  website: z.string().url().optional(),\n  phone: z.string().optional(),\n  dateOfBirth: z.string().optional(),\n  gender: z.enum(['male', 'female', 'other', 'prefer_not_to_say']).optional(),\n  roles: z.array(z.enum(['customer', 'shop_manager', 'administrator', 'editor', 'author', 'contributor', 'subscriber'])),\n  status: z.enum(['active', 'inactive', 'pending', 'suspended']),\n  dateRegistered: z.string(),\n  lastLogin: z.string().optional(),\n  isEmailVerified: z.boolean(),\n  isPhoneVerified: z.boolean(),\n});\n\nexport const UserSyncRequestSchema = z.object({\n  userId: z.number().positive(),\n  externalUserId: z.string().optional(),\n  syncProfile: z.boolean().optional(),\n  syncAddresses: z.boolean().optional(),\n  syncPreferences: z.boolean().optional(),\n  syncOrderHistory: z.boolean().optional(),\n  syncWishlist: z.boolean().optional(),\n  forceRefresh: z.boolean().optional(),\n});\n\nexport const UserAuthContextSchema = z.object({\n  userId: z.number().positive(),\n  externalUserId: z.string().optional(),\n  email: z.string().email(),\n  isAuthenticated: z.boolean(),\n  accessToken: z.string().optional(),\n  refreshToken: z.string().optional(),\n  tokenExpiry: z.string().optional(),\n  permissions: z.array(z.string()).optional(),\n  sessionId: z.string().optional(),\n});\n\n// Type guards\nexport function isUserAddress(obj: unknown): obj is UserAddress {\n  try {\n    UserAddressSchema.parse(obj);\n    return true;\n  } catch {\n    return false;\n  }\n}\n\nexport function isUserProfile(obj: unknown): obj is UserProfile {\n  try {\n    UserProfileSchema.parse(obj);\n    return true;\n  } catch {\n    return false;\n  }\n}\n\nexport function isUserAuthContext(obj: unknown): obj is UserAuthContext {\n  try {\n    UserAuthContextSchema.parse(obj);\n    return true;\n  } catch {\n    return false;\n  }\n}\n\n/**\n * User query parameters for fetching user lists\n */\nexport interface UserListParams {\n  readonly page?: number;\n  readonly limit?: number;\n  readonly search?: string;\n  readonly role?: UserRole;\n  readonly status?: UserStatus;\n  readonly orderBy?: 'id' | 'username' | 'email' | 'registered' | 'display_name';\n  readonly order?: 'asc' | 'desc';\n  readonly include?: readonly number[];\n  readonly exclude?: readonly number[];\n}\n\n/**\n * User list response\n */\nexport interface UserListResponse {\n  readonly users: readonly UserProfile[];\n  readonly total: number;\n  readonly pages: number;\n  readonly page: number;\n  readonly limit: number;\n}\n\n/**\n * User statistics\n */\nexport interface UserStats {\n  readonly totalUsers: number;\n  readonly activeUsers: number;\n  readonly newUsersThisMonth: number;\n  readonly totalCustomers: number;\n  readonly payingCustomers: number;\n  readonly averageOrderValue: string;\n  readonly totalOrdersCount: number;\n  readonly topSpendingCustomers: readonly {\n    readonly userId: number;\n    readonly email: string;\n    readonly totalSpent: string;\n    readonly ordersCount: number;\n  }[];\n} ","/**\n * Email Verification Service for WooCommerce Headless SDK\n * Following the Enhanced Unified 10X Developer Framework\n */\n\nimport { HttpClient } from '../../core/client';\nimport { CacheManager } from '../../core/cache';\nimport { Result, Ok, Err } from '../../types/result';\nimport { WooError, ErrorFactory } from '../../types/errors';\n\n/**\n * Email verification token\n */\nexport interface EmailVerificationToken {\n  readonly token: string;\n  readonly userId: number;\n  readonly email: string;\n  readonly createdAt: Date;\n  readonly expiresAt: Date;\n  readonly isUsed: boolean;\n  readonly attempts: number;\n}\n\n/**\n * Email verification request\n */\nexport interface EmailVerificationRequest {\n  readonly userId: number;\n  readonly email: string;\n  readonly templateType?: 'welcome' | 'change_email' | 'resend';\n  readonly returnUrl?: string;\n  readonly locale?: string;\n}\n\n/**\n * Email verification response\n */\nexport interface EmailVerificationResponse {\n  readonly success: boolean;\n  readonly tokenId: string;\n  readonly expiresAt: Date;\n  readonly message: string;\n}\n\n/**\n * Email verification confirmation request\n */\nexport interface EmailVerificationConfirmRequest {\n  readonly token: string;\n  readonly userId?: number; // Optional for additional security\n}\n\n/**\n * Email verification confirmation response\n */\nexport interface EmailVerificationConfirmResponse {\n  readonly success: boolean;\n  readonly userId: number;\n  readonly email: string;\n  readonly verifiedAt: Date;\n  readonly message: string;\n}\n\n/**\n * Email verification status\n */\nexport interface EmailVerificationStatus {\n  readonly userId: number;\n  readonly email: string;\n  readonly isVerified: boolean;\n  readonly verificationDate?: Date;\n  readonly pendingVerification: boolean;\n  readonly lastTokenSent?: Date;\n  readonly attemptsRemaining: number;\n}\n\n/**\n * Email template configuration\n */\nexport interface EmailTemplate {\n  readonly type: 'welcome' | 'change_email' | 'resend';\n  readonly subject: string;\n  readonly htmlBody: string;\n  readonly textBody: string;\n  readonly fromEmail: string;\n  readonly fromName: string;\n}\n\n/**\n * Email verification configuration\n */\nexport interface EmailVerificationConfig {\n  readonly enabled: boolean;\n  readonly tokenExpiryMinutes: number;\n  readonly maxAttemptsPerDay: number;\n  readonly maxResendAttempts: number;\n  readonly resendCooldownMinutes: number;\n  readonly baseUrl: string;\n  readonly verificationPath: string;\n  readonly autoVerifyOnRegistration: boolean;\n  readonly requireVerificationForPurchase: boolean;\n  readonly emailService: {\n    readonly provider: 'smtp' | 'sendgrid' | 'mailgun' | 'ses' | 'custom';\n    readonly apiKey?: string;\n    readonly apiUrl?: string;\n    readonly fromEmail: string;\n    readonly fromName: string;\n  };\n  readonly templates: {\n    readonly welcome: EmailTemplate;\n    readonly changeEmail: EmailTemplate;\n    readonly resend: EmailTemplate;\n  };\n}\n\n/**\n * Email verification service\n */\nexport class EmailVerificationService {\n  private readonly client: HttpClient;\n  private readonly cache: CacheManager;\n  private readonly config: EmailVerificationConfig;\n\n  constructor(\n    client: HttpClient,\n    cache: CacheManager,\n    config: EmailVerificationConfig\n  ) {\n    this.client = client;\n    this.cache = cache;\n    this.config = config;\n  }\n\n  /**\n   * Send email verification\n   */\n  async sendVerification(request: EmailVerificationRequest): Promise<Result<EmailVerificationResponse, WooError>> {\n    try {\n      if (!this.config.enabled) {\n        return Err(ErrorFactory.configurationError(\n          'Email verification is disabled',\n          'Enable email verification in configuration to use this feature'\n        ));\n      }\n\n      // Check rate limiting\n      const rateLimitResult = await this.checkRateLimit(request.userId, request.email);\n      if (!rateLimitResult.success) {\n        return rateLimitResult;\n      }\n\n      // Generate verification token\n      const token = this.generateVerificationToken();\n      const expiresAt = new Date(Date.now() + (this.config.tokenExpiryMinutes * 60 * 1000));\n\n      // Store token in cache and database\n      const tokenData: EmailVerificationToken = {\n        token,\n        userId: request.userId,\n        email: request.email,\n        createdAt: new Date(),\n        expiresAt,\n        isUsed: false,\n        attempts: 0\n      };\n\n      await this.storeVerificationToken(tokenData);\n\n      // Send email\n      const emailResult = await this.sendVerificationEmail(request, token);\n      if (!emailResult.success) {\n        // Clean up token if email failed\n        await this.removeVerificationToken(token);\n        return emailResult;\n      }\n\n      // Update rate limiting\n      await this.updateRateLimit(request.userId, request.email);\n\n      return Ok({\n        success: true,\n        tokenId: token,\n        expiresAt,\n        message: 'Verification email sent successfully'\n      });\n\n    } catch (error) {\n      return Err(ErrorFactory.apiError(\n        'Failed to send verification email',\n        500,\n        error\n      ));\n    }\n  }\n\n  /**\n   * Confirm email verification\n   */\n  async confirmVerification(request: EmailVerificationConfirmRequest): Promise<Result<EmailVerificationConfirmResponse, WooError>> {\n    try {\n      if (!this.config.enabled) {\n        return Err(ErrorFactory.configurationError(\n          'Email verification is disabled'\n        ));\n      }\n\n      // Retrieve and validate token\n      const tokenResult = await this.getVerificationToken(request.token);\n      if (!tokenResult.success) {\n        return Err(ErrorFactory.validationError(\n          'Invalid or expired verification token'\n        ));\n      }\n\n      const tokenData = tokenResult.data;\n\n      // Check if token is already used\n      if (tokenData.isUsed) {\n        return Err(ErrorFactory.validationError(\n          'Verification token has already been used'\n        ));\n      }\n\n      // Check if token is expired\n      if (new Date() > tokenData.expiresAt) {\n        await this.removeVerificationToken(request.token);\n        return Err(ErrorFactory.validationError(\n          'Verification token has expired'\n        ));\n      }\n\n      // Additional user ID check if provided\n      if (request.userId && request.userId !== tokenData.userId) {\n        return Err(ErrorFactory.validationError(\n          'Token does not match user'\n        ));\n      }\n\n      // Mark email as verified in WooCommerce/WordPress\n      const verificationResult = await this.markEmailAsVerified(tokenData.userId, tokenData.email);\n      if (!verificationResult.success) {\n        return verificationResult;\n      }\n\n      // Mark token as used\n      await this.markTokenAsUsed(request.token);\n\n      // Clear rate limiting for this user\n      await this.clearRateLimit(tokenData.userId, tokenData.email);\n\n      const verifiedAt = new Date();\n\n      return Ok({\n        success: true,\n        userId: tokenData.userId,\n        email: tokenData.email,\n        verifiedAt,\n        message: 'Email verified successfully'\n      });\n\n    } catch (error) {\n      return Err(ErrorFactory.apiError(\n        'Failed to confirm email verification',\n        500,\n        error\n      ));\n    }\n  }\n\n  /**\n   * Get email verification status\n   */\n  async getVerificationStatus(userId: number): Promise<Result<EmailVerificationStatus, WooError>> {\n    try {\n      // Get user data from WordPress/WooCommerce\n      const userResponse = await this.client.get<any>(`/wp/v2/users/${userId}`);\n      if (!userResponse.success) {\n        return Err(ErrorFactory.apiError(\n          'Failed to get user data',\n          404,\n          'User not found'\n        ));\n      }\n\n      const userData = userResponse.data.data;\n      const email = userData.email;\n\n      // Check if email is verified (from user meta)\n      const isVerified = await this.isEmailVerified(userId);\n      const verificationDate = await this.getVerificationDate(userId);\n      \n             // Check for pending verification tokens\n       const pendingTokens = await this.getPendingTokens(userId, email);\n       const pendingVerification = pendingTokens.length > 0;\n       const lastTokenSent: Date | undefined = pendingTokens.length > 0 \n         ? pendingTokens[0].createdAt \n         : undefined;\n\n      // Check rate limiting\n      const rateLimitInfo = await this.getRateLimitInfo(userId, email);\n      const attemptsRemaining = Math.max(0, this.config.maxResendAttempts - rateLimitInfo.attempts);\n\n             const status: EmailVerificationStatus = {\n         userId,\n         email,\n         isVerified,\n         ...(verificationDate && { verificationDate }),\n         pendingVerification,\n         ...(lastTokenSent && { lastTokenSent }),\n         attemptsRemaining\n       };\n\n       return Ok(status);\n\n    } catch (error) {\n      return Err(ErrorFactory.apiError(\n        'Failed to get verification status',\n        500,\n        error\n      ));\n    }\n  }\n\n  /**\n   * Resend verification email\n   */\n  async resendVerification(userId: number): Promise<Result<EmailVerificationResponse, WooError>> {\n    try {\n      // Get user email\n      const userResponse = await this.client.get<any>(`/wp/v2/users/${userId}`);\n      if (!userResponse.success) {\n        return Err(ErrorFactory.apiError(\n          'User not found',\n          404\n        ));\n      }\n\n      const email = userResponse.data.data.email;\n\n      // Check if already verified\n      const isVerified = await this.isEmailVerified(userId);\n      if (isVerified) {\n        return Err(ErrorFactory.validationError(\n          'Email is already verified'\n        ));\n      }\n\n      // Invalidate existing tokens\n      await this.invalidateUserTokens(userId, email);\n\n      // Send new verification\n      return this.sendVerification({\n        userId,\n        email,\n        templateType: 'resend'\n      });\n\n    } catch (error) {\n      return Err(ErrorFactory.apiError(\n        'Failed to resend verification email',\n        500,\n        error\n      ));\n    }\n  }\n\n  /**\n   * Check if email verification is required for a specific action\n   */\n  isVerificationRequired(action: 'purchase' | 'profile_update' | 'password_change'): boolean {\n    switch (action) {\n      case 'purchase':\n        return this.config.requireVerificationForPurchase;\n      case 'profile_update':\n      case 'password_change':\n        return this.config.enabled;\n      default:\n        return false;\n    }\n  }\n\n  // Private helper methods\n\n  /**\n   * Generate verification token\n   */\n  private generateVerificationToken(): string {\n    const timestamp = Date.now().toString(36);\n    const random = Math.random().toString(36).substr(2, 16);\n    const hash = this.simpleHash(`${timestamp}-${random}`);\n    return `${timestamp}${random}${hash}`.substr(0, 64);\n  }\n\n  /**\n   * Simple hash function for token generation\n   */\n  private simpleHash(str: string): string {\n    let hash = 0;\n    for (let i = 0; i < str.length; i++) {\n      const char = str.charCodeAt(i);\n      hash = ((hash << 5) - hash) + char;\n      hash = hash & hash; // Convert to 32-bit integer\n    }\n    return Math.abs(hash).toString(36);\n  }\n\n  /**\n   * Store verification token\n   */\n  private async storeVerificationToken(tokenData: EmailVerificationToken): Promise<Result<void, WooError>> {\n    try {\n      // Store in cache for quick access\n      const cacheKey = `email_verification:${tokenData.token}`;\n      await this.cache.set(cacheKey, tokenData, this.config.tokenExpiryMinutes * 60);\n\n      // Store in user meta (WordPress)\n      const metaKey = '_email_verification_tokens';\n      const existingTokens = await this.getUserTokens(tokenData.userId);\n      const updatedTokens = [...existingTokens, tokenData];\n\n      await this.client.post(`/wp/v2/users/${tokenData.userId}`, {\n        meta: {\n          [metaKey]: JSON.stringify(updatedTokens)\n        }\n      });\n\n      return Ok(undefined);\n\n    } catch (error) {\n      return Err(ErrorFactory.cacheError(\n        'Failed to store verification token',\n        error\n      ));\n    }\n  }\n\n  /**\n   * Get verification token\n   */\n  private async getVerificationToken(token: string): Promise<Result<EmailVerificationToken, WooError>> {\n    try {\n      // Try cache first\n      const cacheKey = `email_verification:${token}`;\n      const cached = await this.cache.get<EmailVerificationToken>(cacheKey);\n      \n      if (cached.success && cached.data) {\n        return Ok(cached.data);\n      }\n\n      // Search in user meta if not in cache\n      // This is a fallback and would be slower\n      return Err(ErrorFactory.validationError(\n        'Verification token not found'\n      ));\n\n    } catch (error) {\n      return Err(ErrorFactory.cacheError(\n        'Failed to retrieve verification token',\n        error\n      ));\n    }\n  }\n\n  /**\n   * Mark email as verified\n   */\n  private async markEmailAsVerified(userId: number, email: string): Promise<Result<void, WooError>> {\n    try {\n      const verificationData = {\n        isEmailVerified: true,\n        emailVerifiedAt: new Date().toISOString(),\n        verifiedEmail: email\n      };\n\n      await this.client.post(`/wp/v2/users/${userId}`, {\n        meta: {\n          '_email_verified': 'true',\n          '_email_verified_at': verificationData.emailVerifiedAt,\n          '_verified_email': email\n        }\n      });\n\n      return Ok(undefined);\n\n    } catch (error) {\n      return Err(ErrorFactory.apiError(\n        'Failed to mark email as verified',\n        500,\n        error\n      ));\n    }\n  }\n\n  /**\n   * Check if email is verified\n   */\n  private async isEmailVerified(userId: number): Promise<boolean> {\n    try {\n      const userResponse = await this.client.get<any>(`/wp/v2/users/${userId}`);\n      if (userResponse.success) {\n        const meta = userResponse.data.data.meta || {};\n        return meta._email_verified === 'true';\n      }\n      return false;\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Get verification date\n   */\n  private async getVerificationDate(userId: number): Promise<Date | undefined> {\n    try {\n      const userResponse = await this.client.get<any>(`/wp/v2/users/${userId}`);\n      if (userResponse.success) {\n        const meta = userResponse.data.data.meta || {};\n        const verifiedAt = meta._email_verified_at;\n        return verifiedAt ? new Date(verifiedAt) : undefined;\n      }\n      return undefined;\n    } catch {\n      return undefined;\n    }\n  }\n\n  /**\n   * Send verification email\n   */\n  private async sendVerificationEmail(\n    request: EmailVerificationRequest,\n    token: string\n  ): Promise<Result<EmailVerificationResponse, WooError>> {\n    try {\n      const template = this.getEmailTemplate(request.templateType || 'welcome');\n      const verificationUrl = this.buildVerificationUrl(token, request.returnUrl);\n\n      const emailData = {\n        to: request.email,\n        subject: template.subject,\n        html: this.processTemplate(template.htmlBody, {\n          verificationUrl,\n          userId: request.userId,\n          email: request.email,\n          expiryMinutes: this.config.tokenExpiryMinutes\n        }),\n        text: this.processTemplate(template.textBody, {\n          verificationUrl,\n          userId: request.userId,\n          email: request.email,\n          expiryMinutes: this.config.tokenExpiryMinutes\n        }),\n        from: {\n          email: template.fromEmail,\n          name: template.fromName\n        }\n      };\n\n      // Send email based on provider\n      const emailResult = await this.sendEmail(emailData);\n      if (!emailResult.success) {\n        return emailResult;\n      }\n\n      return Ok({\n        success: true,\n        tokenId: token,\n        expiresAt: new Date(Date.now() + (this.config.tokenExpiryMinutes * 60 * 1000)),\n        message: 'Verification email sent successfully'\n      });\n\n    } catch (error) {\n      return Err(ErrorFactory.apiError(\n        'Failed to send verification email',\n        500,\n        error\n      ));\n    }\n  }\n\n  /**\n   * Build verification URL\n   */\n  private buildVerificationUrl(token: string, returnUrl?: string): string {\n    const baseUrl = this.config.baseUrl.replace(/\\/$/, '');\n    const path = this.config.verificationPath.replace(/^\\//, '');\n    let url = `${baseUrl}/${path}?token=${encodeURIComponent(token)}`;\n    \n    if (returnUrl) {\n      url += `&return_url=${encodeURIComponent(returnUrl)}`;\n    }\n    \n    return url;\n  }\n\n  /**\n   * Get email template\n   */\n  private getEmailTemplate(type: 'welcome' | 'change_email' | 'resend'): EmailTemplate {\n    return this.config.templates[type];\n  }\n\n  /**\n   * Process email template\n   */\n  private processTemplate(template: string, variables: Record<string, any>): string {\n    let processed = template;\n    \n    for (const [key, value] of Object.entries(variables)) {\n      const placeholder = `{{${key}}}`;\n      processed = processed.replace(new RegExp(placeholder, 'g'), String(value));\n    }\n    \n    return processed;\n  }\n\n  /**\n   * Send email via configured provider\n   */\n  private async sendEmail(emailData: any): Promise<Result<EmailVerificationResponse, WooError>> {\n    try {\n      // This would integrate with the configured email service\n      // For now, return success as placeholder\n      console.log(' Email would be sent:', emailData.subject, 'to', emailData.to);\n      \n      return Ok({\n        success: true,\n        tokenId: 'sent',\n        expiresAt: new Date(),\n        message: 'Email sent successfully'\n      });\n\n    } catch (error) {\n      return Err(ErrorFactory.apiError(\n        'Email delivery failed',\n        500,\n        error\n      ));\n    }\n  }\n\n  /**\n   * Check rate limiting\n   */\n  private async checkRateLimit(userId: number, email: string): Promise<Result<void, WooError>> {\n    const rateLimitInfo = await this.getRateLimitInfo(userId, email);\n    \n    if (rateLimitInfo.attempts >= this.config.maxResendAttempts) {\n      const cooldownEnd = new Date(rateLimitInfo.lastAttempt.getTime() + (this.config.resendCooldownMinutes * 60 * 1000));\n      \n      if (new Date() < cooldownEnd) {\n        return Err(ErrorFactory.validationError(\n          `Too many verification attempts. Please wait ${this.config.resendCooldownMinutes} minutes before trying again.`\n        ));\n      }\n    }\n\n    return Ok(undefined);\n  }\n\n  /**\n   * Get rate limit info\n   */\n  private async getRateLimitInfo(userId: number, email: string): Promise<{ attempts: number; lastAttempt: Date }> {\n    try {\n      const cacheKey = `email_verification_rate_limit:${userId}:${email}`;\n      const cached = await this.cache.get<{ attempts: number; lastAttempt: string }>(cacheKey);\n      \n      if (cached.success && cached.data) {\n        return {\n          attempts: cached.data.attempts,\n          lastAttempt: new Date(cached.data.lastAttempt)\n        };\n      }\n      \n      return { attempts: 0, lastAttempt: new Date(0) };\n    } catch {\n      return { attempts: 0, lastAttempt: new Date(0) };\n    }\n  }\n\n  /**\n   * Update rate limit\n   */\n  private async updateRateLimit(userId: number, email: string): Promise<void> {\n    try {\n      const cacheKey = `email_verification_rate_limit:${userId}:${email}`;\n      const currentInfo = await this.getRateLimitInfo(userId, email);\n      \n      const updatedInfo = {\n        attempts: currentInfo.attempts + 1,\n        lastAttempt: new Date().toISOString()\n      };\n      \n      await this.cache.set(cacheKey, updatedInfo, 24 * 60 * 60); // 24 hours\n    } catch (error) {\n      console.warn('Failed to update rate limit:', error);\n    }\n  }\n\n  /**\n   * Clear rate limit\n   */\n  private async clearRateLimit(userId: number, email: string): Promise<void> {\n    try {\n      const cacheKey = `email_verification_rate_limit:${userId}:${email}`;\n      await this.cache.delete(cacheKey);\n    } catch (error) {\n      console.warn('Failed to clear rate limit:', error);\n    }\n  }\n\n  /**\n   * Get user tokens\n   */\n  private async getUserTokens(userId: number): Promise<EmailVerificationToken[]> {\n    try {\n      const userResponse = await this.client.get<any>(`/wp/v2/users/${userId}`);\n      if (userResponse.success) {\n        const meta = userResponse.data.data.meta || {};\n        const tokensJson = meta._email_verification_tokens;\n        return tokensJson ? JSON.parse(tokensJson) : [];\n      }\n      return [];\n    } catch {\n      return [];\n    }\n  }\n\n  /**\n   * Get pending tokens\n   */\n  private async getPendingTokens(userId: number, email: string): Promise<EmailVerificationToken[]> {\n    const allTokens = await this.getUserTokens(userId);\n    const now = new Date();\n    \n    return allTokens.filter(token => \n      token.email === email &&\n      !token.isUsed &&\n      new Date(token.expiresAt) > now\n    );\n  }\n\n  /**\n   * Mark token as used\n   */\n  private async markTokenAsUsed(token: string): Promise<void> {\n    try {\n      const cacheKey = `email_verification:${token}`;\n      const tokenData = await this.cache.get<EmailVerificationToken>(cacheKey);\n      \n      if (tokenData.success && tokenData.data) {\n        const updatedToken = {\n          ...tokenData.data,\n          isUsed: true\n        };\n        \n        await this.cache.set(cacheKey, updatedToken, this.config.tokenExpiryMinutes * 60);\n      }\n    } catch (error) {\n      console.warn('Failed to mark token as used:', error);\n    }\n  }\n\n  /**\n   * Remove verification token\n   */\n  private async removeVerificationToken(token: string): Promise<void> {\n    try {\n      const cacheKey = `email_verification:${token}`;\n      await this.cache.delete(cacheKey);\n    } catch (error) {\n      console.warn('Failed to remove verification token:', error);\n    }\n  }\n\n  /**\n   * Invalidate user tokens\n   */\n  private async invalidateUserTokens(userId: number, email: string): Promise<void> {\n    try {\n      const tokens = await this.getPendingTokens(userId, email);\n      \n      for (const token of tokens) {\n        await this.removeVerificationToken(token.token);\n      }\n    } catch (error) {\n      console.warn('Failed to invalidate user tokens:', error);\n    }\n  }\n}\n\n/**\n * Default email verification configuration\n */\nexport const DEFAULT_EMAIL_VERIFICATION_CONFIG: EmailVerificationConfig = {\n  enabled: true,\n  tokenExpiryMinutes: 60,\n  maxAttemptsPerDay: 5,\n  maxResendAttempts: 3,\n  resendCooldownMinutes: 15,\n  baseUrl: '',\n  verificationPath: '/verify-email',\n  autoVerifyOnRegistration: false,\n  requireVerificationForPurchase: false,\n  emailService: {\n    provider: 'smtp',\n    fromEmail: 'noreply@example.com',\n    fromName: 'WooCommerce Store'\n  },\n  templates: {\n    welcome: {\n      type: 'welcome',\n      subject: 'Welcome! Please verify your email address',\n      htmlBody: `\n        <h2>Welcome to our store!</h2>\n        <p>Please click the link below to verify your email address:</p>\n        <a href=\"{{verificationUrl}}\" style=\"background: #0073aa; color: white; padding: 12px 24px; text-decoration: none; border-radius: 4px;\">Verify Email</a>\n        <p>This link will expire in {{expiryMinutes}} minutes.</p>\n        <p>If you didn't create this account, please ignore this email.</p>\n      `,\n      textBody: `\n        Welcome to our store!\n        \n        Please verify your email address by clicking this link:\n        {{verificationUrl}}\n        \n        This link will expire in {{expiryMinutes}} minutes.\n        \n        If you didn't create this account, please ignore this email.\n      `,\n      fromEmail: 'noreply@example.com',\n      fromName: 'WooCommerce Store'\n    },\n    changeEmail: {\n      type: 'change_email',\n      subject: 'Verify your new email address',\n      htmlBody: `\n        <h2>Email Address Change</h2>\n        <p>You requested to change your email address. Please click the link below to verify your new email:</p>\n        <a href=\"{{verificationUrl}}\" style=\"background: #0073aa; color: white; padding: 12px 24px; text-decoration: none; border-radius: 4px;\">Verify New Email</a>\n        <p>This link will expire in {{expiryMinutes}} minutes.</p>\n        <p>If you didn't request this change, please contact support immediately.</p>\n      `,\n      textBody: `\n        Email Address Change\n        \n        You requested to change your email address. Please verify your new email by clicking this link:\n        {{verificationUrl}}\n        \n        This link will expire in {{expiryMinutes}} minutes.\n        \n        If you didn't request this change, please contact support immediately.\n      `,\n      fromEmail: 'noreply@example.com',\n      fromName: 'WooCommerce Store'\n    },\n    resend: {\n      type: 'resend',\n      subject: 'Email verification - Resent',\n      htmlBody: `\n        <h2>Email Verification</h2>\n        <p>Here's your requested email verification link:</p>\n        <a href=\"{{verificationUrl}}\" style=\"background: #0073aa; color: white; padding: 12px 24px; text-decoration: none; border-radius: 4px;\">Verify Email</a>\n        <p>This link will expire in {{expiryMinutes}} minutes.</p>\n        <p>If you continue to have issues, please contact support.</p>\n      `,\n      textBody: `\n        Email Verification\n        \n        Here's your requested email verification link:\n        {{verificationUrl}}\n        \n        This link will expire in {{expiryMinutes}} minutes.\n        \n        If you continue to have issues, please contact support.\n      `,\n      fromEmail: 'noreply@example.com',\n      fromName: 'WooCommerce Store'\n    }\n  }\n};","/**\n * Download Management Service for WooCommerce Headless SDK\n * Following the Enhanced Unified 10X Developer Framework\n */\n\nimport { HttpClient } from '../../core/client';\nimport { CacheManager } from '../../core/cache';\nimport { Result, Ok, Err } from '../../types/result';\nimport { WooError, ErrorFactory } from '../../types/errors';\n\n/**\n * Digital product interface\n */\nexport interface DigitalProduct {\n  readonly id: number;\n  readonly name: string;\n  readonly downloadableFiles: readonly DownloadableFile[];\n  readonly downloadLimit?: number;\n  readonly downloadExpiry?: number; // Days until download expires\n  readonly fileSize: number;\n  readonly fileType: string;\n  readonly isDownloadable: boolean;\n}\n\n/**\n * Downloadable file interface\n */\nexport interface DownloadableFile {\n  readonly id: string;\n  readonly name: string;\n  readonly file: string; // URL or file path\n  readonly downloadCount: number;\n  readonly remainingDownloads?: number;\n  readonly fileSize: number;\n  readonly fileType: string;\n  readonly checksum?: string; // For file integrity verification\n}\n\n/**\n * Download link interface\n */\nexport interface DownloadLink {\n  readonly downloadId: string;\n  readonly customerId: number;\n  readonly orderId: number;\n  readonly productId: number;\n  readonly downloadUrl: string;\n  readonly accessToken: string;\n  readonly expiresAt: Date;\n  readonly downloadsRemaining: number;\n  readonly fileSize: number;\n  readonly fileName: string;\n  readonly secureUrl: string;\n}\n\n/**\n * Download permission interface\n */\nexport interface DownloadPermission {\n  readonly permissionId: string;\n  readonly customerId: number;\n  readonly orderId: number;\n  readonly productId: number;\n  readonly downloadId: string;\n  readonly downloadsRemaining: number;\n  readonly accessGranted: Date;\n  readonly accessExpires: Date | undefined;\n  readonly orderKey: string;\n  readonly isActive: boolean;\n}\n\n/**\n * Customer download interface\n */\nexport interface CustomerDownload {\n  readonly permissionId: string;\n  readonly orderId: number;\n  readonly orderDate: Date;\n  readonly productId: number;\n  readonly productName: string;\n  readonly downloadId: string;\n  readonly fileName: string;\n  readonly fileSize: number;\n  readonly downloadsRemaining: number;\n  readonly accessExpires: Date | undefined;\n  readonly downloadUrl: string;\n  readonly isExpired: boolean;\n  readonly canDownload: boolean;\n}\n\n/**\n * Download analytics interface\n */\nexport interface DownloadAnalytics {\n  readonly downloadId: string;\n  readonly customerId: number;\n  readonly productId: number;\n  readonly downloadedAt: Date;\n  readonly ipAddress: string;\n  readonly userAgent: string;\n  readonly fileSize: number;\n  readonly downloadDuration?: number;\n  readonly successful: boolean;\n  readonly errorMessage?: string;\n  readonly bandwidth: number; // bytes per second\n}\n\n/**\n * Download request interface\n */\nexport interface DownloadRequest {\n  readonly permissionId: string;\n  readonly customerId: number;\n  readonly ipAddress: string;\n  readonly userAgent: string;\n  readonly validateOwnership?: boolean;\n}\n\n/**\n * Download validation result\n */\nexport interface DownloadValidationResult {\n  readonly isValid: boolean;\n  readonly permission: DownloadPermission | undefined;\n  readonly errors: readonly string[];\n  readonly warnings: readonly string[];\n}\n\n/**\n * Download statistics\n */\nexport interface DownloadStatistics {\n  readonly totalDownloads: number;\n  readonly totalBandwidth: number;\n  readonly popularProducts: readonly {\n    readonly productId: number;\n    readonly productName: string;\n    readonly downloadCount: number;\n  }[];\n  readonly downloadsByDate: readonly {\n    readonly date: string;\n    readonly count: number;\n    readonly bandwidth: number;\n  }[];\n  readonly averageFileSize: number;\n  readonly successRate: number;\n}\n\n/**\n * Download configuration\n */\nexport interface DownloadConfig {\n  readonly enabled: boolean;\n  readonly maxDownloadsPerProduct: number;\n  readonly defaultExpiryDays: number;\n  readonly maxFileSize: number; // bytes\n  readonly allowedFileTypes: readonly string[];\n  readonly secureDownloads: boolean;\n  readonly trackAnalytics: boolean;\n  readonly rateLimiting: {\n    readonly enabled: boolean;\n    readonly maxDownloadsPerHour: number;\n    readonly maxBandwidthPerHour: number; // bytes\n  };\n  readonly security: {\n    readonly tokenExpiryMinutes: number;\n    readonly ipValidation: boolean;\n    readonly checksumValidation: boolean;\n    readonly encryptFiles: boolean;\n  };\n  readonly storage: {\n    readonly provider: 'local' | 'aws-s3' | 'google-cloud' | 'azure';\n    readonly basePath: string;\n    readonly secureBasePath: string;\n    readonly cdnUrl?: string;\n  };\n}\n\n/**\n * File stream interface for downloads\n */\nexport interface FileStream {\n  readonly stream: ReadableStream;\n  readonly fileName: string;\n  readonly fileSize: number;\n  readonly mimeType: string;\n  readonly headers: Record<string, string>;\n}\n\n/**\n * Download management service\n */\nexport class DownloadManagementService {\n  private readonly client: HttpClient;\n  private readonly cache: CacheManager;\n  private readonly config: DownloadConfig;\n\n  constructor(\n    client: HttpClient,\n    cache: CacheManager,\n    config: DownloadConfig\n  ) {\n    this.client = client;\n    this.cache = cache;\n    this.config = config;\n  }\n\n  /**\n   * Get customer's downloadable products\n   */\n  async getCustomerDownloads(customerId: number): Promise<Result<CustomerDownload[], WooError>> {\n    try {\n      if (!this.config.enabled) {\n        return Err(ErrorFactory.configurationError(\n          'Download management is disabled',\n          'Enable download management in configuration to use this feature'\n        ));\n      }\n\n      // Get customer's download permissions from WooCommerce\n      const response = await this.client.get<any>(`/customers/${customerId}/downloads`);\n      \n      if (!response.success) {\n        return Err(ErrorFactory.apiError(\n          'Failed to fetch customer downloads',\n          response.error?.statusCode || 500,\n          response.error\n        ));\n      }\n\n      const downloads = response.data.data;\n      const customerDownloads: CustomerDownload[] = [];\n\n      for (const download of downloads) {\n        const customerDownload = await this.mapToCustomerDownload(download);\n        if (customerDownload) {\n          customerDownloads.push(customerDownload);\n        }\n      }\n\n      // Sort by order date (newest first)\n      customerDownloads.sort((a, b) => b.orderDate.getTime() - a.orderDate.getTime());\n\n      return Ok(customerDownloads);\n\n    } catch (error) {\n      return Err(ErrorFactory.apiError(\n        'Failed to get customer downloads',\n        500,\n        error\n      ));\n    }\n  }\n\n  /**\n   * Generate secure download link\n   */\n  async generateDownloadLink(request: DownloadRequest): Promise<Result<DownloadLink, WooError>> {\n    try {\n      // Validate download permission\n      const validationResult = await this.validateDownloadPermission(request);\n      if (!validationResult.isValid || !validationResult.permission) {\n        return Err(ErrorFactory.validationError(\n          'Download permission validation failed',\n          validationResult.errors.join(', ')\n        ));\n      }\n\n      const permission = validationResult.permission;\n\n      // Check rate limiting\n      if (this.config.rateLimiting.enabled) {\n        const rateLimitResult = await this.checkRateLimit(request.customerId, request.ipAddress);\n        if (!rateLimitResult.success) {\n          return rateLimitResult;\n        }\n      }\n\n      // Generate secure access token\n      const accessToken = this.generateSecureToken(permission);\n      const expiresAt = new Date(Date.now() + (this.config.security.tokenExpiryMinutes * 60 * 1000));\n\n      // Get file information\n      const fileInfo = await this.getFileInformation(permission.downloadId);\n      if (!fileInfo.success) {\n        return fileInfo;\n      }\n\n      const file = fileInfo.data;\n\n      // Generate secure download URL\n      const secureUrl = this.generateSecureUrl(accessToken, permission.downloadId);\n\n      // Cache the token for validation\n      await this.cacheDownloadToken(accessToken, permission, expiresAt);\n\n      const downloadLink: DownloadLink = {\n        downloadId: permission.downloadId,\n        customerId: permission.customerId,\n        orderId: permission.orderId,\n        productId: permission.productId,\n        downloadUrl: secureUrl,\n        accessToken,\n        expiresAt,\n        downloadsRemaining: permission.downloadsRemaining,\n        fileSize: file.fileSize,\n        fileName: file.fileName,\n        secureUrl\n      };\n\n      return Ok(downloadLink);\n\n    } catch (error) {\n      return Err(ErrorFactory.apiError(\n        'Failed to generate download link',\n        500,\n        error\n      ));\n    }\n  }\n\n  /**\n   * Validate download permission\n   */\n  async validateDownloadPermission(request: DownloadRequest): Promise<DownloadValidationResult> {\n    const errors: string[] = [];\n    const warnings: string[] = [];\n\n    try {\n      // Get permission from WooCommerce\n      const permissionResponse = await this.client.get<any>(`/customers/${request.customerId}/downloads/${request.permissionId}`);\n      \n      if (!permissionResponse.success) {\n        errors.push('Download permission not found');\n        return { isValid: false, permission: undefined, errors, warnings };\n      }\n\n      const permissionData = permissionResponse.data.data;\n      const permission = this.mapToDownloadPermission(permissionData);\n\n      // Validate ownership\n      if (request.validateOwnership && permission.customerId !== request.customerId) {\n        errors.push('Customer does not own this download');\n      }\n\n      // Check if permission is active\n      if (!permission.isActive) {\n        errors.push('Download permission is not active');\n      }\n\n      // Check download limits\n      if (permission.downloadsRemaining <= 0) {\n        errors.push('Download limit exceeded');\n      }\n\n      // Check expiration\n      if (permission.accessExpires && new Date() > permission.accessExpires) {\n        errors.push('Download access has expired');\n      }\n\n      // IP validation if enabled\n      if (this.config.security.ipValidation) {\n        const ipValidation = await this.validateCustomerIP(request.customerId, request.ipAddress);\n        if (!ipValidation) {\n          warnings.push('Download from unusual IP address');\n        }\n      }\n\n      return {\n        isValid: errors.length === 0,\n        permission: errors.length === 0 ? permission : undefined,\n        errors,\n        warnings\n      };\n\n    } catch (error) {\n      errors.push('Failed to validate download permission');\n      return { isValid: false, permission: undefined, errors, warnings };\n    }\n  }\n\n  /**\n   * Track download attempt\n   */\n  async trackDownload(analytics: DownloadAnalytics): Promise<Result<void, WooError>> {\n    try {\n      if (!this.config.trackAnalytics) {\n        return Ok(undefined);\n      }\n\n      // Store analytics in cache for immediate access\n      const cacheKey = `download_analytics:${analytics.downloadId}:${Date.now()}`;\n      await this.cache.set(cacheKey, analytics, 24 * 60 * 60); // 24 hours\n\n      // Store in WooCommerce (could be custom table or meta data)\n      const analyticsData = {\n        download_id: analytics.downloadId,\n        customer_id: analytics.customerId,\n        product_id: analytics.productId,\n        downloaded_at: analytics.downloadedAt.toISOString(),\n        ip_address: analytics.ipAddress,\n        user_agent: analytics.userAgent,\n        file_size: analytics.fileSize,\n        download_duration: analytics.downloadDuration,\n        successful: analytics.successful,\n        error_message: analytics.errorMessage,\n        bandwidth: analytics.bandwidth\n      };\n\n      // This would typically go to a custom analytics endpoint\n      await this.client.post('/download-analytics', analyticsData);\n\n      return Ok(undefined);\n\n    } catch (error) {\n      // Don't fail the download if analytics tracking fails\n      console.warn('Failed to track download analytics:', error);\n      return Ok(undefined);\n    }\n  }\n\n  /**\n   * Serve secure file download\n   */\n  async serveFile(downloadToken: string): Promise<Result<FileStream, WooError>> {\n    try {\n      // Validate download token\n      const tokenValidation = await this.validateDownloadToken(downloadToken);\n      if (!tokenValidation.success) {\n        return tokenValidation;\n      }\n\n      const { permission, fileInfo } = tokenValidation.data;\n\n      // Update download count\n      await this.updateDownloadCount(permission.permissionId);\n\n      // Generate file stream\n      const fileStream = await this.createFileStream(fileInfo.filePath, fileInfo.fileName, fileInfo.fileSize);\n      if (!fileStream.success) {\n        return fileStream;\n      }\n\n      // Track download start\n      const startTime = Date.now();\n      await this.trackDownload({\n        downloadId: permission.downloadId,\n        customerId: permission.customerId,\n        productId: permission.productId,\n        downloadedAt: new Date(),\n        ipAddress: '', // Would be provided by the request context\n        userAgent: '', // Would be provided by the request context\n        fileSize: fileInfo.fileSize,\n        successful: true,\n        bandwidth: 0 // Would be calculated during transfer\n      });\n\n      return Ok(fileStream.data);\n\n    } catch (error) {\n      return Err(ErrorFactory.apiError(\n        'Failed to serve file download',\n        500,\n        error\n      ));\n    }\n  }\n\n  /**\n   * Get download statistics\n   */\n  async getDownloadStatistics(\n    customerId?: number,\n    startDate?: Date,\n    endDate?: Date\n  ): Promise<Result<DownloadStatistics, WooError>> {\n    try {\n      if (!this.config.trackAnalytics) {\n        return Err(ErrorFactory.configurationError(\n          'Download analytics is disabled'\n        ));\n      }\n\n      // Build query parameters\n      const params: any = {};\n      if (customerId) params.customer_id = customerId;\n      if (startDate) params.start_date = startDate.toISOString().split('T')[0];\n      if (endDate) params.end_date = endDate.toISOString().split('T')[0];\n\n      // Get analytics data\n      const response = await this.client.get<any>('/download-analytics/stats', params);\n      \n      if (!response.success) {\n        return Err(ErrorFactory.apiError(\n          'Failed to fetch download statistics',\n          response.error?.statusCode || 500,\n          response.error\n        ));\n      }\n\n      const data = response.data.data;\n      \n      const statistics: DownloadStatistics = {\n        totalDownloads: data.total_downloads || 0,\n        totalBandwidth: data.total_bandwidth || 0,\n        popularProducts: data.popular_products?.map((p: any) => ({\n          productId: p.product_id,\n          productName: p.product_name,\n          downloadCount: p.download_count\n        })) || [],\n        downloadsByDate: data.downloads_by_date?.map((d: any) => ({\n          date: d.date,\n          count: d.count,\n          bandwidth: d.bandwidth\n        })) || [],\n        averageFileSize: data.average_file_size || 0,\n        successRate: data.success_rate || 100\n      };\n\n      return Ok(statistics);\n\n    } catch (error) {\n      return Err(ErrorFactory.apiError(\n        'Failed to get download statistics',\n        500,\n        error\n      ));\n    }\n  }\n\n  /**\n   * Cleanup expired downloads\n   */\n  async cleanupExpiredDownloads(): Promise<Result<number, WooError>> {\n    try {\n      let cleanedCount = 0;\n\n      // Note: Since CacheManager doesn't have a keys() method,\n      // this cleanup would need to be implemented differently\n      // For now, we'll return 0 and add a note for future implementation\n      \n      // TODO: Implement cleanup using a separate tracking mechanism\n      // or extend CacheManager to support key pattern matching\n      \n      return Ok(cleanedCount);\n\n    } catch (error) {\n      return Err(ErrorFactory.apiError(\n        'Failed to cleanup expired downloads',\n        500,\n        error\n      ));\n    }\n  }\n\n  // Private helper methods\n\n  /**\n   * Map WooCommerce download data to CustomerDownload\n   */\n  private async mapToCustomerDownload(downloadData: any): Promise<CustomerDownload | null> {\n    try {\n      const now = new Date();\n      const accessExpires = downloadData.access_expires ? new Date(downloadData.access_expires) : undefined;\n      const isExpired = accessExpires ? now > accessExpires : false;\n      const canDownload = downloadData.downloads_remaining > 0 && !isExpired;\n\n      return {\n        permissionId: downloadData.permission_id,\n        orderId: downloadData.order_id,\n        orderDate: new Date(downloadData.order_date),\n        productId: downloadData.product_id,\n        productName: downloadData.product_name,\n        downloadId: downloadData.download_id,\n        fileName: downloadData.file_name,\n        fileSize: downloadData.file_size || 0,\n        downloadsRemaining: downloadData.downloads_remaining,\n        accessExpires,\n        downloadUrl: '', // Will be generated when needed\n        isExpired,\n        canDownload\n      };\n    } catch (error) {\n      console.warn('Failed to map download data:', error);\n      return null;\n    }\n  }\n\n  /**\n   * Map to DownloadPermission\n   */\n  private mapToDownloadPermission(data: any): DownloadPermission {\n    return {\n      permissionId: data.permission_id,\n      customerId: data.customer_id,\n      orderId: data.order_id,\n      productId: data.product_id,\n      downloadId: data.download_id,\n      downloadsRemaining: data.downloads_remaining,\n      accessGranted: new Date(data.access_granted),\n      accessExpires: data.access_expires ? new Date(data.access_expires) : undefined,\n      orderKey: data.order_key,\n      isActive: data.is_active || true\n    };\n  }\n\n  /**\n   * Generate secure token\n   */\n  private generateSecureToken(permission: DownloadPermission): string {\n    const timestamp = Date.now().toString(36);\n    const random = Math.random().toString(36).substr(2, 16);\n    const hash = this.simpleHash(`${permission.permissionId}-${permission.customerId}-${timestamp}`);\n    return `dl_${timestamp}${random}${hash}`.substr(0, 64);\n  }\n\n  /**\n   * Simple hash function\n   */\n  private simpleHash(str: string): string {\n    let hash = 0;\n    for (let i = 0; i < str.length; i++) {\n      const char = str.charCodeAt(i);\n      hash = ((hash << 5) - hash) + char;\n      hash = hash & hash;\n    }\n    return Math.abs(hash).toString(36);\n  }\n\n  /**\n   * Generate secure download URL\n   */\n  private generateSecureUrl(token: string, downloadId: string): string {\n    const baseUrl = this.config.storage.basePath;\n    return `${baseUrl}/download/${token}/${downloadId}`;\n  }\n\n  /**\n   * Cache download token\n   */\n  private async cacheDownloadToken(\n    token: string, \n    permission: DownloadPermission, \n    expiresAt: Date\n  ): Promise<void> {\n    const cacheKey = `download_token:${token}`;\n    const tokenData = {\n      permission,\n      expiresAt: expiresAt.toISOString(),\n      createdAt: new Date().toISOString()\n    };\n    \n    const ttl = Math.floor((expiresAt.getTime() - Date.now()) / 1000);\n    await this.cache.set(cacheKey, tokenData, ttl);\n  }\n\n  /**\n   * Validate download token\n   */\n  private async validateDownloadToken(token: string): Promise<Result<{ permission: DownloadPermission; fileInfo: any }, WooError>> {\n    try {\n      const cacheKey = `download_token:${token}`;\n      const tokenData = await this.cache.get<{\n        permission: DownloadPermission;\n        expiresAt: string;\n        createdAt: string;\n      }>(cacheKey);\n      \n      if (!tokenData.success || !tokenData.data) {\n        return Err(ErrorFactory.validationError(\n          'Invalid or expired download token'\n        ));\n      }\n\n      const data = tokenData.data;\n      const expiresAt = new Date(data.expiresAt);\n      \n      if (new Date() > expiresAt) {\n        await this.cache.delete(cacheKey);\n        return Err(ErrorFactory.validationError(\n          'Download token has expired'\n        ));\n      }\n\n      // Get file information\n      const fileInfo = await this.getFileInformation(data.permission.downloadId);\n      if (!fileInfo.success) {\n        return fileInfo;\n      }\n\n      return Ok({\n        permission: data.permission,\n        fileInfo: fileInfo.data\n      });\n\n    } catch (error) {\n      return Err(ErrorFactory.validationError(\n        'Failed to validate download token'\n      ));\n    }\n  }\n\n  /**\n   * Get file information\n   */\n  private async getFileInformation(downloadId: string): Promise<Result<any, WooError>> {\n    try {\n      // This would fetch file metadata from WooCommerce or file system\n      // For now, return placeholder data\n      const fileInfo = {\n        downloadId,\n        fileName: `file_${downloadId}.zip`,\n        fileSize: 1024 * 1024, // 1MB placeholder\n        filePath: `/secure/downloads/${downloadId}`,\n        mimeType: 'application/zip'\n      };\n\n      return Ok(fileInfo);\n\n    } catch (error) {\n      return Err(ErrorFactory.apiError(\n        'Failed to get file information',\n        500,\n        error\n      ));\n    }\n  }\n\n  /**\n   * Create file stream\n   */\n  private async createFileStream(\n    filePath: string, \n    fileName: string, \n    fileSize: number\n  ): Promise<Result<FileStream, WooError>> {\n    try {\n      // This would create an actual file stream\n      // For now, return placeholder\n      const stream = new ReadableStream({\n        start(controller) {\n          // Placeholder stream implementation\n          controller.enqueue(new Uint8Array([1, 2, 3, 4, 5]));\n          controller.close();\n        }\n      });\n\n      const fileStream: FileStream = {\n        stream,\n        fileName,\n        fileSize,\n        mimeType: this.getMimeType(fileName),\n        headers: {\n          'Content-Disposition': `attachment; filename=\"${fileName}\"`,\n          'Content-Length': fileSize.toString(),\n          'Content-Type': this.getMimeType(fileName),\n          'Cache-Control': 'no-cache, no-store, must-revalidate'\n        }\n      };\n\n      return Ok(fileStream);\n\n    } catch (error) {\n      return Err(ErrorFactory.apiError(\n        'Failed to create file stream',\n        500,\n        error\n      ));\n    }\n  }\n\n  /**\n   * Get MIME type from file name\n   */\n  private getMimeType(fileName: string): string {\n    const extension = fileName.split('.').pop()?.toLowerCase();\n    const mimeTypes: Record<string, string> = {\n      'pdf': 'application/pdf',\n      'zip': 'application/zip',\n      'exe': 'application/octet-stream',\n      'dmg': 'application/octet-stream',\n      'mp4': 'video/mp4',\n      'mp3': 'audio/mpeg',\n      'jpg': 'image/jpeg',\n      'jpeg': 'image/jpeg',\n      'png': 'image/png',\n      'txt': 'text/plain'\n    };\n    \n    return mimeTypes[extension || ''] || 'application/octet-stream';\n  }\n\n  /**\n   * Check rate limiting\n   */\n  private async checkRateLimit(customerId: number, ipAddress: string): Promise<Result<void, WooError>> {\n    if (!this.config.rateLimiting.enabled) {\n      return Ok(undefined);\n    }\n\n    try {\n      const hourlyKey = `rate_limit:downloads:${customerId}:${new Date().getHours()}`;\n      const cached = await this.cache.get<number>(hourlyKey);\n      const currentCount = cached.success ? (cached.data || 0) : 0;\n\n      if (currentCount >= this.config.rateLimiting.maxDownloadsPerHour) {\n        return Err(ErrorFactory.validationError(\n          `Download rate limit exceeded. Maximum ${this.config.rateLimiting.maxDownloadsPerHour} downloads per hour.`\n        ));\n      }\n\n      // Update count\n      await this.cache.set(hourlyKey, currentCount + 1, 3600); // 1 hour TTL\n\n      return Ok(undefined);\n\n    } catch (error) {\n      // Don't fail downloads if rate limiting check fails\n      console.warn('Rate limiting check failed:', error);\n      return Ok(undefined);\n    }\n  }\n\n  /**\n   * Validate customer IP\n   */\n  private async validateCustomerIP(customerId: number, ipAddress: string): Promise<boolean> {\n    try {\n      // This would implement IP validation logic\n      // For now, return true as placeholder\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Update download count\n   */\n  private async updateDownloadCount(permissionId: string): Promise<void> {\n    try {\n      // Update download count in WooCommerce\n      await this.client.post(`/download-permissions/${permissionId}/increment`);\n    } catch (error) {\n      console.warn('Failed to update download count:', error);\n    }\n  }\n}\n\n/**\n * Default download management configuration\n */\nexport const DEFAULT_DOWNLOAD_CONFIG: DownloadConfig = {\n  enabled: true,\n  maxDownloadsPerProduct: 5,\n  defaultExpiryDays: 30,\n  maxFileSize: 500 * 1024 * 1024, // 500MB\n  allowedFileTypes: ['pdf', 'zip', 'exe', 'dmg', 'mp4', 'mp3', 'jpg', 'png'],\n  secureDownloads: true,\n  trackAnalytics: true,\n  rateLimiting: {\n    enabled: true,\n    maxDownloadsPerHour: 10,\n    maxBandwidthPerHour: 1024 * 1024 * 1024 // 1GB\n  },\n  security: {\n    tokenExpiryMinutes: 60,\n    ipValidation: false,\n    checksumValidation: true,\n    encryptFiles: false\n  },\n  storage: {\n    provider: 'local',\n    basePath: '/downloads',\n    secureBasePath: '/secure/downloads'\n  }\n};","/**\n * User Data Integration Service for WooCommerce Headless SDK\n * Following the enhanced unified-10x-dev framework\n * Works with external authentication systems (e.g., Better Auth)\n */\n\nimport { HttpClient } from '../../core/client';\nimport { CacheManager } from '../../core/cache';\nimport { Result, Ok, Err } from '../../types/result';\nimport { WooError, ErrorFactory } from '../../types/errors';\nimport { UserSyncConfig } from '../../types/config';\nimport {\n  UserProfile,\n  CustomerData,\n  UserAddress,\n  UserPreferences,\n  UserOrderSummary,\n  UserWishlist,\n  WishlistItem,\n  UserActivity,\n  UserAuthContext,\n  UserSyncRequest,\n  UserSyncResponse,\n  UserUpdateRequest,\n  AddressValidationResult,\n  UserListParams,\n  UserListResponse,\n  UserStats,\n  UserRole,\n  UserStatus,\n  UserProfileSchema,\n  UserAddressSchema,\n  UserPreferencesSchema,\n  UserSyncRequestSchema,\n  UserAuthContextSchema,\n  isUserProfile,\n  isUserAddress,\n  isUserAuthContext\n} from '../../types/user';\nimport { generateId } from '../../test/utils';\nimport { \n  EmailVerificationService, \n  EmailVerificationConfig, \n  EmailVerificationRequest,\n  EmailVerificationConfirmRequest,\n  EmailVerificationResponse,\n  EmailVerificationConfirmResponse,\n  EmailVerificationStatus,\n  DEFAULT_EMAIL_VERIFICATION_CONFIG\n} from './email-verification';\nimport { \n  DownloadManagementService, \n  DownloadConfig, \n  CustomerDownload, \n  DownloadRequest, \n  DownloadLink, \n  DownloadStatistics,\n  DEFAULT_DOWNLOAD_CONFIG \n} from './download-management';\n\n/**\n * User cache manager for optimized data access\n */\nclass UserCacheManager {\n  private readonly cache: CacheManager;\n  private readonly config: UserSyncConfig;\n\n  constructor(cache: CacheManager, config: UserSyncConfig) {\n    this.cache = cache;\n    this.config = config;\n  }\n\n  /**\n   * Get cached user profile\n   */\n  async getUserProfile(userId: number): Promise<Result<UserProfile | null, WooError>> {\n    if (!this.config.cacheUserData) {\n      return Ok(null);\n    }\n\n    try {\n      const cacheKey = `user-profile:${userId}`;\n      const cached = await this.cache.get<UserProfile>(cacheKey);\n      return Ok(cached.success ? cached.data : null);\n    } catch (error) {\n      return Err(ErrorFactory.cacheError(\n        'Failed to get cached user profile',\n        error\n      ));\n    }\n  }\n\n  /**\n   * Cache user profile\n   */\n  async cacheUserProfile(profile: UserProfile): Promise<Result<void, WooError>> {\n    if (!this.config.cacheUserData) {\n      return Ok(undefined);\n    }\n\n    try {\n      const cacheKey = `user-profile:${profile.id}`;\n      await this.cache.set(cacheKey, profile, this.config.cacheTtl);\n      return Ok(undefined);\n    } catch (error) {\n      return Err(ErrorFactory.cacheError(\n        'Failed to cache user profile',\n        error\n      ));\n    }\n  }\n\n  /**\n   * Clear user cache\n   */\n  async clearUserCache(userId: number): Promise<Result<void, WooError>> {\n    try {\n      const keys = [\n        `user-profile:${userId}`,\n        `user-addresses:${userId}`,\n        `user-preferences:${userId}`,\n        `user-orders:${userId}`,\n        `user-wishlist:${userId}`\n      ];\n\n      for (const key of keys) {\n        await this.cache.delete(key);\n      }\n\n      return Ok(undefined);\n    } catch (error) {\n      return Err(ErrorFactory.cacheError(\n        'Failed to clear user cache',\n        error\n      ));\n    }\n  }\n}\n\n/**\n * Address validation service\n */\nclass AddressValidator {\n  /**\n   * Validate user address\n   */\n  static validateAddress(address: UserAddress): AddressValidationResult {\n    const errors: string[] = [];\n    const warnings: string[] = [];\n\n    // Required field validation\n    if (!address.firstName.trim()) {\n      errors.push('First name is required');\n    }\n    if (!address.lastName.trim()) {\n      errors.push('Last name is required');\n    }\n    if (!address.address1.trim()) {\n      errors.push('Address line 1 is required');\n    }\n    if (!address.city.trim()) {\n      errors.push('City is required');\n    }\n    if (!address.state.trim()) {\n      errors.push('State/Province is required');\n    }\n    if (!address.postcode.trim()) {\n      errors.push('Postal code is required');\n    }\n    if (!address.country.trim() || address.country.length !== 2) {\n      errors.push('Valid country code is required');\n    }\n\n    // Email validation if provided\n    if (address.email && !this.isValidEmail(address.email)) {\n      errors.push('Invalid email format');\n    }\n\n    // Phone validation if provided\n    if (address.phone && !this.isValidPhone(address.phone)) {\n      warnings.push('Phone number format may be invalid');\n    }\n\n    // Postal code format warnings\n    if (!this.isValidPostalCode(address.postcode, address.country)) {\n      warnings.push('Postal code format may be invalid for the selected country');\n    }\n\n    const result: AddressValidationResult = {\n      isValid: errors.length === 0,\n      errors,\n      warnings\n    };\n    \n    // Only add suggestedAddress if we have one\n    // TODO: Implement address suggestion service\n    \n    return result;\n  }\n\n  private static isValidEmail(email: string): boolean {\n    const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n    return emailRegex.test(email);\n  }\n\n  private static isValidPhone(phone: string): boolean {\n    // Basic phone validation - can be enhanced with more specific patterns\n    const phoneRegex = /^[\\+]?[1-9][\\d]{0,15}$/;\n    return phoneRegex.test(phone.replace(/[\\s\\-\\(\\)]/g, ''));\n  }\n\n  private static isValidPostalCode(postcode: string, country: string): boolean {\n    // Basic postal code validation - can be enhanced with country-specific patterns\n    const patterns: Record<string, RegExp> = {\n      'US': /^\\d{5}(-\\d{4})?$/,\n      'CA': /^[A-Za-z]\\d[A-Za-z][ -]?\\d[A-Za-z]\\d$/,\n      'GB': /^[A-Z]{1,2}\\d[A-Z\\d]? ?\\d[A-Z]{2}$/,\n      'DE': /^\\d{5}$/,\n      'FR': /^\\d{5}$/,\n      'AU': /^\\d{4}$/\n    };\n\n    const pattern = patterns[country.toUpperCase()];\n    return pattern ? pattern.test(postcode) : true; // Default to valid for unknown countries\n  }\n}\n\n/**\n * Main User Service class\n */\nexport class UserService {\n  private readonly client: HttpClient;\n  private readonly cache: CacheManager;\n  private readonly config: UserSyncConfig;\n  private readonly userCache: UserCacheManager;\n  private readonly emailVerification: EmailVerificationService;\n  private readonly downloads: DownloadManagementService;\n  private currentAuthContext: UserAuthContext | null = null;\n\n  constructor(\n    client: HttpClient,\n    cache: CacheManager,\n    config: UserSyncConfig,\n    emailVerificationConfig?: EmailVerificationConfig,\n    downloadConfig?: DownloadConfig\n  ) {\n    this.client = client;\n    this.cache = cache;\n    this.config = config;\n    this.userCache = new UserCacheManager(cache, config);\n    this.emailVerification = new EmailVerificationService(\n      client,\n      cache,\n      emailVerificationConfig || DEFAULT_EMAIL_VERIFICATION_CONFIG\n    );\n    this.downloads = new DownloadManagementService(\n      client,\n      cache,\n      downloadConfig || DEFAULT_DOWNLOAD_CONFIG\n    );\n  }\n\n  /**\n   * Set authentication context from external auth system\n   */\n  setAuthContext(authContext: UserAuthContext): Result<void, WooError> {\n    try {\n      // Validate the auth context\n      if (!isUserAuthContext(authContext)) {\n        return Err(ErrorFactory.validationError(\n          'Invalid authentication context',\n          'AuthContext must contain valid user information'\n        ));\n      }\n\n      this.currentAuthContext = authContext;\n\n      // Trigger sync if enabled and configured\n      if (this.config.enabled && this.config.syncOnLogin) {\n        // Don't await - let sync happen in background\n        const syncRequest: UserSyncRequest = {\n          userId: authContext.userId\n        };\n        if (authContext.externalUserId) {\n          (syncRequest as any).externalUserId = authContext.externalUserId;\n        }\n        this.syncUserData(syncRequest).catch(error => {\n          console.warn('Background user sync failed:', error);\n        });\n      }\n\n      return Ok(undefined);\n    } catch (error) {\n      return Err(ErrorFactory.apiError(\n        'Failed to set authentication context',\n        500,\n        error\n      ));\n    }\n  }\n\n  /**\n   * Get current authenticated user context\n   */\n  getCurrentAuthContext(): UserAuthContext | null {\n    return this.currentAuthContext;\n  }\n\n  /**\n   * Clear authentication context\n   */\n  clearAuthContext(): Result<void, WooError> {\n    try {\n      if (this.currentAuthContext) {\n        // Clear user cache when logging out\n        this.userCache.clearUserCache(this.currentAuthContext.userId);\n      }\n      this.currentAuthContext = null;\n      return Ok(undefined);\n    } catch (error) {\n      return Err(ErrorFactory.apiError(\n        'Failed to clear authentication context',\n        500,\n        error\n      ));\n    }\n  }\n\n  /**\n   * Sync user data with WordPress/WooCommerce\n   */\n  async syncUserData(request: UserSyncRequest): Promise<Result<UserSyncResponse, WooError>> {\n    try {\n      // Validate request\n      const validationResult = this.validateSyncRequest(request);\n      if (!validationResult.success) {\n        return validationResult;\n      }\n\n      if (!this.config.enabled) {\n        return Err(ErrorFactory.configurationError(\n          'User sync is disabled',\n          'Enable user sync in configuration to use this feature'\n        ));\n      }\n\n      // Build response object with collected data\n      const syncErrors: string[] = [];\n      let profile: UserProfile | undefined;\n      let customerData: CustomerData | undefined;\n      let addresses: readonly UserAddress[] | undefined;\n      let preferences: UserPreferences | undefined;\n      let orderHistory: readonly UserOrderSummary[] | undefined;\n      let wishlist: UserWishlist | undefined;\n\n      // Sync profile data\n      if (request.syncProfile !== false && this.config.syncProfile) {\n        const profileResult = await this.syncUserProfile(request.userId);\n        if (profileResult.success) {\n          profile = profileResult.data.profile;\n          customerData = profileResult.data.customerData;\n        } else {\n          syncErrors.push(`Profile sync failed: ${profileResult.error.message}`);\n        }\n      }\n\n      // Sync addresses\n      if (request.syncAddresses !== false && this.config.syncAddresses) {\n        const addressResult = await this.syncUserAddresses(request.userId);\n        if (addressResult.success) {\n          addresses = addressResult.data;\n        } else {\n          syncErrors.push(`Address sync failed: ${addressResult.error.message}`);\n        }\n      }\n\n      // Sync preferences\n      if (request.syncPreferences !== false && this.config.syncPreferences) {\n        const prefResult = await this.syncUserPreferences(request.userId);\n        if (prefResult.success) {\n          preferences = prefResult.data;\n        } else {\n          syncErrors.push(`Preferences sync failed: ${prefResult.error.message}`);\n        }\n      }\n\n      // Sync order history\n      if (request.syncOrderHistory !== false && this.config.syncOrderHistory) {\n        const orderResult = await this.syncUserOrderHistory(request.userId);\n        if (orderResult.success) {\n          orderHistory = orderResult.data;\n        } else {\n          syncErrors.push(`Order history sync failed: ${orderResult.error.message}`);\n        }\n      }\n\n      // Sync wishlist\n      if (request.syncWishlist !== false && this.config.syncWishlist) {\n        const wishlistResult = await this.syncUserWishlist(request.userId);\n        if (wishlistResult.success) {\n          wishlist = wishlistResult.data;\n        } else {\n          syncErrors.push(`Wishlist sync failed: ${wishlistResult.error.message}`);\n        }\n      }\n\n      // Construct final response\n      const response: UserSyncResponse = {\n        userId: request.userId,\n        syncedAt: new Date().toISOString(),\n        profile,\n        customerData,\n        addresses,\n        preferences,\n        orderHistory,\n        wishlist,\n        syncErrors: syncErrors.length > 0 ? syncErrors : undefined\n      };\n\n      return Ok(response);\n\n    } catch (error) {\n      return Err(ErrorFactory.apiError(\n        'User data sync failed',\n        500,\n        error\n      ));\n    }\n  }\n\n  /**\n   * Get user profile by ID\n   */\n  async getUserProfile(userId: number, useCache: boolean = true): Promise<Result<UserProfile, WooError>> {\n    try {\n      // Check cache first\n      if (useCache) {\n        const cachedResult = await this.userCache.getUserProfile(userId);\n        if (cachedResult.success && cachedResult.data) {\n          return Ok(cachedResult.data);\n        }\n      }\n\n      // Fetch from WordPress API\n      const response = await this.client.get<any>(`/wp/v2/users/${userId}`);\n      if (!response.success) {\n        return response;\n      }\n\n      const userData = response.data.data;\n      \n      // Transform WordPress user data to our UserProfile format\n      const profile: UserProfile = {\n        id: userData.id,\n        wordpressUserId: userData.id,\n        username: userData.username || userData.slug,\n        email: userData.email,\n        firstName: userData.first_name || '',\n        lastName: userData.last_name || '',\n        displayName: userData.display_name || userData.name,\n        avatar: userData.avatar_urls?.['96'] || undefined,\n        bio: userData.description || undefined,\n        website: userData.url || undefined,\n        roles: userData.roles || ['customer'],\n        status: 'active', // Default status\n        dateRegistered: userData.date || new Date().toISOString(),\n        lastLogin: undefined, // Not available in standard WP API\n        isEmailVerified: true, // Assume verified if user exists\n        isPhoneVerified: false // Default to false\n      };\n\n      // Cache the profile\n      await this.userCache.cacheUserProfile(profile);\n\n      return Ok(profile);\n\n    } catch (error) {\n      return Err(ErrorFactory.apiError(\n        'Failed to get user profile',\n        500,\n        error\n      ));\n    }\n  }\n\n  /**\n   * Update user profile\n   */\n  async updateUserProfile(userId: number, updates: UserUpdateRequest): Promise<Result<UserProfile, WooError>> {\n    try {\n      const updateData: any = {};\n\n      if (updates.profile) {\n        if (updates.profile.firstName) updateData.first_name = updates.profile.firstName;\n        if (updates.profile.lastName) updateData.last_name = updates.profile.lastName;\n        if (updates.profile.displayName) updateData.display_name = updates.profile.displayName;\n        if (updates.profile.bio) updateData.description = updates.profile.bio;\n        if (updates.profile.website) updateData.url = updates.profile.website;\n      }\n\n      const response = await this.client.post<any>(`/wp/v2/users/${userId}`, updateData);\n      if (!response.success) {\n        return response;\n      }\n\n      // Clear cache and fetch updated profile\n      await this.userCache.clearUserCache(userId);\n      return this.getUserProfile(userId, false);\n\n    } catch (error) {\n      return Err(ErrorFactory.apiError(\n        'Failed to update user profile',\n        500,\n        error\n      ));\n    }\n  }\n\n  /**\n   * Get customer data from WooCommerce\n   */\n  async getCustomerData(customerId: number): Promise<Result<CustomerData, WooError>> {\n    try {\n      const response = await this.client.get<any>(`/customers/${customerId}`);\n      if (!response.success) {\n        return response;\n      }\n\n      const customerData = response.data.data;\n      \n      // Transform WooCommerce customer data\n      const customer: CustomerData = {\n        id: customerData.id,\n        email: customerData.email,\n        firstName: customerData.first_name,\n        lastName: customerData.last_name,\n        username: customerData.username,\n        role: customerData.role || 'customer',\n        billing: this.transformWooAddressToUserAddress(customerData.billing, 'billing'),\n        shipping: this.transformWooAddressToUserAddress(customerData.shipping, 'shipping'),\n        isPayingCustomer: customerData.is_paying_customer || false,\n        ordersCount: customerData.orders_count || 0,\n        totalSpent: customerData.total_spent || '0',\n        avatarUrl: customerData.avatar_url || '',\n        dateCreated: customerData.date_created,\n        dateModified: customerData.date_modified,\n        metaData: customerData.meta_data || []\n      };\n\n      return Ok(customer);\n\n    } catch (error) {\n      return Err(ErrorFactory.apiError(\n        'Failed to get customer data',\n        500,\n        error\n      ));\n    }\n  }\n\n  /**\n   * Validate address\n   */\n  validateAddress(address: UserAddress): AddressValidationResult {\n    return AddressValidator.validateAddress(address);\n  }\n\n  // Email Verification Methods\n\n  /**\n   * Send email verification\n   */\n  async sendEmailVerification(request: EmailVerificationRequest): Promise<Result<EmailVerificationResponse, WooError>> {\n    return this.emailVerification.sendVerification(request);\n  }\n\n  /**\n   * Confirm email verification\n   */\n  async confirmEmailVerification(request: EmailVerificationConfirmRequest): Promise<Result<EmailVerificationConfirmResponse, WooError>> {\n    return this.emailVerification.confirmVerification(request);\n  }\n\n  /**\n   * Get email verification status\n   */\n  async getEmailVerificationStatus(userId: number): Promise<Result<EmailVerificationStatus, WooError>> {\n    return this.emailVerification.getVerificationStatus(userId);\n  }\n\n  /**\n   * Resend email verification\n   */\n  async resendEmailVerification(userId: number): Promise<Result<EmailVerificationResponse, WooError>> {\n    return this.emailVerification.resendVerification(userId);\n  }\n\n  /**\n   * Check if email verification is required for a specific action\n   */\n  isEmailVerificationRequired(action: 'purchase' | 'profile_update' | 'password_change'): boolean {\n    return this.emailVerification.isVerificationRequired(action);\n  }\n\n  // Download Management Methods\n\n  /**\n   * Get customer's downloadable products\n   */\n  async getCustomerDownloads(customerId: number): Promise<Result<CustomerDownload[], WooError>> {\n    return this.downloads.getCustomerDownloads(customerId);\n  }\n\n  /**\n   * Generate secure download link\n   */\n  async generateDownloadLink(request: DownloadRequest): Promise<Result<DownloadLink, WooError>> {\n    return this.downloads.generateDownloadLink(request);\n  }\n\n  /**\n   * Get download statistics\n   */\n  async getDownloadStatistics(\n    customerId?: number,\n    startDate?: Date,\n    endDate?: Date\n  ): Promise<Result<DownloadStatistics, WooError>> {\n    return this.downloads.getDownloadStatistics(customerId, startDate, endDate);\n  }\n\n  /**\n   * Cleanup expired downloads\n   */\n  async cleanupExpiredDownloads(): Promise<Result<number, WooError>> {\n    return this.downloads.cleanupExpiredDownloads();\n  }\n\n  /**\n   * Get user order history\n   */\n  async getUserOrderHistory(\n    userId: number, \n    page: number = 1, \n    limit: number = 10\n  ): Promise<Result<UserOrderSummary[], WooError>> {\n    try {\n      const response = await this.client.get<any>(\n        `/orders?customer=${userId}&page=${page}&per_page=${Math.min(limit, this.config.maxOrderHistory)}`\n      );\n      \n      if (!response.success) {\n        return response;\n      }\n\n      const orders = response.data.data.map((order: any): UserOrderSummary => ({\n        id: order.id,\n        orderNumber: order.number,\n        status: order.status,\n        currency: order.currency,\n        total: order.total,\n        totalTax: order.total_tax,\n        subtotal: order.subtotal,\n        shippingTotal: order.shipping_total,\n        dateCreated: order.date_created,\n        dateModified: order.date_modified,\n        itemCount: order.line_items?.length || 0,\n        paymentMethod: order.payment_method,\n        paymentMethodTitle: order.payment_method_title\n      }));\n\n      return Ok(orders);\n\n    } catch (error) {\n      return Err(ErrorFactory.apiError(\n        'Failed to get user order history',\n        500,\n        error\n      ));\n    }\n  }\n\n  /**\n   * Log user activity\n   */\n  async logUserActivity(activity: Omit<UserActivity, 'id' | 'timestamp'>): Promise<Result<void, WooError>> {\n    try {\n      const activityEntry: UserActivity = {\n        ...activity,\n        id: generateId(),\n        timestamp: new Date().toISOString()\n      };\n\n      // Store activity in cache for now (could be enhanced to store in database)\n      const cacheKey = `user-activity:${activity.userId}:${activityEntry.id}`;\n      await this.cache.set(cacheKey, activityEntry, 86400000); // 24 hours\n\n      return Ok(undefined);\n    } catch (error) {\n      return Err(ErrorFactory.cacheError(\n        'Failed to log user activity',\n        error\n      ));\n    }\n  }\n\n  // Private helper methods\n\n  private validateSyncRequest(request: UserSyncRequest): Result<void, WooError> {\n    try {\n      UserSyncRequestSchema.parse(request);\n      return Ok(undefined);\n    } catch (error) {\n      return Err(ErrorFactory.validationError(\n        'Invalid sync request',\n        error\n      ));\n    }\n  }\n\n  private async syncUserProfile(userId: number): Promise<Result<{ profile: UserProfile; customerData?: CustomerData }, WooError>> {\n    const profileResult = await this.getUserProfile(userId, false);\n    if (!profileResult.success) {\n      return profileResult;\n    }\n\n    const profile = profileResult.data;\n    \n    // Try to get WooCommerce customer data\n    let customerData: CustomerData | undefined;\n    const customerResult = await this.getCustomerData(userId);\n    if (customerResult.success) {\n      customerData = customerResult.data;\n    }\n\n    return Ok({ profile, customerData });\n  }\n\n  private async syncUserAddresses(userId: number): Promise<Result<UserAddress[], WooError>> {\n    // This would typically fetch addresses from WooCommerce customer data\n    const customerResult = await this.getCustomerData(userId);\n    if (!customerResult.success) {\n      return customerResult;\n    }\n\n    const addresses: UserAddress[] = [];\n    const customer = customerResult.data;\n\n    if (customer.billing) {\n      addresses.push(customer.billing);\n    }\n    if (customer.shipping) {\n      addresses.push(customer.shipping);\n    }\n\n    return Ok(addresses);\n  }\n\n  private async syncUserPreferences(userId: number): Promise<Result<UserPreferences, WooError>> {\n    // Default preferences - could be enhanced to fetch from user meta\n    const preferences: UserPreferences = {\n      language: 'en',\n      currency: 'USD',\n      timezone: 'UTC',\n      dateFormat: 'YYYY-MM-DD',\n      timeFormat: '24h',\n      emailNotifications: {\n        orderUpdates: true,\n        promotions: false,\n        newsletter: false,\n        wishlistReminders: true,\n        backInStock: true,\n        priceDrops: false\n      },\n      privacy: {\n        profileVisibility: 'private',\n        showPurchaseHistory: false,\n        allowRecommendations: true,\n        dataSharing: false\n      }\n    };\n\n    return Ok(preferences);\n  }\n\n  private async syncUserOrderHistory(userId: number): Promise<Result<UserOrderSummary[], WooError>> {\n    return this.getUserOrderHistory(userId, 1, this.config.maxOrderHistory);\n  }\n\n  private async syncUserWishlist(userId: number): Promise<Result<UserWishlist, WooError>> {\n    // Placeholder implementation - would need a wishlist plugin or custom implementation\n    const wishlist: UserWishlist = {\n      id: `wishlist-${userId}`,\n      userId,\n      name: 'My Wishlist',\n      items: [],\n      isPublic: false,\n      dateCreated: new Date().toISOString(),\n      dateModified: new Date().toISOString()\n    };\n\n    return Ok(wishlist);\n  }\n\n  private transformWooAddressToUserAddress(wooAddress: any, type: 'billing' | 'shipping'): UserAddress {\n    return {\n      type,\n      firstName: wooAddress.first_name || '',\n      lastName: wooAddress.last_name || '',\n      company: wooAddress.company || undefined,\n      address1: wooAddress.address_1 || '',\n      address2: wooAddress.address_2 || undefined,\n      city: wooAddress.city || '',\n      state: wooAddress.state || '',\n      postcode: wooAddress.postcode || '',\n      country: wooAddress.country || '',\n      phone: wooAddress.phone || undefined,\n      email: wooAddress.email || undefined,\n      isDefault: true\n    };\n  }\n}\n\n// Export download management types and service\nexport type { \n  DigitalProduct, \n  DownloadableFile, \n  DownloadLink, \n  DownloadPermission, \n  CustomerDownload, \n  DownloadAnalytics, \n  DownloadRequest, \n  DownloadValidationResult, \n  DownloadStatistics, \n  DownloadConfig, \n  FileStream \n} from './download-management';\n\nexport { DownloadManagementService, DEFAULT_DOWNLOAD_CONFIG } from './download-management'; ","/**\n * Review and Rating management module for WooCommerce Headless SDK\n * Following the enhanced unified-10x-dev framework\n */\n\nimport { HttpClient } from '../../core/client';\nimport { CacheManager } from '../../core/cache';\nimport { Result, Ok, Err } from '../../types/result';\nimport { WooError, ErrorFactory } from '../../types/errors';\nimport { \n  ProductReview,\n  CreateReviewRequest,\n  UpdateReviewRequest,\n  ReviewListParams,\n  ReviewListResponse,\n  ReviewAnalytics,\n  ReviewValidationResult,\n  ReviewVote,\n  ReviewModeration,\n  RatingDistribution,\n  ReviewStatus,\n  ReviewSearchConfig,\n  ReviewFilter,\n  ReviewImage\n} from '../../types/review';\n/**\n * Review validation schema\n */\nconst CreateReviewSchema = {\n  product_id: { min: 1, type: 'number' },\n  review: { min: 10, max: 10000, type: 'string' },\n  reviewer: { min: 1, max: 100, type: 'string' },\n  reviewer_email: { type: 'email' },\n  rating: { min: 1, max: 5, type: 'number' },\n  parent_id: { type: 'number', optional: true },\n  images: { type: 'array', optional: true }\n};\n\n/**\n * Review service class with comprehensive functionality\n */\nexport class ReviewService {\n  private readonly client: HttpClient;\n  private readonly cache: CacheManager;\n  private readonly rateLimitStore = new Map<string, { count: number; resetTime: number }>();\n\n  constructor(client: HttpClient, cache: CacheManager) {\n    this.client = client;\n    this.cache = cache;\n  }\n\n  /**\n   * List reviews with advanced filtering and pagination\n   */\n  async list(params: ReviewListParams = {}): Promise<Result<ReviewListResponse, WooError>> {\n    try {\n      // Validate parameters\n      const validationResult = this.validateListParams(params);\n      if (!validationResult.success) {\n        return validationResult;\n      }\n\n      // Build query parameters\n      const queryParams = this.buildQueryParams(params);\n      const cacheKey = `reviews:list:${JSON.stringify(queryParams)}`;\n\n      // Check cache\n      const cachedResult = await this.cache.get<ReviewListResponse>(cacheKey);\n      if (cachedResult.success && cachedResult.data) {\n        return Ok(cachedResult.data);\n      }\n\n      // Make API request\n      const response = await this.client.get<ProductReview[]>(\n        `/products/reviews?${new URLSearchParams(queryParams as any).toString()}`\n      );\n\n      if (!response.success) {\n        return response;\n      }\n\n      // Extract pagination from headers\n      const totalReviews = parseInt(response.data.headers['x-wp-total'] || '0');\n      const totalPages = parseInt(response.data.headers['x-wp-totalpages'] || '0');\n\n      // Process and validate reviews\n      const reviews = response.data.data;\n      \n      // Calculate rating distribution and average\n      const ratingDistribution = this.calculateRatingDistribution(reviews);\n      const averageRating = ratingDistribution.average;\n\n      const result: ReviewListResponse = {\n        reviews,\n        totalReviews,\n        totalPages,\n        currentPage: params.page || 1,\n        perPage: params.limit || 10,\n        averageRating,\n        ratingDistribution\n      };\n\n      // Cache the result with TTL\n      await this.cache.set(cacheKey, result, 300); // 5 minutes cache\n\n      return Ok(result);\n    } catch (error) {\n      return Err(ErrorFactory.apiError(\n        'Failed to list reviews',\n        500,\n        error\n      ));\n    }\n  }\n\n  /**\n   * Get a single review by ID\n   */\n  async get(reviewId: number): Promise<Result<ProductReview, WooError>> {\n    try {\n      if (!reviewId || reviewId <= 0) {\n        return Err(ErrorFactory.validationError('Invalid review ID'));\n      }\n\n      const cacheKey = `reviews:single:${reviewId}`;\n\n      // Check cache\n      const cachedResult = await this.cache.get<ProductReview>(cacheKey);\n      if (cachedResult.success && cachedResult.data) {\n        return Ok(cachedResult.data);\n      }\n\n      // Make API request\n      const response = await this.client.get<ProductReview>(`/products/reviews/${reviewId}`);\n\n      if (!response.success) {\n        if (response.error.statusCode === 404) {\n          return Err(ErrorFactory.validationError('Review not found'));\n        }\n        return response;\n      }\n\n      const review = response.data.data;\n\n      // Cache the result\n      await this.cache.set(cacheKey, review, 600); // 10 minutes cache\n\n      return Ok(review);\n    } catch (error) {\n      return Err(ErrorFactory.apiError(\n        'Failed to get review',\n        500,\n        error\n      ));\n    }\n  }\n\n  /**\n   * Create a new review with validation and rate limiting\n   */\n  async create(reviewData: CreateReviewRequest): Promise<Result<ProductReview, WooError>> {\n    try {\n      // Validate request data\n      const validation = await this.validateReview(reviewData);\n      if (!validation.isValid) {\n        return Err(ErrorFactory.validationError(\n          'Review validation failed',\n          validation.errors\n        ));\n      }\n\n      // Check rate limiting\n      const rateLimitCheck = await this.checkRateLimit(reviewData.reviewer_email);\n      if (!rateLimitCheck.success) {\n        return rateLimitCheck;\n      }\n\n      // Process images if provided\n      let processedImages: ReviewImage[] = [];\n      if (reviewData.images && reviewData.images.length > 0) {\n        const imageResult = await this.processReviewImages(reviewData.images);\n        if (!imageResult.success) {\n          return imageResult;\n        }\n        processedImages = imageResult.data;\n      }\n\n      // Prepare review payload\n      const reviewPayload = {\n        product_id: reviewData.product_id,\n        review: this.sanitizeContent(reviewData.review),\n        reviewer: this.sanitizeContent(reviewData.reviewer),\n        reviewer_email: reviewData.reviewer_email,\n        rating: reviewData.rating,\n        parent: reviewData.parent_id || 0,\n        status: validation.requiresModeration ? 'hold' : 'approved'\n      };\n\n      // Submit review\n      const response = await this.client.post<ProductReview>('/products/reviews', reviewPayload);\n\n      if (!response.success) {\n        return response;\n      }\n\n      const createdReview = response.data.data;\n\n      // Attach images if any\n      if (processedImages.length > 0) {\n        await this.attachImagesToReview(createdReview.id, processedImages);\n      }\n\n      // Update rate limiting counter\n      this.updateRateLimit(reviewData.reviewer_email);\n\n      // Invalidate related caches\n      await this.invalidateReviewCaches(reviewData.product_id);\n\n      // Log analytics event\n      await this.trackReviewEvent('review_created', {\n        reviewId: createdReview.id,\n        productId: reviewData.product_id,\n        rating: reviewData.rating,\n        hasImages: processedImages.length > 0\n      });\n\n      return Ok(createdReview);\n    } catch (error) {\n      return Err(ErrorFactory.apiError(\n        'Failed to create review',\n        500,\n        error\n      ));\n    }\n  }\n\n  /**\n   * Update an existing review\n   */\n  async update(reviewId: number, updateData: UpdateReviewRequest): Promise<Result<ProductReview, WooError>> {\n    try {\n      if (!reviewId || reviewId <= 0) {\n        return Err(ErrorFactory.validationError('Invalid review ID'));\n      }\n\n      // Get existing review first\n      const existingReview = await this.get(reviewId);\n      if (!existingReview.success) {\n        return existingReview;\n      }\n\n      // Prepare update payload\n      const updatePayload: any = {};\n      \n      if (updateData.review !== undefined) {\n        updatePayload.review = this.sanitizeContent(updateData.review);\n      }\n      \n      if (updateData.rating !== undefined) {\n        if (updateData.rating < 1 || updateData.rating > 5) {\n          return Err(ErrorFactory.validationError('Rating must be between 1 and 5'));\n        }\n        updatePayload.rating = updateData.rating;\n      }\n      \n      if (updateData.status !== undefined) {\n        updatePayload.status = updateData.status;\n      }\n\n      // Update review\n      const response = await this.client.put<ProductReview>(`/products/reviews/${reviewId}`, updatePayload);\n\n      if (!response.success) {\n        return response;\n      }\n\n      const updatedReview = response.data.data;\n\n      // Update images if provided\n      if (updateData.images) {\n        await this.updateReviewImages(reviewId, updateData.images);\n      }\n\n      // Invalidate caches\n      await this.cache.delete(`reviews:single:${reviewId}`);\n      await this.invalidateReviewCaches(existingReview.data.product_id);\n\n      return Ok(updatedReview);\n    } catch (error) {\n      return Err(ErrorFactory.apiError(\n        'Failed to update review',\n        500,\n        error\n      ));\n    }\n  }\n\n  /**\n   * Delete a review\n   */\n  async delete(reviewId: number, force = false): Promise<Result<boolean, WooError>> {\n    try {\n      if (!reviewId || reviewId <= 0) {\n        return Err(ErrorFactory.validationError('Invalid review ID'));\n      }\n\n      // Get review first to get product ID for cache invalidation\n      const existingReview = await this.get(reviewId);\n      if (!existingReview.success) {\n        return existingReview;\n      }\n\n      // Delete review\n      const response = await this.client.delete(`/products/reviews/${reviewId}?force=${force}`);\n\n      if (!response.success) {\n        return response;\n      }\n\n      // Invalidate caches\n      await this.cache.delete(`reviews:single:${reviewId}`);\n      await this.invalidateReviewCaches(existingReview.data.product_id);\n\n      return Ok(true);\n    } catch (error) {\n      return Err(ErrorFactory.apiError(\n        'Failed to delete review',\n        500,\n        error\n      ));\n    }\n  }\n\n  /**\n   * Get reviews for a specific product with analytics\n   */\n  async getProductReviews(productId: number, params: Omit<ReviewListParams, 'product'> = {}): Promise<Result<ReviewListResponse, WooError>> {\n    return this.list({ ...params, product: productId });\n  }\n\n  /**\n   * Get review analytics for a product\n   */\n  async getAnalytics(productId: number, period = '30d'): Promise<Result<ReviewAnalytics, WooError>> {\n    try {\n      if (!productId || productId <= 0) {\n        return Err(ErrorFactory.validationError('Invalid product ID'));\n      }\n\n      const cacheKey = `reviews:analytics:${productId}:${period}`;\n\n      // Check cache\n      const cachedResult = await this.cache.get<ReviewAnalytics>(cacheKey);\n      if (cachedResult.success && cachedResult.data) {\n        return Ok(cachedResult.data);\n      }\n\n      // Get all reviews for the product\n      const reviewsResult = await this.getProductReviews(productId, { limit: 1000 });\n      if (!reviewsResult.success) {\n        return reviewsResult;\n      }\n\n      const reviews = reviewsResult.data.reviews;\n      const ratingDistribution = this.calculateRatingDistribution(reviews);\n\n      // Calculate analytics\n      const verifiedReviews = reviews.filter(r => r.verified);\n      const reviewsWithReplies = reviews.filter(r => r.replies && r.replies.length > 0);\n      const totalHelpfulVotes = reviews.reduce((sum, r) => sum + r.helpful_votes, 0);\n\n      // Get previous period data for trend analysis\n      const previousPeriodData = await this.getPreviousPeriodData(productId, period);\n\n      const analytics: ReviewAnalytics = {\n        productId,\n        totalReviews: reviews.length,\n        averageRating: ratingDistribution.average,\n        ratingDistribution,\n        verifiedPurchaseRatio: reviews.length > 0 ? (verifiedReviews.length / reviews.length) * 100 : 0,\n        responseRate: reviews.length > 0 ? (reviewsWithReplies.length / reviews.length) * 100 : 0,\n        helpfulnessRatio: reviews.length > 0 ? totalHelpfulVotes / reviews.length : 0,\n        recentTrend: {\n          period,\n          averageRating: ratingDistribution.average,\n          reviewCount: reviews.length,\n          ratingChange: previousPeriodData ? ratingDistribution.average - previousPeriodData.averageRating : 0\n        },\n        topKeywords: await this.extractTopKeywords(reviews)\n      };\n\n      // Cache analytics\n      await this.cache.set(cacheKey, analytics, 3600); // 1 hour cache\n\n      return Ok(analytics);\n    } catch (error) {\n      return Err(ErrorFactory.apiError(\n        'Failed to get review analytics',\n        500,\n        error\n      ));\n    }\n  }\n\n  /**\n   * Vote on review helpfulness\n   */\n  async voteHelpful(reviewId: number, voteType: 'helpful' | 'not_helpful', userEmail?: string): Promise<Result<ReviewVote, WooError>> {\n    try {\n      if (!reviewId || reviewId <= 0) {\n        return Err(ErrorFactory.validationError('Invalid review ID'));\n      }\n\n      // Check if user already voted\n      if (userEmail) {\n        const existingVote = await this.getUserVote(reviewId, userEmail);\n        if (existingVote) {\n          return Err(ErrorFactory.validationError('User has already voted on this review'));\n        }\n      }\n\n      // Submit vote\n      const votePayload = {\n        review_id: reviewId,\n        vote_type: voteType,\n        user_email: userEmail,\n        voted_at: new Date().toISOString()\n      };\n\n      const response = await this.client.post<ReviewVote>(`/products/reviews/${reviewId}/vote`, votePayload);\n\n      if (!response.success) {\n        return response;\n      }\n\n      // Invalidate review cache\n      await this.cache.delete(`reviews:single:${reviewId}`);\n\n      return Ok(response.data.data);\n    } catch (error) {\n      return Err(ErrorFactory.apiError(\n        'Failed to vote on review',\n        500,\n        error\n      ));\n    }\n  }\n\n  /**\n   * Moderate a review (approve, hold, spam, trash)\n   */\n  async moderate(reviewId: number, action: ReviewStatus, reason?: string): Promise<Result<ReviewModeration, WooError>> {\n    try {\n      if (!reviewId || reviewId <= 0) {\n        return Err(ErrorFactory.validationError('Invalid review ID'));\n      }\n\n      const validActions: ReviewStatus[] = ['approved', 'hold', 'spam', 'trash'];\n      if (!validActions.includes(action)) {\n        return Err(ErrorFactory.validationError('Invalid moderation action'));\n      }\n\n      // Update review status\n      const updateResult = await this.update(reviewId, { status: action });\n      if (!updateResult.success) {\n        return updateResult;\n      }\n\n      // Log moderation action\n      const moderation: ReviewModeration = {\n        review_id: reviewId,\n        action,\n        reason,\n        moderated_at: new Date().toISOString(),\n        automated: false\n      };\n\n      // Track moderation event\n      await this.trackReviewEvent('review_moderated', {\n        reviewId,\n        action,\n        reason\n      });\n\n      return Ok(moderation);\n    } catch (error) {\n      return Err(ErrorFactory.apiError(\n        'Failed to moderate review',\n        500,\n        error\n      ));\n    }\n  }\n\n  /**\n   * Search reviews with advanced filtering\n   */\n  async search(config: ReviewSearchConfig): Promise<Result<ReviewListResponse, WooError>> {\n    try {\n      // Convert search config to list params\n      const params: ReviewListParams = {\n        page: config.pagination.page,\n        limit: config.pagination.limit,\n        search: config.query\n      };\n\n      // Apply filters\n      if (config.filters) {\n        for (const filter of config.filters) {\n          this.applyFilterToParams(params, filter);\n        }\n      }\n\n      // Apply sorting\n      if (config.sort && config.sort.length > 0) {\n        const primarySort = config.sort[0];\n        params.orderby = primarySort.field as any;\n        params.order = primarySort.direction;\n      }\n\n      return this.list(params);\n    } catch (error) {\n      return Err(ErrorFactory.apiError(\n        'Failed to search reviews',\n        500,\n        error\n      ));\n    }\n  }\n\n  // Private helper methods\n\n  private validateListParams(params: ReviewListParams): Result<void, WooError> {\n    if (params.page && params.page < 1) {\n      return Err(ErrorFactory.validationError('Page must be >= 1'));\n    }\n    \n    if (params.limit && (params.limit < 1 || params.limit > 100)) {\n      return Err(ErrorFactory.validationError('Limit must be between 1 and 100'));\n    }\n    \n    if (params.rating) {\n      const ratings = Array.isArray(params.rating) ? params.rating : [params.rating];\n      for (const rating of ratings) {\n        if (rating < 1 || rating > 5) {\n          return Err(ErrorFactory.validationError('Rating must be between 1 and 5'));\n        }\n      }\n    }\n\n    return Ok(undefined);\n  }\n\n  private buildQueryParams(params: ReviewListParams): Record<string, string> {\n    const queryParams: Record<string, string> = {};\n\n    if (params.page) queryParams.page = params.page.toString();\n    if (params.limit) queryParams.per_page = params.limit.toString();\n    if (params.product) {\n      queryParams.product = Array.isArray(params.product) \n        ? params.product.join(',') \n        : params.product.toString();\n    }\n    if (params.status) {\n      queryParams.status = Array.isArray(params.status) \n        ? params.status.join(',') \n        : params.status;\n    }\n    if (params.reviewer) queryParams.reviewer = params.reviewer;\n    if (params.reviewer_email) queryParams.reviewer_email = params.reviewer_email;\n    if (params.rating) {\n      queryParams.rating = Array.isArray(params.rating) \n        ? params.rating.join(',') \n        : params.rating.toString();\n    }\n    if (params.verified !== undefined) queryParams.verified = params.verified.toString();\n    if (params.after) queryParams.after = params.after;\n    if (params.before) queryParams.before = params.before;\n    if (params.search) queryParams.search = params.search;\n    if (params.orderby) queryParams.orderby = params.orderby;\n    if (params.order) queryParams.order = params.order;\n    if (params.include) queryParams.include = params.include.join(',');\n    if (params.exclude) queryParams.exclude = params.exclude.join(',');\n    if (params.parent) queryParams.parent = params.parent.toString();\n    if (params.offset) queryParams.offset = params.offset.toString();\n\n    return queryParams;\n  }\n\n  private calculateRatingDistribution(reviews: readonly ProductReview[]): RatingDistribution {\n    const distribution = { 1: 0, 2: 0, 3: 0, 4: 0, 5: 0 };\n    \n    for (const review of reviews) {\n      const rating = Math.floor(review.rating) as 1 | 2 | 3 | 4 | 5;\n      if (rating >= 1 && rating <= 5) {\n        distribution[rating]++;\n      }\n    }\n\n    const total = reviews.length;\n    const average = total > 0 \n      ? reviews.reduce((sum, r) => sum + r.rating, 0) / total \n      : 0;\n\n    const percentage = {\n      1: total > 0 ? (distribution[1] / total) * 100 : 0,\n      2: total > 0 ? (distribution[2] / total) * 100 : 0,\n      3: total > 0 ? (distribution[3] / total) * 100 : 0,\n      4: total > 0 ? (distribution[4] / total) * 100 : 0,\n      5: total > 0 ? (distribution[5] / total) * 100 : 0\n    };\n\n    return {\n      ...distribution,\n      total,\n      average: Math.round(average * 100) / 100,\n      percentage\n    };\n  }\n\n  private async validateReview(reviewData: CreateReviewRequest): Promise<ReviewValidationResult> {\n    const errors: string[] = [];\n    const warnings: string[] = [];\n\n    try {\n      // Schema validation\n      CreateReviewSchema.parse(reviewData);\n    } catch (error) {\n      if (error instanceof z.ZodError) {\n        errors.push(...error.errors.map(e => e.message));\n      }\n    }\n\n    // Content validation\n    const spamScore = await this.calculateSpamScore(reviewData.review);\n    const requiresModeration = spamScore > 70 || this.containsProfanity(reviewData.review);\n\n    if (spamScore > 90) {\n      errors.push('Review appears to be spam');\n    } else if (spamScore > 70) {\n      warnings.push('Review may require manual moderation');\n    }\n\n    return {\n      isValid: errors.length === 0,\n      errors,\n      warnings,\n      canSubmit: errors.length === 0,\n      requiresModeration,\n      spamScore\n    };\n  }\n\n  private async checkRateLimit(userEmail: string): Promise<Result<void, WooError>> {\n    const now = Date.now();\n    const userKey = userEmail.toLowerCase();\n    const userLimit = this.rateLimitStore.get(userKey);\n\n    // Default rate limits\n    const maxPerHour = 5;\n    const hourInMs = 60 * 60 * 1000;\n\n    if (userLimit) {\n      if (now < userLimit.resetTime) {\n        if (userLimit.count >= maxPerHour) {\n          return Err(ErrorFactory.rateLimitError(\n            'Too many reviews submitted. Please wait before submitting another review.',\n            Math.ceil((userLimit.resetTime - now) / 1000)\n          ));\n        }\n      } else {\n        // Reset counter\n        this.rateLimitStore.set(userKey, { count: 0, resetTime: now + hourInMs });\n      }\n    } else {\n      // First time user\n      this.rateLimitStore.set(userKey, { count: 0, resetTime: now + hourInMs });\n    }\n\n    return Ok(undefined);\n  }\n\n  private updateRateLimit(userEmail: string): void {\n    const userKey = userEmail.toLowerCase();\n    const userLimit = this.rateLimitStore.get(userKey);\n    \n    if (userLimit) {\n      userLimit.count++;\n      this.rateLimitStore.set(userKey, userLimit);\n    }\n  }\n\n  private sanitizeContent(content: string): string {\n    // Basic HTML sanitization - in production, use a proper sanitization library\n    return content\n      .replace(/<script\\b[^<]*(?:(?!<\\/script>)<[^<]*)*<\\/script>/gi, '')\n      .replace(/<iframe\\b[^<]*(?:(?!<\\/iframe>)<[^<]*)*<\\/iframe>/gi, '')\n      .trim();\n  }\n\n  private async calculateSpamScore(content: string): Promise<number> {\n    // Simple spam detection - in production, use more sophisticated methods\n    let score = 0;\n    \n    // Check for excessive caps\n    const capsRatio = (content.match(/[A-Z]/g) || []).length / content.length;\n    if (capsRatio > 0.5) score += 30;\n    \n    // Check for excessive punctuation\n    const punctuationRatio = (content.match(/[!?]{2,}/g) || []).length;\n    if (punctuationRatio > 2) score += 25;\n    \n    // Check for suspicious patterns\n    const suspiciousPatterns = [\n      /click here/gi,\n      /free offer/gi,\n      /limited time/gi,\n      /act now/gi\n    ];\n    \n    for (const pattern of suspiciousPatterns) {\n      if (pattern.test(content)) score += 20;\n    }\n    \n    return Math.min(score, 100);\n  }\n\n  private containsProfanity(content: string): boolean {\n    // Basic profanity filter - in production, use a comprehensive profanity filter\n    const profanityWords = ['spam', 'fake', 'scam']; // Minimal list for example\n    const lowerContent = content.toLowerCase();\n    \n    return profanityWords.some(word => lowerContent.includes(word));\n  }\n\n  private async processReviewImages(images: readonly (File | string)[]): Promise<Result<ReviewImage[], WooError>> {\n    // Image processing implementation would go here\n    // For now, return empty array\n    return Ok([]);\n  }\n\n  private async attachImagesToReview(reviewId: number, images: ReviewImage[]): Promise<void> {\n    // Implementation for attaching images to review\n  }\n\n  private async updateReviewImages(reviewId: number, images: ReviewImage[]): Promise<void> {\n    // Implementation for updating review images\n  }\n\n  private async invalidateReviewCaches(productId: number): Promise<void> {\n    // Invalidate all review-related caches for a product\n    const cacheKeys = [\n      `reviews:list:*${productId}*`,\n      `reviews:analytics:${productId}*`\n    ];\n    \n    for (const pattern of cacheKeys) {\n      await this.cache.deletePattern(pattern);\n    }\n  }\n\n  private async trackReviewEvent(event: string, data: any): Promise<void> {\n    // Analytics tracking implementation\n    console.log(`Review event: ${event}`, data);\n  }\n\n  private async getUserVote(reviewId: number, userEmail: string): Promise<ReviewVote | null> {\n    // Check if user has already voted - implementation would query database\n    return null;\n  }\n\n  private async getPreviousPeriodData(productId: number, period: string): Promise<{ averageRating: number } | null> {\n    // Get previous period data for trend analysis\n    return null;\n  }\n\n  private async extractTopKeywords(reviews: readonly ProductReview[]): Promise<Array<{keyword: string; count: number; sentiment: 'positive' | 'negative' | 'neutral'}>> {\n    // Extract and analyze keywords from reviews\n    // This would use NLP libraries in production\n    return [];\n  }\n\n  private applyFilterToParams(params: ReviewListParams, filter: ReviewFilter): void {\n    // Apply individual filter to params object\n    switch (filter.field) {\n      case 'rating':\n        if (filter.operator === 'eq') {\n          params.rating = filter.value as number;\n        }\n        break;\n      case 'verified':\n        if (filter.operator === 'eq') {\n          params.verified = filter.value as boolean;\n        }\n        break;\n      // Add more filter implementations\n    }\n  }\n} ","/**\n * Checkout System Types for WooCommerce Headless SDK\n * Following the Enhanced Unified 10X Developer Framework\n */\n\nimport { z } from 'zod';\n\n/**\n * Base address interface for billing and shipping\n */\nexport interface BaseAddress {\n  readonly firstName: string;\n  readonly lastName: string;\n  readonly company?: string;\n  readonly address1: string;\n  readonly address2?: string;\n  readonly city: string;\n  readonly state: string;\n  readonly postcode: string;\n  readonly country: string;\n  readonly email?: string;\n  readonly phone?: string;\n}\n\n/**\n * Billing address with required email\n */\nexport interface BillingAddress extends BaseAddress {\n  readonly email: string;\n}\n\n/**\n * Shipping address (email optional)\n */\nexport interface ShippingAddress extends BaseAddress {}\n\n/**\n * Address validation result\n */\nexport interface AddressValidation {\n  readonly isValid: boolean;\n  readonly errors: readonly string[];\n  readonly warnings: readonly string[];\n  readonly suggestedAddress?: BaseAddress;\n}\n\n/**\n * Country configuration for address validation\n */\nexport interface CountryConfig {\n  readonly code: string;\n  readonly name: string;\n  readonly postcodePattern?: string;\n  readonly stateRequired: boolean;\n  readonly postcodeRequired: boolean;\n  readonly phonePattern?: string;\n}\n\n/**\n * Payment method types\n */\nexport type PaymentMethodType = \n  | 'credit_card'\n  | 'stripe'\n  | 'stripe_checkout'\n  | 'paypal' \n  | 'apple_pay'\n  | 'google_pay'\n  | 'bank_transfer'\n  | 'cash_on_delivery'\n  | 'check';\n\n/**\n * Credit card information\n */\nexport interface CreditCard {\n  readonly number: string;\n  readonly expiryMonth: number;\n  readonly expiryYear: number;\n  readonly cvv: string;\n  readonly holderName: string;\n}\n\n/**\n * Payment method configuration\n */\nexport interface PaymentMethod {\n  readonly id: string;\n  readonly type: PaymentMethodType;\n  readonly title: string;\n  readonly description: string;\n  readonly enabled: boolean;\n  readonly testMode: boolean;\n  readonly settings: Record<string, unknown>;\n  readonly supportedCountries?: readonly string[];\n  readonly supportedCurrencies?: readonly string[];\n  readonly minimumAmount?: number;\n  readonly maximumAmount?: number;\n  readonly icon?: string;\n  readonly acceptedCards?: readonly string[];\n}\n\n/**\n * Shipping method types\n */\nexport type ShippingMethodType =\n  | 'flat_rate'\n  | 'free_shipping'\n  | 'local_pickup'\n  | 'table_rate'\n  | 'expedited'\n  | 'overnight';\n\n/**\n * Shipping rate calculation\n */\nexport interface ShippingRate {\n  readonly id: string;\n  readonly method: ShippingMethodType;\n  readonly title: string;\n  readonly description: string;\n  readonly cost: number;\n  readonly taxable: boolean;\n  readonly estimatedDelivery?: string;\n  readonly trackingAvailable: boolean;\n}\n\n/**\n * Shipping zone configuration\n */\nexport interface ShippingZone {\n  readonly id: string;\n  readonly name: string;\n  readonly countries: readonly string[];\n  readonly states: readonly string[];\n  readonly postcodes: readonly string[];\n  readonly methods: readonly ShippingRate[];\n}\n\n/**\n * Shipping method selection\n */\nexport interface SelectedShippingMethod {\n  readonly zoneId: string;\n  readonly methodId: string;\n  readonly rate: ShippingRate;\n  readonly title: string;\n  readonly cost: number;\n}\n\n/**\n * Order status types\n */\nexport type OrderStatus =\n  | 'pending'\n  | 'processing'\n  | 'on_hold'\n  | 'completed'\n  | 'cancelled'\n  | 'refunded'\n  | 'failed'\n  | 'draft';\n\n/**\n * Order totals breakdown\n */\nexport interface OrderTotals {\n  readonly subtotal: number;\n  readonly tax: number;\n  readonly shipping: number;\n  readonly shippingTax: number;\n  readonly discount: number;\n  readonly fees: number;\n  readonly feesTax: number;\n  readonly total: number;\n  readonly currency: string;\n}\n\n/**\n * Order line item\n */\nexport interface OrderLineItem {\n  readonly id: number;\n  readonly productId: number;\n  readonly variationId?: number;\n  readonly name: string;\n  readonly quantity: number;\n  readonly price: number;\n  readonly total: number;\n  readonly subtotal: number;\n  readonly totalTax: number;\n  readonly subtotalTax: number;\n  readonly sku?: string;\n  readonly meta: readonly {\n    readonly key: string;\n    readonly value: string;\n  }[];\n}\n\n/**\n * Complete order information\n */\nexport interface Order {\n  readonly id: number;\n  readonly number: string;\n  readonly status: OrderStatus;\n  readonly currency: string;\n  readonly dateCreated: Date;\n  readonly dateModified: Date;\n  readonly total: number;\n  readonly subtotal: number;\n  readonly totalTax: number;\n  readonly shippingTotal: number;\n  readonly shippingTax: number;\n  readonly discountTotal: number;\n  readonly discountTax: number;\n  readonly feeTotal: number;\n  readonly feeTax: number;\n  readonly customerId: number;\n  readonly customerNote?: string;\n  readonly billingAddress: BillingAddress;\n  readonly shippingAddress: ShippingAddress;\n  readonly paymentMethod: string;\n  readonly paymentMethodTitle: string;\n  readonly shippingMethod: string;\n  readonly shippingMethodTitle: string;\n  readonly lineItems: readonly OrderLineItem[];\n  readonly createdAt: Date;\n  readonly updatedAt: Date;\n  readonly completedAt?: Date;\n}\n\n/**\n * Checkout step types\n */\nexport type CheckoutStepType = \n  | 'address'\n  | 'shipping'\n  | 'payment'\n  | 'review'\n  | 'cart_review'\n  | 'shipping_address'\n  | 'billing_address'\n  | 'shipping_method'\n  | 'payment_method'\n  | 'order_review'\n  | 'payment_processing'\n  | 'order_confirmation';\n\n/**\n * Individual checkout step\n */\nexport interface CheckoutStep {\n  readonly type: CheckoutStepType;\n  readonly title: string;\n  readonly description: string;\n  readonly completed: boolean;\n  readonly valid: boolean;\n  readonly errors: readonly string[];\n  readonly data?: Record<string, unknown>;\n}\n\n/**\n * Checkout flow state\n */\nexport interface CheckoutFlow {\n  readonly steps: readonly CheckoutStep[];\n  readonly currentStep: CheckoutStepType;\n  readonly canProceed: boolean;\n  readonly canGoBack: boolean;\n  readonly progress: {\n    readonly current: number;\n    readonly total: number;\n    readonly percentage: number;\n  };\n}\n\n/**\n * Checkout session state\n */\nexport interface CheckoutSession {\n  readonly id: string;\n  readonly cartId: string;\n  readonly customerId?: number;\n  readonly billingAddress?: BillingAddress;\n  readonly shippingAddress?: ShippingAddress;\n  readonly useShippingAsBilling?: boolean;\n  readonly selectedShippingMethod?: SelectedShippingMethod;\n  readonly selectedPaymentMethod?: PaymentMethod;\n  readonly orderNotes?: string;\n  readonly termsAccepted?: boolean;\n  readonly newsletterOptIn?: boolean;\n  readonly isGuestCheckout?: boolean;\n  readonly orderTotals: OrderTotals;\n  readonly flow: CheckoutFlow;\n  readonly expiresAt: Date;\n  readonly createdAt: Date;\n  readonly updatedAt: Date;\n}\n\n/**\n * Checkout validation rules\n */\nexport interface CheckoutValidationRules {\n  readonly requireShippingAddress: boolean;\n  readonly requireBillingAddress: boolean;\n  readonly requireEmail?: boolean;\n  readonly requirePhoneNumber: boolean;\n  readonly requireCompanyName: boolean;\n  readonly allowGuestCheckout: boolean;\n  readonly minimumOrderAmount?: number;\n  readonly maximumOrderAmount?: number;\n  readonly restrictedCountries: readonly string[];\n  readonly requiredFields: readonly string[];\n  readonly returnUrl?: string;\n  readonly cancelUrl?: string;\n}\n\n/**\n * Checkout configuration\n */\nexport interface CheckoutConfig {\n  readonly enabled: boolean;\n  readonly guestCheckoutEnabled: boolean;\n  readonly termsPageId?: number;\n  readonly privacyPageId?: number;\n  readonly validationRules: CheckoutValidationRules;\n  readonly paymentMethods: readonly PaymentMethod[];\n  readonly shippingZones: readonly ShippingZone[];\n  readonly countries: readonly CountryConfig[];\n  readonly defaultCountry: string;\n  readonly sessionTtl: number; // in minutes\n  readonly autoCalculateTotals: boolean;\n}\n\n/**\n * Checkout form data for step updates\n */\nexport interface CheckoutFormData {\n  readonly step: CheckoutStepType;\n  readonly data: Record<string, unknown>;\n  readonly validate?: boolean;\n}\n\n/**\n * Checkout error types\n */\nexport type CheckoutErrorCode =\n  | 'INVALID_ADDRESS'\n  | 'UNSUPPORTED_COUNTRY'\n  | 'INVALID_POSTCODE'\n  | 'SHIPPING_NOT_AVAILABLE'\n  | 'PAYMENT_METHOD_UNAVAILABLE'\n  | 'INSUFFICIENT_STOCK'\n  | 'MINIMUM_ORDER_NOT_MET'\n  | 'MAXIMUM_ORDER_EXCEEDED'\n  | 'CHECKOUT_SESSION_EXPIRED'\n  | 'PAYMENT_PROCESSING_FAILED'\n  | 'ORDER_CREATION_FAILED'\n  | 'INVALID_CHECKOUT_DATA'\n  | 'TERMS_NOT_ACCEPTED';\n\n/**\n * Checkout specific error\n */\nexport interface CheckoutError {\n  readonly code: CheckoutErrorCode;\n  readonly message: string;\n  readonly field?: string;\n  readonly step?: CheckoutStepType;\n  readonly details?: Record<string, unknown>;\n}\n\n/**\n * Zod validation schemas\n */\nexport const BaseAddressSchema = z.object({\n  firstName: z.string().min(1, 'First name is required').max(100),\n  lastName: z.string().min(1, 'Last name is required').max(100),\n  company: z.string().max(100).optional(),\n  address1: z.string().min(1, 'Address is required').max(200),\n  address2: z.string().max(200).optional(),\n  city: z.string().min(1, 'City is required').max(100),\n  state: z.string().min(1, 'State is required').max(100),\n  postcode: z.string().min(1, 'Postcode is required').max(20),\n  country: z.string().length(2, 'Country must be 2-letter code'),\n  email: z.string().email().optional(),\n  phone: z.string().max(20).optional()\n});\n\nexport const BillingAddressSchema = BaseAddressSchema.extend({\n  email: z.string().email('Valid email is required')\n});\n\nexport const ShippingAddressSchema = BaseAddressSchema;\n\nexport const CreditCardSchema = z.object({\n  number: z.string().regex(/^\\d{13,19}$/, 'Invalid card number'),\n  expiryMonth: z.number().int().min(1).max(12),\n  expiryYear: z.number().int().min(new Date().getFullYear()),\n  cvv: z.string().regex(/^\\d{3,4}$/, 'Invalid CVV'),\n  holderName: z.string().min(1, 'Cardholder name is required').max(100)\n});\n\nexport const OrderTotalsSchema = z.object({\n  subtotal: z.number().min(0),\n  tax: z.number().min(0),\n  shipping: z.number().min(0),\n  shippingTax: z.number().min(0),\n  discount: z.number().min(0),\n  fees: z.number().min(0),\n  feesTax: z.number().min(0),\n  total: z.number().min(0),\n  currency: z.string().length(3)\n});\n\nexport const CheckoutFormDataSchema = z.object({\n  step: z.enum(['cart_review', 'shipping_address', 'billing_address', 'shipping_method', 'payment_method', 'order_review', 'payment_processing', 'order_confirmation']),\n  data: z.record(z.unknown()),\n  validate: z.boolean().optional()\n});\n\n/**\n * Type guards\n */\nexport function isBillingAddress(address: BaseAddress): address is BillingAddress {\n  return 'email' in address && typeof address.email === 'string' && address.email.length > 0;\n}\n\nexport function isValidCheckoutStep(step: string): step is CheckoutStepType {\n  return ['cart_review', 'shipping_address', 'billing_address', 'shipping_method', 'payment_method', 'order_review', 'payment_processing', 'order_confirmation'].includes(step);\n}\n\nexport function isValidPaymentMethod(method: string): method is PaymentMethodType {\n  return ['credit_card', 'stripe', 'stripe_checkout', 'paypal', 'apple_pay', 'google_pay', 'bank_transfer', 'cash_on_delivery', 'check'].includes(method);\n}\n\n/**\n * Validation functions\n */\nexport function validateBaseAddress(address: unknown): BaseAddress {\n  const parsed = BaseAddressSchema.parse(address);\n  // Handle exactOptionalPropertyTypes by removing undefined values\n  const result: BaseAddress = {\n    firstName: parsed.firstName,\n    lastName: parsed.lastName,\n    address1: parsed.address1,\n    city: parsed.city,\n    state: parsed.state,\n    postcode: parsed.postcode,\n    country: parsed.country,\n    ...(parsed.company !== undefined && { company: parsed.company }),\n    ...(parsed.address2 !== undefined && { address2: parsed.address2 }),\n    ...(parsed.email !== undefined && { email: parsed.email }),\n    ...(parsed.phone !== undefined && { phone: parsed.phone })\n  };\n  return result;\n}\n\nexport function validateBillingAddress(address: unknown): BillingAddress {\n  const parsed = BillingAddressSchema.parse(address);\n  // Handle exactOptionalPropertyTypes by removing undefined values\n  const result: BillingAddress = {\n    firstName: parsed.firstName,\n    lastName: parsed.lastName,\n    address1: parsed.address1,\n    city: parsed.city,\n    state: parsed.state,\n    postcode: parsed.postcode,\n    country: parsed.country,\n    email: parsed.email,\n    ...(parsed.company !== undefined && { company: parsed.company }),\n    ...(parsed.address2 !== undefined && { address2: parsed.address2 }),\n    ...(parsed.phone !== undefined && { phone: parsed.phone })\n  };\n  return result;\n}\n\nexport function validateShippingAddress(address: unknown): ShippingAddress {\n  const parsed = ShippingAddressSchema.parse(address);\n  // Handle exactOptionalPropertyTypes by removing undefined values\n  const result: ShippingAddress = {\n    firstName: parsed.firstName,\n    lastName: parsed.lastName,\n    address1: parsed.address1,\n    city: parsed.city,\n    state: parsed.state,\n    postcode: parsed.postcode,\n    country: parsed.country,\n    ...(parsed.company !== undefined && { company: parsed.company }),\n    ...(parsed.address2 !== undefined && { address2: parsed.address2 }),\n    ...(parsed.email !== undefined && { email: parsed.email }),\n    ...(parsed.phone !== undefined && { phone: parsed.phone })\n  };\n  return result;\n}\n\nexport function validateCreditCard(card: unknown): CreditCard {\n  return CreditCardSchema.parse(card);\n}\n\nexport function validateOrderTotals(totals: unknown): OrderTotals {\n  return OrderTotalsSchema.parse(totals);\n}\n\nexport function validateCheckoutFormData(data: unknown): CheckoutFormData {\n  const parsed = CheckoutFormDataSchema.parse(data);\n  // Handle exactOptionalPropertyTypes by removing undefined values\n  const result: CheckoutFormData = {\n    step: parsed.step,\n    data: parsed.data,\n    ...(parsed.validate !== undefined && { validate: parsed.validate })\n  };\n  return result;\n}\n\n/**\n * Helper functions\n */\nexport function createEmptyCheckoutFlow(): CheckoutFlow {\n  const steps: CheckoutStep[] = [\n    {\n      type: 'cart_review',\n      title: 'Review Cart',\n      description: 'Review items in your cart',\n      completed: false,\n      valid: false,\n      errors: []\n    },\n    {\n      type: 'shipping_address',\n      title: 'Shipping Address',\n      description: 'Enter your shipping address',\n      completed: false,\n      valid: false,\n      errors: []\n    },\n    {\n      type: 'billing_address',\n      title: 'Billing Address',\n      description: 'Enter your billing address',\n      completed: false,\n      valid: false,\n      errors: []\n    },\n    {\n      type: 'shipping_method',\n      title: 'Shipping Method',\n      description: 'Choose your shipping method',\n      completed: false,\n      valid: false,\n      errors: []\n    },\n    {\n      type: 'payment_method',\n      title: 'Payment Method',\n      description: 'Choose your payment method',\n      completed: false,\n      valid: false,\n      errors: []\n    },\n    {\n      type: 'order_review',\n      title: 'Review Order',\n      description: 'Review your order before payment',\n      completed: false,\n      valid: false,\n      errors: []\n    }\n  ];\n\n  return {\n    steps,\n    currentStep: 'cart_review',\n    canProceed: false,\n    canGoBack: false,\n    progress: {\n      current: 1,\n      total: steps.length,\n      percentage: Math.round((1 / steps.length) * 100)\n    }\n  };\n}\n\n/**\n * Default configurations\n */\nexport const DEFAULT_CHECKOUT_CONFIG: Partial<CheckoutConfig> = {\n  enabled: true,\n  guestCheckoutEnabled: true,\n  sessionTtl: 60, // 1 hour\n  autoCalculateTotals: true,\n  defaultCountry: 'US',\n  validationRules: {\n    requireShippingAddress: true,\n    requireBillingAddress: true,\n    requirePhoneNumber: false,\n    requireCompanyName: false,\n    allowGuestCheckout: true,\n    restrictedCountries: [],\n    requiredFields: ['firstName', 'lastName', 'address1', 'city', 'state', 'postcode', 'country', 'email']\n  }\n};\n\n/**\n * Payment transaction details\n */\nexport interface PaymentTransaction {\n  readonly id: string;\n  readonly paymentId: string;\n  readonly amount: number;\n  readonly currency: string;\n  readonly status: 'pending' | 'completed' | 'failed' | 'cancelled';\n  readonly method: PaymentMethodType;\n  readonly transactionId?: string;\n  readonly gatewayResponse?: Record<string, unknown>;\n  readonly processedAt?: Date;\n  readonly failureReason?: string;\n}\n\n/**\n * Payment initialization response\n */\nexport interface PaymentInitResponse {\n  readonly paymentId: string;\n  readonly redirectUrl: string | undefined; // Allow undefined explicitly\n  readonly requiresRedirect: boolean;\n  readonly clientSecret: string | undefined; // Allow undefined explicitly\n  readonly paymentIntentId: string | undefined; // Allow undefined explicitly\n  readonly instructions: string | undefined; // Allow undefined explicitly\n  readonly expiresAt: Date | undefined; // Allow undefined explicitly\n}\n\n/**\n * Payment status response\n */\nexport interface PaymentStatusResponse {\n  readonly paymentId: string;\n  readonly status: PaymentStatus;\n  readonly transactionId: string | undefined; // Allow undefined explicitly\n  readonly failureReason: string | undefined; // Allow undefined explicitly\n  readonly redirectUrl: string | undefined; // Allow undefined explicitly\n  readonly nextAction: {\n    readonly type: 'redirect' | 'authenticate' | 'confirm';\n    readonly url?: string;\n    readonly data?: Record<string, unknown>;\n  } | undefined; // Allow undefined explicitly\n}\n\n/**\n * Payment status enumeration\n */\nexport type PaymentStatus = \n  | 'pending'\n  | 'processing' \n  | 'completed'\n  | 'failed'\n  | 'cancelled'\n  | 'refunded'\n  | 'requires_action';\n\n/**\n * Payment request interface\n */\nexport interface PaymentRequest {\n  readonly orderId: string;\n  readonly amount: number;\n  readonly currency: string;\n  readonly paymentMethod: string;\n  readonly returnUrl?: string;\n  readonly metadata?: Record<string, unknown>;\n}\n\n/**\n * Payment initialization request\n */\nexport interface PaymentInitRequest {\n  readonly paymentMethodId: string;\n  readonly orderId: string;\n  readonly amount: number;\n  readonly currency: string;\n  readonly returnUrl: string;\n  readonly cancelUrl: string;\n  readonly metadata?: Record<string, unknown>;\n}\n\n/**\n * Payment status request\n */\nexport interface PaymentStatusRequest {\n  readonly paymentId: string;\n  readonly orderId: string;\n}\n\n/**\n * Payment callback data\n */\nexport interface PaymentCallbackData {\n  readonly paymentId: string;\n  readonly orderId: string;\n  readonly status: string;\n  readonly transactionId?: string;\n  readonly signature?: string;\n  readonly metadata?: Record<string, unknown>;\n}\n\n/**\n * Checkout validation result interface\n */\nexport interface CheckoutValidationResult {\n  readonly isValid: boolean;\n  readonly errors: readonly CheckoutError[];\n  readonly warnings: readonly CheckoutError[];\n}\n","/**\n * Address Management Service for WooCommerce Headless SDK\n * Following the Enhanced Unified 10X Developer Framework\n */\n\nimport { Result, Ok, Err, isErr, unwrap, unwrapErr } from '../../types/result';\nimport { WooError, ErrorFactory } from '../../types/errors';\nimport { \n  BaseAddress, \n  BillingAddress, \n  ShippingAddress,\n  AddressValidation,\n  CountryConfig,\n  CheckoutValidationRules,\n  validateBaseAddress,\n  validateBillingAddress,\n  validateShippingAddress\n} from '../../types/checkout';\n\n/**\n * Dynamic field requirements configuration\n */\nexport interface AddressFieldRequirements {\n  readonly firstName: boolean;\n  readonly lastName: boolean;\n  readonly company: boolean;\n  readonly address1: boolean;\n  readonly address2: boolean;\n  readonly city: boolean;\n  readonly state: boolean;\n  readonly postcode: boolean;\n  readonly country: boolean;\n  readonly email: boolean;\n  readonly phone: boolean;\n}\n\n/**\n * Address validation context\n */\nexport interface AddressValidationContext {\n  readonly fieldRequirements?: Partial<AddressFieldRequirements>;\n  readonly checkoutRules?: CheckoutValidationRules;\n  readonly isGuestCheckout?: boolean;\n  readonly addressType: 'billing' | 'shipping';\n}\n\n/**\n * Country-specific postal code patterns and validation rules\n */\nconst COUNTRY_CONFIGS: Record<string, CountryConfig> = {\n  'US': {\n    code: 'US',\n    name: 'United States',\n    postcodePattern: '^\\\\d{5}(-\\\\d{4})?$',\n    stateRequired: true,\n    postcodeRequired: true,\n    phonePattern: '^\\\\+?1?[-.\\\\s]?\\\\(?\\\\d{3}\\\\)?[-.\\\\s]?\\\\d{3}[-.\\\\s]?\\\\d{4}$'\n  },\n  'CA': {\n    code: 'CA',\n    name: 'Canada',\n    postcodePattern: '^[A-Za-z]\\\\d[A-Za-z]\\\\s?\\\\d[A-Za-z]\\\\d$',\n    stateRequired: true,\n    postcodeRequired: true,\n    phonePattern: '^\\\\+?1?[-.\\\\s]?\\\\(?\\\\d{3}\\\\)?[-.\\\\s]?\\\\d{3}[-.\\\\s]?\\\\d{4}$'\n  },\n  'GB': {\n    code: 'GB',\n    name: 'United Kingdom',\n    postcodePattern: '^[A-Za-z]{1,2}\\\\d[A-Za-z\\\\d]?\\\\s?\\\\d[A-Za-z]{2}$',\n    stateRequired: false,\n    postcodeRequired: true,\n    phonePattern: '^\\\\+?44[-.\\\\s]?\\\\d{4}[-.\\\\s]?\\\\d{6}$'\n  },\n  'DE': {\n    code: 'DE',\n    name: 'Germany',\n    postcodePattern: '^\\\\d{5}$',\n    stateRequired: false,\n    postcodeRequired: true,\n    phonePattern: '^\\\\+?49[-.\\\\s]?\\\\d{3,4}[-.\\\\s]?\\\\d{7,8}$'\n  },\n  'FR': {\n    code: 'FR',\n    name: 'France',\n    postcodePattern: '^\\\\d{5}$',\n    stateRequired: false,\n    postcodeRequired: true,\n    phonePattern: '^\\\\+?33[-.\\\\s]?\\\\d{1}[-.\\\\s]?\\\\d{2}[-.\\\\s]?\\\\d{2}[-.\\\\s]?\\\\d{2}[-.\\\\s]?\\\\d{2}$'\n  },\n  'AU': {\n    code: 'AU',\n    name: 'Australia',\n    postcodePattern: '^\\\\d{4}$',\n    stateRequired: true,\n    postcodeRequired: true,\n    phonePattern: '^\\\\+?61[-.\\\\s]?\\\\d{1}[-.\\\\s]?\\\\d{4}[-.\\\\s]?\\\\d{4}$'\n  },\n  'JP': {\n    code: 'JP',\n    name: 'Japan',\n    postcodePattern: '^\\\\d{3}-\\\\d{4}$',\n    stateRequired: true,\n    postcodeRequired: true,\n    phonePattern: '^\\\\+?81[-.\\\\s]?\\\\d{1,4}[-.\\\\s]?\\\\d{1,4}[-.\\\\s]?\\\\d{4}$'\n  },\n  'BR': {\n    code: 'BR',\n    name: 'Brazil',\n    postcodePattern: '^\\\\d{5}-?\\\\d{3}$',\n    stateRequired: true,\n    postcodeRequired: true,\n    phonePattern: '^\\\\+?55[-.\\\\s]?\\\\d{2}[-.\\\\s]?\\\\d{4,5}[-.\\\\s]?\\\\d{4}$'\n  },\n  'IN': {\n    code: 'IN',\n    name: 'India',\n    postcodePattern: '^\\\\d{6}$',\n    stateRequired: true,\n    postcodeRequired: true,\n    phonePattern: '^\\\\+?91[-.\\\\s]?\\\\d{5}[-.\\\\s]?\\\\d{5}$'\n  },\n  'NL': {\n    code: 'NL',\n    name: 'Netherlands',\n    postcodePattern: '^\\\\d{4}\\\\s?[A-Za-z]{2}$',\n    stateRequired: false,\n    postcodeRequired: true,\n    phonePattern: '^\\\\+?31[-.\\\\s]?\\\\d{1,3}[-.\\\\s]?\\\\d{7}$'\n  }\n};\n\n/**\n * Address management service with dynamic field requirements\n */\nexport class AddressManager {\n  private readonly countryConfigs: Record<string, CountryConfig>;\n\n  constructor(customCountryConfigs?: Record<string, CountryConfig>) {\n    this.countryConfigs = {\n      ...COUNTRY_CONFIGS,\n      ...customCountryConfigs\n    };\n  }\n\n  /**\n   * Validate address with dynamic field requirements\n   */\n  async validateAddressWithContext(\n    address: BaseAddress, \n    context: AddressValidationContext\n  ): Promise<Result<AddressValidation, WooError>> {\n    try {\n      const errors: string[] = [];\n      const warnings: string[] = [];\n\n      // Get country configuration\n      const countryConfig = this.countryConfigs[address.country.toUpperCase()];\n      if (!countryConfig) {\n        errors.push(`Country \"${address.country}\" is not supported`);\n        return Ok({\n          isValid: false,\n          errors,\n          warnings\n        });\n      }\n\n      // Build dynamic field requirements\n      const fieldRequirements = this.buildFieldRequirements(context, countryConfig);\n\n      // Validate fields based on dynamic requirements\n      this.validateRequiredFields(address, fieldRequirements, errors);\n\n      // Validate field formats\n      this.validateFieldFormats(address, countryConfig, errors, warnings);\n\n      return Ok({\n        isValid: errors.length === 0,\n        errors,\n        warnings\n      });\n\n    } catch (error) {\n      return Err(ErrorFactory.validationError(\n        'Address validation failed',\n        error\n      ));\n    }\n  }\n\n  /**\n   * Get field requirements for address type and context\n   */\n  getFieldRequirements(context: AddressValidationContext): AddressFieldRequirements {\n    const countryCode = context.checkoutRules?.requiredFields?.[0] || 'US';\n    const countryConfig = this.countryConfigs[countryCode] || this.countryConfigs['US'] || {\n      code: 'US',\n      name: 'United States',\n      stateRequired: true,\n      postcodeRequired: true\n    };\n    return this.buildFieldRequirements(context, countryConfig);\n  }\n\n  /**\n   * Check if specific field is required\n   */\n  isFieldRequired(\n    fieldName: keyof AddressFieldRequirements, \n    context: AddressValidationContext\n  ): boolean {\n    const requirements = this.getFieldRequirements(context);\n    return requirements[fieldName];\n  }\n\n  /**\n   * Validate a base address with country-specific rules\n   */\n  async validateAddress(address: BaseAddress): Promise<Result<AddressValidation, WooError>> {\n    // Use default context for backward compatibility\n    const context: AddressValidationContext = {\n      addressType: 'shipping',\n      isGuestCheckout: false\n    };\n    return this.validateAddressWithContext(address, context);\n  }\n\n  /**\n   * Validate a billing address (requires email)\n   */\n  async validateBillingAddress(address: BillingAddress): Promise<Result<AddressValidation, WooError>> {\n    const context: AddressValidationContext = {\n      addressType: 'billing',\n      isGuestCheckout: false,\n      fieldRequirements: { email: true }\n    };\n    return this.validateAddressWithContext(address, context);\n  }\n\n  /**\n   * Validate a shipping address\n   */\n  async validateShippingAddress(address: ShippingAddress): Promise<Result<AddressValidation, WooError>> {\n    const context: AddressValidationContext = {\n      addressType: 'shipping',\n      isGuestCheckout: false\n    };\n    return this.validateAddressWithContext(address, context);\n  }\n\n  /**\n   * Check if addresses are the same (for \"same as billing\" functionality)\n   */\n  addressesEqual(address1: BaseAddress, address2: BaseAddress): boolean {\n    return (\n      address1.firstName === address2.firstName &&\n      address1.lastName === address2.lastName &&\n      address1.company === address2.company &&\n      address1.address1 === address2.address1 &&\n      address1.address2 === address2.address2 &&\n      address1.city === address2.city &&\n      address1.state === address2.state &&\n      address1.postcode === address2.postcode &&\n      address1.country === address2.country &&\n      address1.phone === address2.phone\n    );\n  }\n\n  /**\n   * Suggest address corrections (basic implementation)\n   */\n  async suggestAddressCorrection(address: BaseAddress): Promise<Result<BaseAddress | null, WooError>> {\n    try {\n      const countryConfig = this.countryConfigs[address.country.toUpperCase()];\n      if (!countryConfig) {\n        return Ok(null);\n      }\n\n      // Create a suggested address with basic corrections\n      const suggestedAddress: BaseAddress = {\n        ...address,\n        // Capitalize names\n        firstName: this.capitalizeWords(address.firstName),\n        lastName: this.capitalizeWords(address.lastName),\n        // Capitalize city\n        city: this.capitalizeWords(address.city),\n        // Uppercase country code\n        country: address.country.toUpperCase(),\n        // Format postal code\n        postcode: this.formatPostcode(address.postcode, countryConfig)\n      };\n\n      // Only return suggestion if something changed\n      if (JSON.stringify(address) !== JSON.stringify(suggestedAddress)) {\n        return Ok(suggestedAddress);\n      }\n\n      return Ok(null);\n\n    } catch (error) {\n      return Err(ErrorFactory.validationError(\n        'Address suggestion failed',\n        error\n      ));\n    }\n  }\n\n  /**\n   * Get country configuration\n   */\n  getCountryConfig(countryCode: string): CountryConfig | null {\n    return this.countryConfigs[countryCode.toUpperCase()] || null;\n  }\n\n  /**\n   * Get all supported countries\n   */\n  getSupportedCountries(): CountryConfig[] {\n    return Object.values(this.countryConfigs);\n  }\n\n  /**\n   * Add or update country configuration\n   */\n  setCountryConfig(countryCode: string, config: CountryConfig): void {\n    this.countryConfigs[countryCode.toUpperCase()] = config;\n  }\n\n  /**\n   * Parse and validate address from raw data\n   */\n  async parseAddress(rawData: unknown, type: 'base' | 'billing' | 'shipping' = 'base'): Promise<Result<BaseAddress | BillingAddress | ShippingAddress, WooError>> {\n    try {\n      switch (type) {\n        case 'billing':\n          const billingAddress = validateBillingAddress(rawData);\n          const billingValidation = await this.validateBillingAddress(billingAddress);\n          if (isErr(billingValidation)) {\n            return Err(unwrapErr(billingValidation));\n          }\n          if (!unwrap(billingValidation).isValid) {\n            return Err(this.createValidationError([...unwrap(billingValidation).errors]));\n          }\n          return Ok(billingAddress);\n\n        case 'shipping':\n          const shippingAddress = validateShippingAddress(rawData);\n          const shippingValidation = await this.validateShippingAddress(shippingAddress);\n          if (isErr(shippingValidation)) {\n            return Err(unwrapErr(shippingValidation));\n          }\n          if (!unwrap(shippingValidation).isValid) {\n            return Err(this.createValidationError([...unwrap(shippingValidation).errors]));\n          }\n          return Ok(shippingAddress);\n\n        default:\n          const baseAddress = validateBaseAddress(rawData);\n          const baseValidation = await this.validateAddress(baseAddress);\n          if (isErr(baseValidation)) {\n            return Err(unwrapErr(baseValidation));\n          }\n          if (!unwrap(baseValidation).isValid) {\n            return Err(this.createValidationError([...unwrap(baseValidation).errors]));\n          }\n          return Ok(baseAddress);\n      }\n\n    } catch (error) {\n      return Err(ErrorFactory.validationError(\n        `Failed to parse ${type} address`,\n        error\n      ));\n    }\n  }\n\n  /**\n   * Convert shipping address to billing address (adds required email)\n   */\n  convertToBillingAddress(shippingAddress: ShippingAddress, email: string): BillingAddress {\n    return {\n      ...shippingAddress,\n      email\n    };\n  }\n\n  /**\n   * Convert billing address to shipping address (removes email)\n   */\n  convertToShippingAddress(billingAddress: BillingAddress): ShippingAddress {\n    const { email, ...shippingAddress } = billingAddress;\n    return shippingAddress;\n  }\n\n  // Private helper methods\n\n  /**\n   * Build field requirements based on context\n   */\n  private buildFieldRequirements(\n    context: AddressValidationContext, \n    countryConfig: CountryConfig\n  ): AddressFieldRequirements {\n    // Start with base requirements\n    const baseRequirements: AddressFieldRequirements = {\n      firstName: true,\n      lastName: true,\n      company: false,\n      address1: true,\n      address2: false,\n      city: true,\n      state: countryConfig.stateRequired,\n      postcode: countryConfig.postcodeRequired,\n      country: true,\n      email: context.addressType === 'billing',\n      phone: false\n    };\n\n    // Apply context-specific overrides and checkout rules\n    const overrides: Partial<AddressFieldRequirements> = {};\n    \n    if (context.fieldRequirements) {\n      Object.assign(overrides, context.fieldRequirements);\n    }\n\n    if (context.checkoutRules) {\n      if (context.checkoutRules.requireCompanyName) {\n        overrides.company = true;\n      }\n      if (context.checkoutRules.requirePhoneNumber) {\n        overrides.phone = true;\n      }\n    }\n\n    // Create final requirements with overrides\n    const finalRequirements: AddressFieldRequirements = {\n      ...baseRequirements,\n      ...overrides\n    };\n\n    return finalRequirements;\n  }\n\n  /**\n   * Validate required fields\n   */\n  private validateRequiredFields(\n    address: BaseAddress, \n    requirements: AddressFieldRequirements, \n    errors: string[]\n  ): void {\n    if (requirements.firstName && (!address.firstName || !address.firstName.trim())) {\n      errors.push('First name is required');\n    }\n\n    if (requirements.lastName && (!address.lastName || !address.lastName.trim())) {\n      errors.push('Last name is required');\n    }\n\n    if (requirements.company && (!address.company || !address.company.trim())) {\n      errors.push('Company name is required');\n    }\n\n    if (requirements.address1 && (!address.address1 || !address.address1.trim())) {\n      errors.push('Street address is required');\n    }\n\n    if (requirements.address2 && (!address.address2 || !address.address2.trim())) {\n      errors.push('Address line 2 is required');\n    }\n\n    if (requirements.city && (!address.city || !address.city.trim())) {\n      errors.push('City is required');\n    }\n\n    if (requirements.state && (!address.state || !address.state.trim())) {\n      errors.push('State/Province is required');\n    }\n\n    if (requirements.postcode && (!address.postcode || !address.postcode.trim())) {\n      errors.push('Postal/ZIP code is required');\n    }\n\n    if (requirements.country && (!address.country || !address.country.trim())) {\n      errors.push('Country is required');\n    }\n\n    if (requirements.email && (!address.email || !address.email.trim())) {\n      errors.push('Email address is required');\n    }\n\n    if (requirements.phone && (!address.phone || !address.phone.trim())) {\n      errors.push('Phone number is required');\n    }\n  }\n\n  /**\n   * Validate field formats\n   */\n  private validateFieldFormats(\n    address: BaseAddress, \n    countryConfig: CountryConfig, \n    errors: string[], \n    warnings: string[]\n  ): void {\n    // Validate postal code format\n    if (address.postcode && countryConfig.postcodePattern) {\n      const postcodeRegex = new RegExp(countryConfig.postcodePattern);\n      if (!postcodeRegex.test(address.postcode)) {\n        errors.push(`Invalid postal/ZIP code format for ${countryConfig.name}`);\n      }\n    }\n\n    // Validate phone number format if provided\n    if (address.phone && countryConfig.phonePattern) {\n      const phoneRegex = new RegExp(countryConfig.phonePattern);\n      if (!phoneRegex.test(address.phone)) {\n        warnings.push(`Phone number format may be invalid for ${countryConfig.name}`);\n      }\n    }\n\n    // Basic field length validation\n    if (address.firstName && address.firstName.length < 2) {\n      errors.push('First name must be at least 2 characters');\n    }\n\n    if (address.lastName && address.lastName.length < 2) {\n      errors.push('Last name must be at least 2 characters');\n    }\n\n    if (address.address1 && address.address1.length < 5) {\n      errors.push('Street address must be at least 5 characters');\n    }\n\n    if (address.city && address.city.length < 2) {\n      errors.push('City must be at least 2 characters');\n    }\n\n    // Email validation\n    if (address.email) {\n      const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n      if (!emailRegex.test(address.email)) {\n        errors.push('Invalid email address format');\n      }\n    }\n  }\n\n  /**\n   * Capitalize words in a string\n   */\n  private capitalizeWords(str: string): string {\n    return str.toLowerCase().replace(/\\b\\w/g, char => char.toUpperCase());\n  }\n\n  /**\n   * Format postal code according to country pattern\n   */\n  private formatPostcode(postcode: string, countryConfig: CountryConfig): string {\n    const cleaned = postcode.replace(/\\s+/g, '').toUpperCase();\n    \n    switch (countryConfig.code) {\n      case 'CA':\n        // Format Canadian postal codes: A1A 1A1\n        if (cleaned.length === 6) {\n          return `${cleaned.slice(0, 3)} ${cleaned.slice(3)}`;\n        }\n        return postcode;\n      \n      case 'GB':\n        // Format UK postal codes with space\n        if (cleaned.length >= 5) {\n          return `${cleaned.slice(0, -3)} ${cleaned.slice(-3)}`;\n        }\n        return postcode;\n      \n      case 'NL':\n        // Format Dutch postal codes: 1234 AB\n        if (cleaned.length === 6) {\n          return `${cleaned.slice(0, 4)} ${cleaned.slice(4)}`;\n        }\n        return postcode;\n      \n      default:\n        return postcode;\n    }\n  }\n\n  /**\n   * Create validation error from error messages\n   */\n  private createValidationError(errors: string[]): WooError {\n    return {\n      code: 'VALIDATION_ERROR',\n      message: 'Address validation failed',\n      details: { errors },\n      timestamp: new Date()\n    };\n  }\n}\n\n/**\n * Default address manager instance\n */\nexport const defaultAddressManager = new AddressManager(); ","/**\n * Shipping Service for WooCommerce Headless SDK\n * Backend-calculated shipping rates with frontend display and selection\n * Following the Enhanced Unified 10X Developer Framework\n */\n\nimport { HttpClient } from '../../core/client';\nimport { CacheManager } from '../../core/cache';\nimport { Result, Ok, Err, isErr, isOk, unwrap, unwrapErr } from '../../types/result';\nimport { WooError, ErrorFactory } from '../../types/errors';\nimport { \n  ShippingRate,\n  ShippingZone,\n  ShippingMethodType,\n  SelectedShippingMethod,\n  BaseAddress,\n  OrderTotals\n} from '../../types/checkout';\n\n/**\n * Shipping rate request parameters\n */\nexport interface ShippingRateRequest {\n  readonly destination: BaseAddress;\n  readonly cartItems: readonly {\n    readonly productId: number;\n    readonly variationId?: number;\n    readonly quantity: number;\n    readonly weight?: number;\n    readonly dimensions?: {\n      readonly length: number;\n      readonly width: number;\n      readonly height: number;\n    };\n  }[];\n  readonly cartTotal: number;\n  readonly currency: string;\n}\n\n/**\n * Shipping rate response from backend\n */\nexport interface ShippingRateResponse {\n  readonly rates: readonly ShippingRate[];\n  readonly zones: readonly ShippingZone[];\n  readonly defaultRate?: ShippingRate;\n  readonly freeShippingThreshold?: number;\n  readonly estimatedDelivery?: {\n    readonly minDays: number;\n    readonly maxDays: number;\n  };\n}\n\n/**\n * Shipping calculation for order totals\n */\nexport interface ShippingCalculation {\n  readonly selectedMethod: SelectedShippingMethod;\n  readonly shippingCost: number;\n  readonly shippingTax: number;\n  readonly estimatedDelivery?: string;\n  readonly trackingAvailable: boolean;\n}\n\n/**\n * Shipping service configuration\n */\nexport interface ShippingConfig {\n  readonly enabled: boolean;\n  readonly calculateTax: boolean;\n  readonly freeShippingThreshold?: number;\n  readonly defaultCountry: string;\n  readonly restrictedCountries: readonly string[];\n  readonly cacheTimeout: number; // in minutes\n}\n\n/**\n * Shipping service for fetching rates and managing selections\n */\nexport class ShippingService {\n  private readonly client: HttpClient;\n  private readonly cache: CacheManager;\n  private readonly config: ShippingConfig;\n\n  constructor(\n    client: HttpClient, \n    cache: CacheManager,\n    config: ShippingConfig\n  ) {\n    this.client = client;\n    this.cache = cache;\n    this.config = config;\n  }\n\n  /**\n   * Fetch available shipping rates from backend\n   */\n  async getShippingRates(request: ShippingRateRequest): Promise<Result<ShippingRateResponse, WooError>> {\n    try {\n      // Check if shipping is available for destination\n      if (!this.isShippingAvailable(request.destination.country)) {\n        return Err(ErrorFactory.validationError(\n          'Shipping not available to this destination',\n          { country: request.destination.country }\n        ));\n      }\n\n      // Generate cache key\n      const cacheKey = this.generateCacheKey(request);\n      \n      // Check cache first\n      const cachedRates = await this.cache.get<ShippingRateResponse>(cacheKey);\n      if (cachedRates.success && cachedRates.data) {\n        return Ok(cachedRates.data);\n      }\n\n      // Fetch from backend\n      const response = await this.client.post('/wp-json/wc/v3/shipping/rates', {\n        destination: {\n          country: request.destination.country,\n          state: request.destination.state,\n          postcode: request.destination.postcode,\n          city: request.destination.city\n        },\n        items: request.cartItems,\n        cart_total: request.cartTotal,\n        currency: request.currency\n      });\n\n      if (isErr(response)) {\n        return Err(ErrorFactory.apiError(\n          'Failed to fetch shipping rates',\n          500,\n          unwrapErr(response)\n        ));\n      }\n\n      const responseData = unwrap(response).data as any;\n      const shippingResponse: ShippingRateResponse = {\n        rates: responseData.rates || [],\n        zones: responseData.zones || [],\n        defaultRate: responseData.default_rate,\n        freeShippingThreshold: responseData.free_shipping_threshold,\n        estimatedDelivery: responseData.estimated_delivery\n      };\n\n      // Cache the response\n      await this.cache.set(cacheKey, shippingResponse, this.config.cacheTimeout * 60);\n\n      return Ok(shippingResponse);\n\n    } catch (error) {\n      return Err(ErrorFactory.apiError(\n        'Shipping rate calculation failed',\n        500,\n        error\n      ));\n    }\n  }\n\n  /**\n   * Get shipping zones for a specific country\n   */\n  async getShippingZones(country: string): Promise<Result<ShippingZone[], WooError>> {\n    try {\n      const cacheKey = `shipping-zones:${country}`;\n      \n      // Check cache first\n      const cachedZones = await this.cache.get<ShippingZone[]>(cacheKey);\n      if (cachedZones.success && cachedZones.data) {\n        return Ok(cachedZones.data);\n      }\n\n      // Fetch from backend\n      const response = await this.client.get(`/wp-json/wc/v3/shipping/zones`, {\n        country: country.toUpperCase()\n      });\n\n      if (isErr(response)) {\n        return Err(unwrap(response));\n      }\n\n      const zones = unwrap(response).data || [];\n      \n      // Cache the response\n      await this.cache.set(cacheKey, zones, this.config.cacheTimeout * 60);\n\n      return Ok(zones);\n\n    } catch (error) {\n      return Err(ErrorFactory.apiError(\n        'Failed to fetch shipping zones',\n        500,\n        error\n      ));\n    }\n  }\n\n  /**\n   * Calculate shipping for selected method (backend handles calculation)\n   */\n  async calculateShipping(\n    selectedMethod: SelectedShippingMethod,\n    destination: BaseAddress,\n    cartTotal: number\n  ): Promise<Result<ShippingCalculation, WooError>> {\n    try {\n      // Backend calculates the actual cost and tax\n      const response = await this.client.post('/wp-json/wc/v3/shipping/calculate', {\n        method_id: selectedMethod.methodId,\n        zone_id: selectedMethod.zoneId,\n        destination: {\n          country: destination.country,\n          state: destination.state,\n          postcode: destination.postcode,\n          city: destination.city\n        },\n        cart_total: cartTotal\n      });\n\n      if (isErr(response)) {\n        return Err(unwrap(response));\n      }\n\n      const data = unwrap(response);\n      \n      const calculation: ShippingCalculation = {\n        selectedMethod,\n        shippingCost: data.cost || 0,\n        shippingTax: data.tax || 0,\n        estimatedDelivery: data.estimated_delivery,\n        trackingAvailable: data.tracking_available || false\n      };\n\n      return Ok(calculation);\n\n    } catch (error) {\n      return Err(ErrorFactory.apiError(\n        'Shipping calculation failed',\n        500,\n        error\n      ));\n    }\n  }\n\n  /**\n   * Check if free shipping is available\n   */\n  checkFreeShipping(cartTotal: number, freeShippingThreshold?: number): boolean {\n    if (!freeShippingThreshold) return false;\n    return cartTotal >= freeShippingThreshold;\n  }\n\n  /**\n   * Get cheapest shipping option\n   */\n  getCheapestRate(rates: readonly ShippingRate[]): ShippingRate | null {\n    if (rates.length === 0) return null;\n    \n    return rates.reduce((cheapest, current) => \n      current.cost < cheapest.cost ? current : cheapest\n    );\n  }\n\n  /**\n   * Get fastest shipping option\n   */\n  getFastestRate(rates: readonly ShippingRate[]): ShippingRate | null {\n    if (rates.length === 0) return null;\n    \n    // Prioritize by shipping method type (expedited, overnight first)\n    const priorityOrder: ShippingMethodType[] = [\n      'overnight',\n      'expedited', \n      'flat_rate',\n      'table_rate',\n      'local_pickup',\n      'free_shipping'\n    ];\n\n    for (const methodType of priorityOrder) {\n      const rate = rates.find(r => r.method === methodType);\n      if (rate) return rate;\n    }\n\n    return rates[0];\n  }\n\n  /**\n   * Filter rates by shipping method type\n   */\n  filterRatesByMethod(rates: readonly ShippingRate[], method: ShippingMethodType): ShippingRate[] {\n    return rates.filter(rate => rate.method === method);\n  }\n\n  /**\n   * Group rates by zone\n   */\n  groupRatesByZone(rates: readonly ShippingRate[], zones: readonly ShippingZone[]): Record<string, ShippingRate[]> {\n    const grouped: Record<string, ShippingRate[]> = {};\n    \n    zones.forEach(zone => {\n      grouped[zone.id] = zone.methods.filter(method => \n        rates.some(rate => rate.id === method.id)\n      );\n    });\n\n    return grouped;\n  }\n\n  /**\n   * Validate shipping selection\n   */\n  validateShippingSelection(\n    selectedMethod: SelectedShippingMethod,\n    availableRates: readonly ShippingRate[]\n  ): boolean {\n    return availableRates.some(rate => \n      rate.id === selectedMethod.methodId\n    );\n  }\n\n  /**\n   * Update order totals with shipping calculation\n   */\n  updateOrderTotalsWithShipping(\n    currentTotals: OrderTotals,\n    shippingCalculation: ShippingCalculation\n  ): OrderTotals {\n    return {\n      ...currentTotals,\n      shipping: shippingCalculation.shippingCost,\n      shippingTax: shippingCalculation.shippingTax,\n      total: currentTotals.subtotal + \n             currentTotals.tax + \n             shippingCalculation.shippingCost + \n             shippingCalculation.shippingTax + \n             currentTotals.fees + \n             currentTotals.feesTax - \n             currentTotals.discount\n    };\n  }\n\n  /**\n   * Estimate delivery date\n   */\n  estimateDeliveryDate(rate: ShippingRate, orderDate: Date = new Date()): Date | null {\n    if (!rate.estimatedDelivery) return null;\n\n    // Parse estimated delivery string (e.g., \"3-5 business days\")\n    const deliveryMatch = rate.estimatedDelivery.match(/(\\d+)-?(\\d+)?\\s*(business\\s+)?days?/i);\n    if (!deliveryMatch) return null;\n\n    const minDays = parseInt(deliveryMatch[1]);\n    const maxDays = deliveryMatch[2] ? parseInt(deliveryMatch[2]) : minDays;\n    const isBusinessDays = !!deliveryMatch[3];\n\n    let deliveryDate = new Date(orderDate);\n    let daysToAdd = maxDays; // Use maximum estimated days\n\n    if (isBusinessDays) {\n      // Add business days (skip weekends)\n      let addedDays = 0;\n      while (addedDays < daysToAdd) {\n        deliveryDate.setDate(deliveryDate.getDate() + 1);\n        if (deliveryDate.getDay() !== 0 && deliveryDate.getDay() !== 6) {\n          addedDays++;\n        }\n      }\n    } else {\n      // Add calendar days\n      deliveryDate.setDate(deliveryDate.getDate() + daysToAdd);\n    }\n\n    return deliveryDate;\n  }\n\n  /**\n   * Clear shipping rate cache\n   */\n  async clearShippingCache(): Promise<Result<void, WooError>> {\n    try {\n      await this.cache.invalidatePattern('shipping-');\n      return Ok(undefined);\n    } catch (error) {\n      return Err(ErrorFactory.cacheError(\n        'Failed to clear shipping cache',\n        error\n      ));\n    }\n  }\n\n  // Private helper methods\n\n  /**\n   * Check if shipping is available to country\n   */\n  private isShippingAvailable(country: string): boolean {\n    if (!this.config.enabled) return false;\n    if (this.config.restrictedCountries.includes(country.toUpperCase())) return false;\n    return true;\n  }\n\n  /**\n   * Generate cache key for shipping request\n   */\n  private generateCacheKey(request: ShippingRateRequest): string {\n    const keyData = {\n      country: request.destination.country,\n      state: request.destination.state,\n      postcode: request.destination.postcode,\n      itemCount: request.cartItems.length,\n      total: request.cartTotal,\n      currency: request.currency\n    };\n    \n    return `shipping-rates:${Buffer.from(JSON.stringify(keyData)).toString('base64')}`;\n  }\n}\n\n/**\n * Default shipping configuration\n */\nexport const DEFAULT_SHIPPING_CONFIG: ShippingConfig = {\n  enabled: true,\n  calculateTax: true,\n  defaultCountry: 'US',\n  restrictedCountries: [],\n  cacheTimeout: 15 // 15 minutes\n}; ","/**\n * Payment Gateway Framework for WooCommerce Headless SDK\n * Backend WordPress/WooCommerce payment processing with frontend flow management\n * Following the Enhanced Unified 10X Developer Framework\n */\n\nimport { HttpClient } from '../../core/client';\nimport { CacheManager } from '../../core/cache';\nimport { Result, Ok, Err, isErr, isOk, unwrap, unwrapErr } from '../../types/result';\nimport { WooError, ErrorFactory } from '../../types/errors';\nimport { \n  PaymentMethod,\n  PaymentMethodType,\n  PaymentTransaction,\n  CreditCard,\n  Order,\n  OrderTotals,\n  PaymentRequest,\n  PaymentInitRequest,\n  PaymentStatusRequest,\n  PaymentCallbackData,\n  CheckoutSession\n} from '../../types/checkout';\n\n/**\n * Available payment methods response from backend\n */\nexport interface PaymentMethodsResponse {\n  readonly availableMethods: readonly PaymentMethod[];\n  readonly defaultMethod?: PaymentMethod;\n  readonly minimumAmounts: Record<string, number>;\n  readonly currency: string;\n}\n\n/**\n * Payment initialization request\n */\nexport interface PaymentInitResponse {\n  readonly paymentId: string;\n  readonly redirectUrl?: string;\n  readonly requiresRedirect: boolean;\n  readonly clientSecret?: string;\n  readonly paymentIntentId?: string;\n  readonly instructions?: string;\n  readonly expiresAt?: Date;\n}\n\n/**\n * Payment status check response\n */\nexport interface PaymentStatusResponse {\n  readonly paymentId: string;\n  readonly status: 'pending' | 'processing' | 'completed' | 'failed' | 'cancelled';\n  readonly transactionId?: string;\n  readonly failureReason?: string;\n  readonly redirectUrl?: string;\n  readonly nextAction?: {\n    readonly type: 'redirect' | 'authenticate' | 'confirm';\n    readonly url?: string;\n    readonly data?: Record<string, unknown>;\n  };\n}\n\n/**\n * Payment method validation result\n */\nexport interface PaymentValidationResult {\n  readonly isValid: boolean;\n  readonly errors: readonly string[];\n  readonly warnings: readonly string[];\n}\n\n/**\n * Payment service configuration\n */\nexport interface PaymentConfig {\n  readonly enabled: boolean;\n  readonly testMode: boolean;\n  readonly supportedMethods: readonly PaymentMethodType[];\n  readonly minimumAmount: number;\n  readonly maximumAmount?: number;\n  readonly currency: string;\n  readonly returnUrl: string;\n  readonly cancelUrl: string;\n  readonly webhookUrl?: string;\n  readonly cacheTimeout: number; // in minutes\n}\n\n/**\n * Payment gateway service for backend integration\n */\nexport class PaymentService {\n  private readonly client: HttpClient;\n  private readonly cache: CacheManager;\n  private readonly config: PaymentConfig;\n\n  constructor(\n    client: HttpClient,\n    cache: CacheManager,\n    config: PaymentConfig\n  ) {\n    this.client = client;\n    this.cache = cache;\n    this.config = config;\n  }\n\n  /**\n   * Get available payment methods from backend\n   */\n  async getAvailablePaymentMethods(\n    amount: number, \n    currency: string = this.config.currency,\n    country?: string\n  ): Promise<Result<PaymentMethodsResponse, WooError>> {\n    try {\n      const cacheKey = `payment-methods:${amount}:${currency}:${country || 'default'}`;\n      \n      // Check cache first\n      const cached = await this.cache.get<PaymentMethodsResponse>(cacheKey);\n      if (cached.success && cached.data) {\n        return Ok(cached.data);\n      }\n\n      // Fetch from backend\n      const response = await this.client.get('/wp-json/wc/v3/payment_gateways', {\n        amount: amount.toString(),\n        currency,\n        country: country?.toUpperCase()\n      });\n\n      if (isErr(response)) {\n        return Err(unwrapErr(response));\n      }\n\n      const data = unwrap(response).data as any;\n      const paymentResponse: PaymentMethodsResponse = {\n        availableMethods: data.payment_gateways || [],\n        defaultMethod: data.default_gateway,\n        minimumAmounts: data.minimum_amounts || {},\n        currency: data.currency || currency\n      };\n\n      // Cache the response\n      await this.cache.set(cacheKey, paymentResponse, this.config.cacheTimeout * 60);\n\n      return Ok(paymentResponse);\n\n    } catch (error) {\n      return Err(ErrorFactory.apiError(\n        'Failed to fetch payment methods',\n        500,\n        error\n      ));\n    }\n  }\n\n  /**\n   * Initialize payment with selected method\n   */\n  async initializePayment(request: PaymentInitRequest): Promise<Result<PaymentInitResponse, WooError>> {\n    try {\n      // Validate payment method is available\n      const methodsResult = await this.getAvailablePaymentMethods(request.amount, request.currency);\n      if (isErr(methodsResult)) {\n        return Err(unwrapErr(methodsResult));\n      }\n\n      const methods = unwrap(methodsResult);\n      const selectedMethod = methods.availableMethods.find(m => m.id === request.paymentMethodId);\n      if (!selectedMethod || !selectedMethod.enabled) {\n        return Err(ErrorFactory.validationError(\n          'Selected payment method is not available',\n          { methodId: request.paymentMethodId }\n        ));\n      }\n\n      // Initialize payment with backend\n      const response = await this.client.post('/wp-json/wc/v3/payments/initialize', {\n        payment_method: request.paymentMethodId,\n        order_id: request.orderId,\n        amount: request.amount,\n        currency: request.currency,\n        return_url: request.returnUrl,\n        cancel_url: request.cancelUrl,\n        metadata: request.metadata\n      });\n\n      if (isErr(response)) {\n        return Err(unwrapErr(response));\n      }\n\n      const data = unwrap(response).data as any;\n      const initResponse: PaymentInitResponse = {\n        paymentId: data.payment_id,\n        redirectUrl: data.redirect_url,\n        requiresRedirect: data.requires_redirect || false,\n        clientSecret: data.client_secret,\n        paymentIntentId: data.payment_intent_id,\n        instructions: data.instructions,\n        expiresAt: data.expires_at ? new Date(data.expires_at) : undefined\n      };\n\n      return Ok(initResponse);\n\n    } catch (error) {\n      return Err(ErrorFactory.apiError(\n        'Payment initialization failed',\n        500,\n        error\n      ));\n    }\n  }\n\n  /**\n   * Check payment status\n   */\n  async checkPaymentStatus(paymentId: string): Promise<Result<PaymentStatusResponse, WooError>> {\n    try {\n      const response = await this.client.get(`/wp-json/wc/v3/payments/${paymentId}/status`);\n\n      if (isErr(response)) {\n        return Err(unwrapErr(response));\n      }\n\n      const data = unwrap(response).data as any;\n      const statusResponse: PaymentStatusResponse = {\n        paymentId: data.payment_id,\n        status: data.status,\n        transactionId: data.transaction_id,\n        failureReason: data.failure_reason,\n        redirectUrl: data.redirect_url,\n        nextAction: data.next_action ? {\n          type: data.next_action.type,\n          url: data.next_action.url,\n          data: data.next_action.data\n        } : undefined\n      };\n\n      return Ok(statusResponse);\n\n    } catch (error) {\n      return Err(ErrorFactory.apiError(\n        'Payment status check failed',\n        500,\n        error\n      ));\n    }\n  }\n\n  /**\n   * Handle payment callback from gateway\n   */\n  async handlePaymentCallback(callbackData: PaymentCallbackData): Promise<Result<PaymentStatusResponse, WooError>> {\n    try {\n      // Verify callback signature if provided\n      if (callbackData.signature) {\n        const isValid = await this.verifyCallbackSignature(callbackData);\n        if (!isValid) {\n          return Err(ErrorFactory.authError(\n            'Invalid payment callback signature'\n          ));\n        }\n      }\n\n      // Process callback with backend\n      const response = await this.client.post('/wp-json/wc/v3/payments/callback', {\n        payment_id: callbackData.paymentId,\n        order_id: callbackData.orderId,\n        status: callbackData.status,\n        transaction_id: callbackData.transactionId,\n        signature: callbackData.signature,\n        metadata: callbackData.metadata\n      });\n\n      if (isErr(response)) {\n        return Err(unwrapErr(response));\n      }\n\n      const data = unwrap(response).data as any;\n      const statusResponse: PaymentStatusResponse = {\n        paymentId: data.payment_id,\n        status: data.status,\n        transactionId: data.transaction_id,\n        failureReason: data.failure_reason,\n        redirectUrl: data.redirect_url\n      };\n\n      return Ok(statusResponse);\n\n    } catch (error) {\n      return Err(ErrorFactory.apiError(\n        'Payment callback processing failed',\n        500,\n        error\n      ));\n    }\n  }\n\n  /**\n   * Cancel payment\n   */\n  async cancelPayment(paymentId: string, reason?: string): Promise<Result<void, WooError>> {\n    try {\n      const response = await this.client.post(`/wp-json/wc/v3/payments/${paymentId}/cancel`, {\n        reason\n      });\n\n      if (isErr(response)) {\n        return Err(unwrapErr(response));\n      }\n\n      return Ok(undefined);\n\n    } catch (error) {\n      return Err(ErrorFactory.apiError(\n        'Payment cancellation failed',\n        500,\n        error\n      ));\n    }\n  }\n\n  /**\n   * Validate payment method selection\n   */\n  async validatePaymentMethod(\n    methodId: string,\n    amount: number,\n    currency: string = this.config.currency\n  ): Promise<Result<PaymentValidationResult, WooError>> {\n    try {\n      const errors: string[] = [];\n      const warnings: string[] = [];\n\n      // Check if method is supported\n      if (!this.config.supportedMethods.includes(methodId as PaymentMethodType)) {\n        errors.push(`Payment method \"${methodId}\" is not supported`);\n      }\n\n      // Check amount limits\n      if (amount < this.config.minimumAmount) {\n        errors.push(`Amount is below minimum (${this.config.minimumAmount} ${currency})`);\n      }\n\n      if (this.config.maximumAmount && amount > this.config.maximumAmount) {\n        errors.push(`Amount exceeds maximum (${this.config.maximumAmount} ${currency})`);\n      }\n\n      // Get available methods to validate\n      const methodsResult = await this.getAvailablePaymentMethods(amount, currency);\n      if (isErr(methodsResult)) {\n        return Err(unwrapErr(methodsResult));\n      }\n\n      const methods = unwrap(methodsResult);\n      const method = methods.availableMethods.find(m => m.id === methodId);\n      \n      if (!method) {\n        errors.push(`Payment method \"${methodId}\" is not available`);\n      } else if (!method.enabled) {\n        errors.push(`Payment method \"${methodId}\" is currently disabled`);\n      } else {\n        // Check method-specific minimum amount\n        const methodMinimum = methods.minimumAmounts[methodId];\n        if (methodMinimum && amount < methodMinimum) {\n          errors.push(`Amount is below minimum for ${method.title} (${methodMinimum} ${currency})`);\n        }\n\n        // Add method-specific warnings\n        if (method.description) {\n          warnings.push(method.description);\n        }\n      }\n\n      return Ok({\n        isValid: errors.length === 0,\n        errors,\n        warnings\n      });\n\n    } catch (error) {\n      return Err(ErrorFactory.validationError(\n        'Payment method validation failed',\n        error\n      ));\n    }\n  }\n\n  /**\n   * Generate payment redirect URL\n   */\n  generateRedirectUrl(baseUrl: string, params: Record<string, string>): string {\n    const url = new URL(baseUrl);\n    Object.entries(params).forEach(([key, value]) => {\n      url.searchParams.set(key, value);\n    });\n    return url.toString();\n  }\n\n  /**\n   * Parse payment callback URL parameters\n   */\n  parseCallbackUrl(callbackUrl: string): Record<string, string> {\n    const url = new URL(callbackUrl);\n    const params: Record<string, string> = {};\n    \n    url.searchParams.forEach((value, key) => {\n      params[key] = value;\n    });\n\n    return params;\n  }\n\n  /**\n   * Check if payment method requires redirect\n   */\n  requiresRedirect(methodId: string): boolean {\n    const redirectMethods: PaymentMethodType[] = [\n      'paypal',\n      'stripe_checkout',\n      'bank_transfer',\n      'cash_on_delivery'\n    ];\n    \n    return redirectMethods.includes(methodId as PaymentMethodType);\n  }\n\n  /**\n   * Get payment method display information\n   */\n  getPaymentMethodDisplay(method: PaymentMethod): {\n    title: string;\n    description: string;\n    icon?: string;\n    acceptedCards?: string[];\n  } {\n    return {\n      title: method.title || method.id,\n      description: method.description || '',\n      icon: method.icon,\n      acceptedCards: method.acceptedCards\n    };\n  }\n\n  /**\n   * Filter payment methods by criteria\n   */\n  filterPaymentMethods(\n    methods: readonly PaymentMethod[],\n    criteria: {\n      enabled?: boolean;\n      minAmount?: number;\n      country?: string;\n      currency?: string;\n    }\n  ): PaymentMethod[] {\n    return methods.filter(method => {\n      if (criteria.enabled !== undefined && method.enabled !== criteria.enabled) {\n        return false;\n      }\n\n      if (criteria.minAmount && method.minimumAmount && criteria.minAmount < method.minimumAmount) {\n        return false;\n      }\n\n      if (criteria.country && method.supportedCountries && \n          !method.supportedCountries.includes(criteria.country.toUpperCase())) {\n        return false;\n      }\n\n      if (criteria.currency && method.supportedCurrencies && \n          !method.supportedCurrencies.includes(criteria.currency.toUpperCase())) {\n        return false;\n      }\n\n      return true;\n    });\n  }\n\n  /**\n   * Clear payment methods cache\n   */\n  async clearPaymentCache(): Promise<Result<void, WooError>> {\n    try {\n      await this.cache.invalidatePattern('payment-');\n      return Ok(undefined);\n    } catch (error) {\n      return Err(ErrorFactory.cacheError(\n        'Failed to clear payment cache',\n        error\n      ));\n    }\n  }\n\n  // Private helper methods\n\n  /**\n   * Verify payment callback signature\n   */\n  private async verifyCallbackSignature(callbackData: PaymentCallbackData): Promise<boolean> {\n    try {\n      // This would implement gateway-specific signature verification\n      // For now, return true as placeholder\n      return true;\n    } catch (error) {\n      return false;\n    }\n  }\n}\n\n/**\n * Payment flow manager for handling multi-step payments\n */\nexport class PaymentFlowManager {\n  private readonly paymentService: PaymentService;\n  private currentPayment: PaymentInitResponse | null = null;\n\n  constructor(paymentService: PaymentService) {\n    this.paymentService = paymentService;\n  }\n\n  /**\n   * Start payment flow\n   */\n  async startPayment(request: PaymentInitRequest): Promise<Result<PaymentInitResponse, WooError>> {\n    const result = await this.paymentService.initializePayment(request);\n    \n    if (isOk(result)) {\n      this.currentPayment = unwrap(result);\n    }\n\n    return result;\n  }\n\n  /**\n   * Handle redirect return\n   */\n  async handleRedirectReturn(returnUrl: string): Promise<Result<PaymentStatusResponse, WooError>> {\n    if (!this.currentPayment) {\n      return Err(ErrorFactory.validationError('No active payment flow'));\n    }\n\n    const params = this.paymentService.parseCallbackUrl(returnUrl);\n    const paymentId = params.payment_id || this.currentPayment.paymentId;\n\n    return this.paymentService.checkPaymentStatus(paymentId);\n  }\n\n  /**\n   * Poll payment status\n   */\n  async pollPaymentStatus(\n    paymentId: string,\n    intervalMs: number = 2000,\n    timeoutMs: number = 30000\n  ): Promise<Result<PaymentStatusResponse, WooError>> {\n    const startTime = Date.now();\n\n    while (Date.now() - startTime < timeoutMs) {\n      const statusResult = await this.paymentService.checkPaymentStatus(paymentId);\n      \n      if (isErr(statusResult)) {\n        return statusResult;\n      }\n\n      const status = unwrap(statusResult);\n      if (status.status === 'completed' || status.status === 'failed') {\n        return Ok(status);\n      }\n\n      // Wait before next poll\n      await new Promise(resolve => setTimeout(resolve, intervalMs));\n    }\n\n    return Err(ErrorFactory.timeoutError('Payment status polling timeout', 30000));\n  }\n\n  /**\n   * Reset current payment flow\n   */\n  resetFlow(): void {\n    this.currentPayment = null;\n  }\n\n  /**\n   * Get current payment info\n   */\n  getCurrentPayment(): PaymentInitResponse | null {\n    return this.currentPayment;\n  }\n}\n\n/**\n * Default payment configuration\n */\nexport const DEFAULT_PAYMENT_CONFIG: PaymentConfig = {\n  enabled: true,\n  testMode: true,\n  supportedMethods: ['stripe', 'paypal', 'bank_transfer', 'cash_on_delivery'],\n  minimumAmount: 1,\n  currency: 'USD',\n  returnUrl: '/checkout/payment/return',\n  cancelUrl: '/checkout/payment/cancel',\n  cacheTimeout: 10 // 10 minutes\n}; ","/**\n * Comprehensive Checkout Validation System for WooCommerce Headless SDK\n * Coordinates all checkout component validations into unified validation framework\n * Following the Enhanced Unified 10X Developer Framework\n */\n\nimport { Result, Ok, Err, isErr, isOk, unwrap, unwrapErr } from '../../types/result';\nimport { WooError, ErrorFactory } from '../../types/errors';\nimport {\n  CheckoutValidationRules,\n  CheckoutValidationResult,\n  CheckoutValidationContext,\n  CheckoutSession\n} from '../../types/checkout';\nimport { Cart, CartItem } from '../../types/cart';\nimport { AddressManager, AddressValidationContext } from './address';\nimport { ShippingService } from './shipping';\nimport { PaymentService } from './payment';\n\n/**\n * Validation result for individual checkout components\n */\nexport interface ValidationResult {\n  readonly component: 'address' | 'shipping' | 'payment' | 'cart' | 'totals';\n  readonly isValid: boolean;\n  readonly errors: readonly string[];\n  readonly warnings: readonly string[];\n  readonly metadata?: Record<string, unknown>;\n}\n\n/**\n * Comprehensive checkout validation result\n */\nexport interface CheckoutValidationResult {\n  readonly isValid: boolean;\n  readonly canProceed: boolean;\n  readonly validationResults: readonly ValidationResult[];\n  readonly criticalErrors: readonly string[];\n  readonly warnings: readonly string[];\n  readonly blockers: readonly string[];\n  readonly recommendations: readonly string[];\n}\n\n/**\n * Validation context for checkout process\n */\nexport interface CheckoutValidationContext {\n  readonly checkoutSession: CheckoutSession;\n  readonly cart: Cart;\n  readonly validationRules: CheckoutValidationRules;\n  readonly isGuestCheckout: boolean;\n  readonly currentStep: number;\n  readonly skipOptionalValidations?: boolean;\n}\n\n/**\n * Stock validation result\n */\nexport interface StockValidationResult {\n  readonly isValid: boolean;\n  readonly outOfStockItems: readonly CartItem[];\n  readonly insufficientStockItems: readonly {\n    readonly item: CartItem;\n    readonly availableQuantity: number;\n  }[];\n  readonly backorderItems: readonly CartItem[];\n}\n\n/**\n * Comprehensive checkout validation service\n */\nexport class CheckoutValidationService {\n  private readonly addressManager: AddressManager;\n  private readonly shippingService: ShippingService;\n  private readonly paymentService: PaymentService;\n\n  constructor(\n    addressManager: AddressManager,\n    shippingService: ShippingService,\n    paymentService: PaymentService\n  ) {\n    this.addressManager = addressManager;\n    this.shippingService = shippingService;\n    this.paymentService = paymentService;\n  }\n\n  /**\n   * Validate entire checkout process\n   */\n  async validateCheckout(context: CheckoutValidationContext): Promise<Result<CheckoutValidationResult, WooError>> {\n    try {\n      const validationResults: ValidationResult[] = [];\n      const criticalErrors: string[] = [];\n      const warnings: string[] = [];\n      const blockers: string[] = [];\n      const recommendations: string[] = [];\n\n      // Validate billing address\n      const billingResult = await this.validateBillingAddress(context);\n      if (isErr(billingResult)) {\n        return Err(unwrapErr(billingResult));\n      }\n      validationResults.push(unwrap(billingResult));\n\n      // Validate shipping address if different from billing\n      if (!context.checkoutSession.useShippingAsBilling) {\n        const shippingResult = await this.validateShippingAddress(context);\n        if (isErr(shippingResult)) {\n          return Err(unwrapErr(shippingResult));\n        }\n        validationResults.push(unwrap(shippingResult));\n      }\n\n      // Validate shipping method\n      if (context.checkoutSession.selectedShippingMethod) {\n        const shippingMethodResult = await this.validateShippingMethod(context);\n        if (isErr(shippingMethodResult)) {\n          return Err(unwrapErr(shippingMethodResult));\n        }\n        validationResults.push(unwrap(shippingMethodResult));\n      }\n\n      // Validate payment method\n      if (context.checkoutSession.selectedPaymentMethod) {\n        const paymentResult = await this.validatePaymentMethod(context);\n        if (isErr(paymentResult)) {\n          return Err(unwrapErr(paymentResult));\n        }\n        validationResults.push(unwrap(paymentResult));\n      }\n\n      // Validate cart and stock\n      const cartResult = await this.validateCart(context);\n      if (isErr(cartResult)) {\n        return Err(unwrapErr(cartResult));\n      }\n      validationResults.push(unwrap(cartResult));\n\n      // Validate order totals\n      const totalsResult = await this.validateOrderTotals(context);\n      if (isErr(totalsResult)) {\n        return Err(unwrapErr(totalsResult));\n      }\n      validationResults.push(unwrap(totalsResult));\n\n      // Aggregate results\n      const allValid = validationResults.every(result => result.isValid);\n      \n      // Collect critical errors and warnings\n      validationResults.forEach(result => {\n        if (!result.isValid) {\n          criticalErrors.push(...result.errors);\n        }\n        warnings.push(...result.warnings);\n      });\n\n      // Determine blockers (issues that prevent checkout completion)\n      const hasAddressErrors = validationResults.some(r => \n        r.component === 'address' && !r.isValid\n      );\n      const hasPaymentErrors = validationResults.some(r => \n        r.component === 'payment' && !r.isValid\n      );\n      const hasStockErrors = validationResults.some(r => \n        r.component === 'cart' && !r.isValid\n      );\n\n      if (hasAddressErrors) {\n        blockers.push('Address information is incomplete or invalid');\n      }\n      if (hasPaymentErrors) {\n        blockers.push('Payment method is not valid or available');\n      }\n      if (hasStockErrors) {\n        blockers.push('Some items are out of stock or unavailable');\n      }\n\n      // Generate recommendations\n      this.generateRecommendations(validationResults, recommendations);\n\n      const canProceed = allValid && blockers.length === 0;\n\n      return Ok({\n        isValid: allValid,\n        canProceed,\n        validationResults,\n        criticalErrors,\n        warnings,\n        blockers,\n        recommendations\n      });\n\n    } catch (error) {\n      return Err(ErrorFactory.validationError(\n        'Checkout validation failed',\n        error\n      ));\n    }\n  }\n\n  /**\n   * Validate billing address\n   */\n  async validateBillingAddress(context: CheckoutValidationContext): Promise<Result<ValidationResult, WooError>> {\n    try {\n      const billingAddress = context.checkoutSession.billingAddress;\n      if (!billingAddress) {\n        return Ok({\n          component: 'address',\n          isValid: false,\n          errors: ['Billing address is required'],\n          warnings: []\n        });\n      }\n\n      const addressContext: AddressValidationContext = {\n        addressType: 'billing',\n        isGuestCheckout: context.isGuestCheckout,\n        checkoutRules: context.validationRules,\n        fieldRequirements: {\n          email: context.isGuestCheckout || context.validationRules.requireEmail\n        }\n      };\n\n      const validation = await this.addressManager.validateAddressWithContext(\n        billingAddress,\n        addressContext\n      );\n\n      if (isErr(validation)) {\n        return Err(unwrapErr(validation));\n      }\n\n      const result = unwrap(validation);\n      return Ok({\n        component: 'address',\n        isValid: result.isValid,\n        errors: result.errors,\n        warnings: result.warnings,\n        metadata: { addressType: 'billing' }\n      });\n\n    } catch (error) {\n      return Err(ErrorFactory.validationError(\n        'Billing address validation failed',\n        error\n      ));\n    }\n  }\n\n  /**\n   * Validate shipping address\n   */\n  async validateShippingAddress(context: CheckoutValidationContext): Promise<Result<ValidationResult, WooError>> {\n    try {\n      const shippingAddress = context.checkoutSession.shippingAddress;\n      if (!shippingAddress) {\n        return Ok({\n          component: 'address',\n          isValid: false,\n          errors: ['Shipping address is required'],\n          warnings: []\n        });\n      }\n\n      const addressContext: AddressValidationContext = {\n        addressType: 'shipping',\n        isGuestCheckout: context.isGuestCheckout,\n        checkoutRules: context.validationRules\n      };\n\n      const validation = await this.addressManager.validateAddressWithContext(\n        shippingAddress,\n        addressContext\n      );\n\n      if (isErr(validation)) {\n        return Err(unwrapErr(validation));\n      }\n\n      const result = unwrap(validation);\n      return Ok({\n        component: 'address',\n        isValid: result.isValid,\n        errors: result.errors,\n        warnings: result.warnings,\n        metadata: { addressType: 'shipping' }\n      });\n\n    } catch (error) {\n      return Err(ErrorFactory.validationError(\n        'Shipping address validation failed',\n        error\n      ));\n    }\n  }\n\n  /**\n   * Validate selected shipping method\n   */\n  async validateShippingMethod(context: CheckoutValidationContext): Promise<Result<ValidationResult, WooError>> {\n    try {\n      const selectedMethod = context.checkoutSession.selectedShippingMethod;\n      const shippingAddress = context.checkoutSession.useShippingAsBilling \n        ? context.checkoutSession.billingAddress \n        : context.checkoutSession.shippingAddress;\n\n      if (!selectedMethod || !shippingAddress) {\n        return Ok({\n          component: 'shipping',\n          isValid: false,\n          errors: ['Shipping method and address are required'],\n          warnings: []\n        });\n      }\n\n      // Get available shipping rates\n      const ratesResult = await this.shippingService.getShippingRates({\n        destination: shippingAddress,\n        cartItems: context.cart.items.map(item => ({\n          productId: item.productId,\n          variationId: item.variationId,\n          quantity: item.quantity,\n          weight: item.weight,\n          dimensions: item.dimensions\n        })),\n        cartTotal: context.cart.totals.total,\n        currency: context.cart.currency\n      });\n\n      if (isErr(ratesResult)) {\n        return Err(unwrapErr(ratesResult));\n      }\n\n      const rates = unwrap(ratesResult);\n      \n      // Check if selected method is available\n      const isValidMethod = this.shippingService.validateShippingSelection(\n        selectedMethod,\n        rates.rates\n      );\n\n      if (!isValidMethod) {\n        return Ok({\n          component: 'shipping',\n          isValid: false,\n          errors: ['Selected shipping method is no longer available'],\n          warnings: []\n        });\n      }\n\n      return Ok({\n        component: 'shipping',\n        isValid: true,\n        errors: [],\n        warnings: [],\n        metadata: { selectedMethod }\n      });\n\n    } catch (error) {\n      return Err(ErrorFactory.validationError(\n        'Shipping method validation failed',\n        error\n      ));\n    }\n  }\n\n  /**\n   * Validate selected payment method\n   */\n  async validatePaymentMethod(context: CheckoutValidationContext): Promise<Result<ValidationResult, WooError>> {\n    try {\n      const selectedMethod = context.checkoutSession.selectedPaymentMethod;\n      if (!selectedMethod) {\n        return Ok({\n          component: 'payment',\n          isValid: false,\n          errors: ['Payment method is required'],\n          warnings: []\n        });\n      }\n\n      // Validate payment method availability and constraints\n      const validation = await this.paymentService.validatePaymentMethod(\n        selectedMethod.id,\n        context.cart.totals.total,\n        context.cart.currency\n      );\n\n      if (isErr(validation)) {\n        return Err(unwrapErr(validation));\n      }\n\n      const result = unwrap(validation);\n      return Ok({\n        component: 'payment',\n        isValid: result.isValid,\n        errors: result.errors,\n        warnings: result.warnings,\n        metadata: { selectedMethod }\n      });\n\n    } catch (error) {\n      return Err(ErrorFactory.validationError(\n        'Payment method validation failed',\n        error\n      ));\n    }\n  }\n\n  /**\n   * Validate cart and stock availability\n   */\n  async validateCart(context: CheckoutValidationContext): Promise<Result<ValidationResult, WooError>> {\n    try {\n      const cart = context.cart;\n      const errors: string[] = [];\n      const warnings: string[] = [];\n\n      // Basic cart validation\n      if (cart.items.length === 0) {\n        errors.push('Cart is empty');\n      }\n\n      // Validate minimum order amount\n      if (context.validationRules.minimumOrderAmount && \n          cart.totals.total < context.validationRules.minimumOrderAmount) {\n        errors.push(`Minimum order amount is ${context.validationRules.minimumOrderAmount}`);\n      }\n\n      // Validate maximum order amount\n      if (context.validationRules.maximumOrderAmount && \n          cart.totals.total > context.validationRules.maximumOrderAmount) {\n        errors.push(`Maximum order amount is ${context.validationRules.maximumOrderAmount}`);\n      }\n\n      // Stock validation would be handled by existing cart validation\n      // This is a placeholder for additional cart-specific validation\n      \n      const isValid = errors.length === 0;\n\n      return Ok({\n        component: 'cart',\n        isValid,\n        errors,\n        warnings,\n        metadata: { \n          itemCount: cart.items.length,\n          total: cart.totals.total\n        }\n      });\n\n    } catch (error) {\n      return Err(ErrorFactory.validationError(\n        'Cart validation failed',\n        error\n      ));\n    }\n  }\n\n  /**\n   * Validate order totals consistency\n   */\n  async validateOrderTotals(context: CheckoutValidationContext): Promise<Result<ValidationResult, WooError>> {\n    try {\n      const totals = context.cart.totals;\n      const errors: string[] = [];\n      const warnings: string[] = [];\n\n      // Basic totals validation\n      if (totals.total < 0) {\n        errors.push('Order total cannot be negative');\n      }\n\n      if (totals.subtotal < 0) {\n        errors.push('Subtotal cannot be negative');\n      }\n\n      if (totals.tax < 0) {\n        errors.push('Tax amount cannot be negative');\n      }\n\n      // Validate total calculation\n      const calculatedTotal = totals.subtotal + totals.tax + totals.shipping + \n                             totals.shippingTax + totals.fees + totals.feesTax - \n                             totals.discount;\n\n      if (Math.abs(calculatedTotal - totals.total) > 0.01) {\n        errors.push('Order total calculation is inconsistent');\n      }\n\n      // Check for reasonable total amounts\n      if (totals.total > 100000) {\n        warnings.push('Order total is unusually high');\n      }\n\n      const isValid = errors.length === 0;\n\n      return Ok({\n        component: 'totals',\n        isValid,\n        errors,\n        warnings,\n        metadata: { \n          calculatedTotal,\n          actualTotal: totals.total\n        }\n      });\n\n    } catch (error) {\n      return Err(ErrorFactory.validationError(\n        'Order totals validation failed',\n        error\n      ));\n    }\n  }\n\n  /**\n   * Validate specific checkout step\n   */\n  async validateStep(\n    step: number,\n    context: CheckoutValidationContext\n  ): Promise<Result<CheckoutValidationResult, WooError>> {\n    try {\n      const validationResults: ValidationResult[] = [];\n\n      switch (step) {\n        case 1: // Address information\n          const billingResult = await this.validateBillingAddress(context);\n          if (isErr(billingResult)) return Err(unwrapErr(billingResult));\n          validationResults.push(unwrap(billingResult));\n\n          if (!context.checkoutSession.useShippingAsBilling) {\n            const shippingResult = await this.validateShippingAddress(context);\n            if (isErr(shippingResult)) return Err(unwrapErr(shippingResult));\n            validationResults.push(unwrap(shippingResult));\n          }\n          break;\n\n        case 2: // Shipping method\n          if (context.checkoutSession.selectedShippingMethod) {\n            const shippingResult = await this.validateShippingMethod(context);\n            if (isErr(shippingResult)) return Err(unwrapErr(shippingResult));\n            validationResults.push(unwrap(shippingResult));\n          }\n          break;\n\n        case 3: // Payment method\n          if (context.checkoutSession.selectedPaymentMethod) {\n            const paymentResult = await this.validatePaymentMethod(context);\n            if (isErr(paymentResult)) return Err(unwrapErr(paymentResult));\n            validationResults.push(unwrap(paymentResult));\n          }\n          break;\n\n        case 4: // Final review\n          return this.validateCheckout(context);\n\n        default:\n          return Err(ErrorFactory.validationError(\n            `Invalid checkout step: ${step}`\n          ));\n      }\n\n      const allValid = validationResults.every(result => result.isValid);\n      const criticalErrors = validationResults.flatMap(r => r.errors);\n      const warnings = validationResults.flatMap(r => r.warnings);\n\n      return Ok({\n        isValid: allValid,\n        canProceed: allValid,\n        validationResults,\n        criticalErrors,\n        warnings,\n        blockers: allValid ? [] : ['Step validation failed'],\n        recommendations: []\n      });\n\n    } catch (error) {\n      return Err(ErrorFactory.validationError(\n        'Step validation failed',\n        error\n      ));\n    }\n  }\n\n  /**\n   * Quick validation for specific fields\n   */\n  async validateField(\n    fieldName: string,\n    value: unknown,\n    context: CheckoutValidationContext\n  ): Promise<Result<ValidationResult, WooError>> {\n    try {\n      const errors: string[] = [];\n      const warnings: string[] = [];\n\n      switch (fieldName) {\n        case 'email':\n          if (typeof value === 'string') {\n            const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n            if (!emailRegex.test(value)) {\n              errors.push('Invalid email format');\n            }\n          } else {\n            errors.push('Email must be a string');\n          }\n          break;\n\n        case 'phone':\n          if (typeof value === 'string' && value.length > 0) {\n            const phoneRegex = /^[\\+]?[\\d\\s\\-\\(\\)]+$/;\n            if (!phoneRegex.test(value)) {\n              errors.push('Invalid phone number format');\n            }\n          }\n          break;\n\n        case 'postcode':\n          if (typeof value === 'string' && value.length > 0) {\n            const billingCountry = context.checkoutSession.billingAddress?.country;\n            if (billingCountry) {\n              const countryConfig = this.addressManager.getCountryConfig(billingCountry);\n              if (countryConfig?.postcodePattern) {\n                const regex = new RegExp(countryConfig.postcodePattern);\n                if (!regex.test(value)) {\n                  errors.push(`Invalid postal code format for ${countryConfig.name}`);\n                }\n              }\n            }\n          }\n          break;\n\n        default:\n          return Err(ErrorFactory.validationError(\n            `Unknown field: ${fieldName}`\n          ));\n      }\n\n      return Ok({\n        component: 'address',\n        isValid: errors.length === 0,\n        errors,\n        warnings,\n        metadata: { fieldName, value }\n      });\n\n    } catch (error) {\n      return Err(ErrorFactory.validationError(\n        'Field validation failed',\n        error\n      ));\n    }\n  }\n\n  // Private helper methods\n\n  /**\n   * Generate recommendations based on validation results\n   */\n  private generateRecommendations(\n    validationResults: readonly ValidationResult[],\n    recommendations: string[]\n  ): void {\n    // Address recommendations\n    const addressResults = validationResults.filter(r => r.component === 'address');\n    if (addressResults.some(r => r.warnings.length > 0)) {\n      recommendations.push('Review address information for accuracy');\n    }\n\n    // Shipping recommendations\n    const shippingResults = validationResults.filter(r => r.component === 'shipping');\n    if (shippingResults.length > 0) {\n      recommendations.push('Consider different shipping options for better rates');\n    }\n\n    // Payment recommendations\n    const paymentResults = validationResults.filter(r => r.component === 'payment');\n    if (paymentResults.some(r => r.warnings.length > 0)) {\n      recommendations.push('Check payment method details');\n    }\n\n    // Cart recommendations\n    const cartResults = validationResults.filter(r => r.component === 'cart');\n    if (cartResults.some(r => r.warnings.length > 0)) {\n      recommendations.push('Review cart items and quantities');\n    }\n  }\n}\n\n/**\n * Validation rule builder for dynamic validation configuration\n */\nexport class ValidationRuleBuilder {\n  private rules: Partial<CheckoutValidationRules> = {};\n\n  /**\n   * Set minimum order amount\n   */\n  minimumOrderAmount(amount: number): ValidationRuleBuilder {\n    this.rules = { ...this.rules, minimumOrderAmount: amount };\n    return this;\n  }\n\n  /**\n   * Set maximum order amount\n   */\n  maximumOrderAmount(amount: number): ValidationRuleBuilder {\n    this.rules = { ...this.rules, maximumOrderAmount: amount };\n    return this;\n  }\n\n  /**\n   * Require email address\n   */\n  requireEmail(required: boolean = true): ValidationRuleBuilder {\n    this.rules = { ...this.rules, requireEmail: required };\n    return this;\n  }\n\n  /**\n   * Require phone number\n   */\n  requirePhoneNumber(required: boolean = true): ValidationRuleBuilder {\n    this.rules = { ...this.rules, requirePhoneNumber: required };\n    return this;\n  }\n\n  /**\n   * Require company name\n   */\n  requireCompanyName(required: boolean = true): ValidationRuleBuilder {\n    this.rules = { ...this.rules, requireCompanyName: required };\n    return this;\n  }\n\n  /**\n   * Set required fields\n   */\n  requiredFields(fields: string[]): ValidationRuleBuilder {\n    this.rules = { ...this.rules, requiredFields: fields };\n    return this;\n  }\n\n  /**\n   * Set return URL\n   */\n  returnUrl(url: string): ValidationRuleBuilder {\n    this.rules = { ...this.rules, returnUrl: url };\n    return this;\n  }\n\n  /**\n   * Set cancel URL\n   */\n  cancelUrl(url: string): ValidationRuleBuilder {\n    this.rules = { ...this.rules, cancelUrl: url };\n    return this;\n  }\n\n  /**\n   * Build the validation rules\n   */\n  build(): CheckoutValidationRules {\n    const rules: CheckoutValidationRules = {\n      requireShippingAddress: this.rules.requireShippingAddress ?? true,\n      requireBillingAddress: this.rules.requireBillingAddress ?? true,\n      requirePhoneNumber: this.rules.requirePhoneNumber ?? false,\n      requireCompanyName: this.rules.requireCompanyName ?? false,\n      allowGuestCheckout: this.rules.allowGuestCheckout ?? true,\n      restrictedCountries: this.rules.restrictedCountries ?? [],\n      requiredFields: this.rules.requiredFields ?? []\n    };\n\n    // Handle optional properties for exactOptionalPropertyTypes\n    if (this.rules.requireEmail !== undefined) {\n      (rules as any).requireEmail = this.rules.requireEmail;\n    }\n    if (this.rules.minimumOrderAmount !== undefined) {\n      (rules as any).minimumOrderAmount = this.rules.minimumOrderAmount;\n    }\n    if (this.rules.maximumOrderAmount !== undefined) {\n      (rules as any).maximumOrderAmount = this.rules.maximumOrderAmount;\n    }\n    if (this.rules.returnUrl !== undefined) {\n      (rules as any).returnUrl = this.rules.returnUrl;\n    }\n    if (this.rules.cancelUrl !== undefined) {\n      (rules as any).cancelUrl = this.rules.cancelUrl;\n    }\n\n    return rules;\n  }\n}\n\n/**\n * Create validation rule builder\n */\nexport function createValidationRules(): ValidationRuleBuilder {\n  return new ValidationRuleBuilder();\n} ","/**\n * Checkout Flow Management System for WooCommerce Headless SDK\n * Multi-step checkout process coordination with state management\n * Following the Enhanced Unified 10X Developer Framework\n */\n\nimport { Result, Ok, Err, isErr, isOk, unwrap, unwrapErr } from '../../types/result';\nimport { WooError, ErrorFactory } from '../../types/errors';\nimport { \n  CheckoutStep,\n  CheckoutStepType,\n  CheckoutSession,\n  CheckoutValidationRules,\n  Order\n} from '../../types/checkout';\nimport { Cart } from '../../types/cart';\nimport { AddressManager } from './address';\nimport { ShippingService } from './shipping';\nimport { PaymentService } from './payment';\nimport { CheckoutValidationService, CheckoutValidationContext, CheckoutValidationResult } from './validation';\n\n/**\n * Checkout flow state\n */\nexport interface CheckoutFlowState {\n  readonly currentStep: number;\n  readonly completedSteps: readonly number[];\n  readonly availableSteps: readonly CheckoutStep[];\n  readonly canProceed: boolean;\n  readonly canGoBack: boolean;\n  readonly session: CheckoutSession;\n  readonly validationResult?: CheckoutValidationResult;\n}\n\n/**\n * Step transition result\n */\nexport interface StepTransitionResult {\n  readonly success: boolean;\n  readonly newStep: number;\n  readonly previousStep: number;\n  readonly validationResult?: CheckoutValidationResult;\n  readonly errors: readonly string[];\n  readonly blockers: readonly string[];\n}\n\n/**\n * Checkout completion result\n */\nexport interface CheckoutCompletionResult {\n  readonly success: boolean;\n  readonly order?: Order;\n  readonly paymentRedirectUrl?: string;\n  readonly requiresPaymentAction: boolean;\n  readonly errors: readonly string[];\n}\n\n/**\n * Checkout flow configuration\n */\nexport interface CheckoutFlowConfig {\n  readonly steps: readonly CheckoutStepType[];\n  readonly allowSkipOptional: boolean;\n  readonly persistSession: boolean;\n  readonly sessionTimeout: number; // in minutes\n  readonly autoAdvance: boolean;\n  readonly validationRules: CheckoutValidationRules;\n}\n\n/**\n * Checkout flow event handlers\n */\nexport interface CheckoutFlowEventHandlers {\n  onStepChange?: (currentStep: number, previousStep: number) => void;\n  onStepComplete?: (step: number) => void;\n  onValidationError?: (errors: readonly string[]) => void;\n  onCheckoutComplete?: (order: Order) => void;\n  onCheckoutError?: (error: WooError) => void;\n}\n\n/**\n * Comprehensive checkout flow manager\n */\nexport class CheckoutFlowManager {\n  private readonly paymentService: PaymentService;\n  private readonly validationService: CheckoutValidationService;\n  private readonly config: CheckoutFlowConfig;\n  private readonly eventHandlers: CheckoutFlowEventHandlers;\n  \n  private flowState: CheckoutFlowState;\n  private sessionId: string;\n\n  constructor(\n    addressManager: AddressManager,\n    shippingService: ShippingService,\n    paymentService: PaymentService,\n    validationService: CheckoutValidationService,\n    config: CheckoutFlowConfig,\n    eventHandlers: CheckoutFlowEventHandlers = {}\n  ) {\n    // Store only the services we actually use\n    this.paymentService = paymentService;\n    this.validationService = validationService;\n    this.config = config;\n    this.eventHandlers = eventHandlers;\n    \n    this.sessionId = this.generateSessionId();\n    this.flowState = this.initializeFlowState();\n  }\n\n  /**\n   * Initialize checkout flow with cart\n   */\n  async initializeCheckout(cart: Cart, isGuestCheckout: boolean = false): Promise<Result<CheckoutFlowState, WooError>> {\n    try {\n      // Create initial checkout session\n      const session: CheckoutSession = {\n        id: this.sessionId,\n        cartId: cart.id,\n        isGuestCheckout,\n        orderTotals: cart.totals,\n        flow: createEmptyCheckoutFlow(),\n        expiresAt: new Date(Date.now() + this.config.sessionTimeout * 60 * 1000),\n        createdAt: new Date(),\n        updatedAt: new Date()\n      };\n\n      // Initialize flow state\n      this.flowState = {\n        currentStep: 1,\n        completedSteps: [],\n        availableSteps: this.buildAvailableSteps(cart),\n        canProceed: false,\n        canGoBack: false,\n        session\n      };\n\n      // Persist session if configured\n      if (this.config.persistSession) {\n        await this.persistSession();\n      }\n\n      return Ok(this.flowState);\n\n    } catch (error) {\n      return Err(ErrorFactory.validationError(\n        'Failed to initialize checkout flow',\n        error\n      ));\n    }\n  }\n\n  /**\n   * Move to next step\n   */\n  async nextStep(cart: Cart): Promise<Result<StepTransitionResult, WooError>> {\n    try {\n      const currentStep = this.flowState.currentStep;\n      \n      // Validate current step before proceeding\n      const validationResult = await this.validateCurrentStep(cart);\n      if (isErr(validationResult)) {\n        return Err(unwrapErr(validationResult));\n      }\n\n      const validation = unwrap(validationResult);\n      if (!validation.canProceed) {\n        return Ok({\n          success: false,\n          newStep: currentStep,\n          previousStep: currentStep,\n          validationResult: validation,\n          errors: validation.criticalErrors,\n          blockers: validation.blockers\n        });\n      }\n\n      // Move to next step\n      const nextStep = currentStep + 1;\n      const maxStep = this.flowState.availableSteps.length;\n\n      if (nextStep > maxStep) {\n        // Attempt to complete checkout\n        return this.completeCheckout(cart);\n      }\n\n      // Update flow state\n      const previousStep = this.flowState.currentStep;\n      this.flowState = {\n        ...this.flowState,\n        currentStep: nextStep,\n        completedSteps: [...this.flowState.completedSteps, currentStep],\n        canProceed: false, // Will be determined by validation\n        canGoBack: true,\n        validationResult: validation\n      };\n\n      // Persist state\n      if (this.config.persistSession) {\n        await this.persistSession();\n      }\n\n      // Trigger events\n      this.eventHandlers.onStepChange?.(nextStep, previousStep);\n      this.eventHandlers.onStepComplete?.(currentStep);\n\n      return Ok({\n        success: true,\n        newStep: nextStep,\n        previousStep,\n        validationResult: validation,\n        errors: [],\n        blockers: []\n      });\n\n    } catch (error) {\n      return Err(ErrorFactory.validationError(\n        'Failed to advance to next step',\n        error\n      ));\n    }\n  }\n\n  /**\n   * Move to previous step\n   */\n  async previousStep(): Promise<Result<StepTransitionResult, WooError>> {\n    try {\n      const currentStep = this.flowState.currentStep;\n      \n      if (currentStep <= 1 || !this.flowState.canGoBack) {\n        return Err(ErrorFactory.validationError(\n          'Cannot go back from current step'\n        ));\n      }\n\n      const previousStep = currentStep - 1;\n      \n      // Update flow state\n      this.flowState = {\n        ...this.flowState,\n        currentStep: previousStep,\n        completedSteps: this.flowState.completedSteps.filter(step => step !== currentStep),\n        canProceed: true, // Previous steps were valid\n        canGoBack: previousStep > 1\n      };\n\n      // Persist state\n      if (this.config.persistSession) {\n        await this.persistSession();\n      }\n\n      // Trigger event\n      this.eventHandlers.onStepChange?.(previousStep, currentStep);\n\n      return Ok({\n        success: true,\n        newStep: previousStep,\n        previousStep: currentStep,\n        errors: [],\n        blockers: []\n      });\n\n    } catch (error) {\n      return Err(ErrorFactory.validationError(\n        'Failed to go back to previous step',\n        error\n      ));\n    }\n  }\n\n  /**\n   * Jump to specific step\n   */\n  async goToStep(targetStep: number, cart: Cart): Promise<Result<StepTransitionResult, WooError>> {\n    try {\n      const currentStep = this.flowState.currentStep;\n      \n      if (targetStep < 1 || targetStep > this.flowState.availableSteps.length) {\n        return Err(ErrorFactory.validationError(\n          `Invalid step: ${targetStep}`\n        ));\n      }\n\n      // If going forward, validate all steps in between\n      if (targetStep > currentStep) {\n        for (let step = currentStep; step < targetStep; step++) {\n          const validationResult = await this.validateStep(step, cart);\n          if (isErr(validationResult)) {\n            return Err(unwrapErr(validationResult));\n          }\n\n          const validation = unwrap(validationResult);\n          if (!validation.canProceed) {\n            return Ok({\n              success: false,\n              newStep: step,\n              previousStep: currentStep,\n              validationResult: validation,\n              errors: validation.criticalErrors,\n              blockers: validation.blockers\n            });\n          }\n        }\n      }\n\n      // Update flow state\n      this.flowState = {\n        ...this.flowState,\n        currentStep: targetStep,\n        completedSteps: targetStep > currentStep \n          ? [...this.flowState.completedSteps, ...Array.from({ length: targetStep - currentStep }, (_, i) => currentStep + i)]\n          : this.flowState.completedSteps.filter(step => step < targetStep),\n        canGoBack: targetStep > 1\n      };\n\n      // Persist state\n      if (this.config.persistSession) {\n        await this.persistSession();\n      }\n\n      // Trigger event\n      this.eventHandlers.onStepChange?.(targetStep, currentStep);\n\n      return Ok({\n        success: true,\n        newStep: targetStep,\n        previousStep: currentStep,\n        errors: [],\n        blockers: []\n      });\n\n    } catch (error) {\n      return Err(ErrorFactory.validationError(\n        'Failed to jump to step',\n        error\n      ));\n    }\n  }\n\n  /**\n   * Update checkout session data\n   */\n  async updateSession(updates: Partial<CheckoutSession>, cart: Cart): Promise<Result<CheckoutFlowState, WooError>> {\n    try {\n      // Update session\n      this.flowState = {\n        ...this.flowState,\n        session: {\n          ...this.flowState.session,\n          ...updates,\n          updatedAt: new Date()\n        }\n      };\n\n      // Re-validate current step with new data\n      const validationResult = await this.validateCurrentStep(cart);\n      if (isOk(validationResult)) {\n        const validation = unwrap(validationResult);\n        this.flowState = {\n          ...this.flowState,\n          canProceed: validation.canProceed,\n          validationResult: validation\n        };\n      }\n\n      // Persist state\n      if (this.config.persistSession) {\n        await this.persistSession();\n      }\n\n      return Ok(this.flowState);\n\n    } catch (error) {\n      return Err(ErrorFactory.validationError(\n        'Failed to update checkout session',\n        error\n      ));\n    }\n  }\n\n  /**\n   * Validate current step\n   */\n  async validateCurrentStep(cart: Cart): Promise<Result<CheckoutValidationResult, WooError>> {\n    return this.validateStep(this.flowState.currentStep, cart);\n  }\n\n  /**\n   * Validate specific step\n   */\n  async validateStep(step: number, cart: Cart): Promise<Result<CheckoutValidationResult, WooError>> {\n    try {\n      const context: CheckoutValidationContext = {\n        checkoutSession: this.flowState.session,\n        cart,\n        validationRules: this.config.validationRules,\n        isGuestCheckout: this.flowState.session.isGuestCheckout ?? false,\n        currentStep: step,\n        skipOptionalValidations: this.config.allowSkipOptional\n      };\n\n      return this.validationService.validateStep(step, context);\n\n    } catch (error) {\n      return Err(ErrorFactory.validationError(\n        'Step validation failed',\n        error\n      ));\n    }\n  }\n\n  /**\n   * Complete checkout and create order\n   */\n  async completeCheckout(cart: Cart): Promise<Result<StepTransitionResult, WooError>> {\n    try {\n      // Final validation of entire checkout\n      const context: CheckoutValidationContext = {\n        checkoutSession: this.flowState.session,\n        cart,\n        validationRules: this.config.validationRules,\n        isGuestCheckout: this.flowState.session.isGuestCheckout ?? false,\n        currentStep: this.flowState.currentStep\n      };\n\n      const validationResult = await this.validationService.validateCheckout(context);\n      if (isErr(validationResult)) {\n        return Err(unwrapErr(validationResult));\n      }\n\n      const validation = unwrap(validationResult);\n      if (!validation.canProceed) {\n        this.eventHandlers.onValidationError?.(validation.criticalErrors);\n        return Ok({\n          success: false,\n          newStep: this.flowState.currentStep,\n          previousStep: this.flowState.currentStep,\n          validationResult: validation,\n          errors: validation.criticalErrors,\n          blockers: validation.blockers\n        });\n      }\n\n      // Create order (this would integrate with order processing service)\n      const order = await this.createOrder(cart);\n      if (isErr(order)) {\n        return Err(unwrapErr(order));\n      }\n\n      const createdOrder = unwrap(order);\n\n      // Initialize payment if required\n      if (this.flowState.session.selectedPaymentMethod) {\n        const paymentInit = await this.initializePayment(createdOrder);\n        if (isOk(paymentInit)) {\n          const payment = unwrap(paymentInit);\n          return Ok({\n            success: true,\n            orderId: createdOrder.id.toString(),\n            redirectUrl: payment.redirectUrl,\n            paymentStatus: 'pending',\n            requiresRedirect: payment.requiresRedirect,\n            clientSecret: payment.clientSecret,\n            paymentIntentId: payment.paymentIntentId\n          });\n        }\n      }\n\n      // Mark checkout as complete\n      this.flowState = {\n        ...this.flowState,\n        currentStep: this.flowState.availableSteps.length + 1,\n        completedSteps: [...this.flowState.completedSteps, this.flowState.currentStep],\n        canProceed: false,\n        canGoBack: false\n      };\n\n      // Trigger completion event\n      this.eventHandlers.onCheckoutComplete?.(createdOrder);\n\n      return Ok({\n        success: true,\n        newStep: this.flowState.currentStep,\n        previousStep: this.flowState.currentStep - 1,\n        errors: [],\n        blockers: []\n      });\n\n    } catch (error) {\n      const woError = ErrorFactory.validationError(\n        'Checkout completion failed',\n        error\n      );\n      this.eventHandlers.onCheckoutError?.(woError);\n      return Err(woError);\n    }\n  }\n\n  /**\n   * Get current flow state\n   */\n  getFlowState(): CheckoutFlowState {\n    return this.flowState;\n  }\n\n  /**\n   * Get current step information\n   */\n  getCurrentStep(): CheckoutStep | null {\n    const stepIndex = this.flowState.currentStep - 1;\n    return this.flowState.availableSteps[stepIndex] || null;\n  }\n\n  /**\n   * Check if step is completed\n   */\n  isStepCompleted(step: number): boolean {\n    return this.flowState.completedSteps.includes(step);\n  }\n\n  /**\n   * Reset checkout flow\n   */\n  async resetFlow(): Promise<Result<void, WooError>> {\n    try {\n      this.flowState = this.initializeFlowState();\n      this.sessionId = this.generateSessionId();\n      \n      if (this.config.persistSession) {\n        await this.clearPersistedSession();\n      }\n\n      return Ok(undefined);\n\n    } catch (error) {\n      return Err(ErrorFactory.validationError(\n        'Failed to reset checkout flow',\n        error\n      ));\n    }\n  }\n\n  // Private helper methods\n\n  /**\n   * Initialize empty flow state\n   */\n  private initializeFlowState(): CheckoutFlowState {\n    return {\n      currentStep: 1,\n      completedSteps: [],\n      availableSteps: [],\n      canProceed: false,\n      canGoBack: false,\n      session: {\n        id: this.sessionId,\n        cartId: '',\n        isGuestCheckout: false,\n        useShippingAsBilling: true,\n        orderNotes: '',\n        termsAccepted: false,\n        newsletterOptIn: false,\n        orderTotals: {\n          subtotal: 0,\n          tax: 0,\n          shipping: 0,\n          shippingTax: 0,\n          discount: 0,\n          fees: 0,\n          feesTax: 0,\n          total: 0,\n          currency: 'USD'\n        },\n        flow: {\n          steps: [],\n          currentStep: 'cart_review',\n          canProceed: false,\n          canGoBack: false,\n          progress: {\n            current: 1,\n            total: 4,\n            percentage: 25\n          }\n        },\n        expiresAt: new Date(Date.now() + 60 * 60 * 1000), // 1 hour\n        createdAt: new Date(),\n        updatedAt: new Date()\n      }\n    };\n  }\n\n  /**\n   * Build available steps based on cart contents\n   */\n  private buildAvailableSteps(cart: Cart): CheckoutStep[] {\n    const steps: CheckoutStep[] = [];\n\n    // Always include address step\n    steps.push({\n      type: 'address',\n      title: 'Billing & Shipping',\n      description: 'Enter your billing and shipping information',\n      completed: false,\n      valid: false,\n      errors: []\n    });\n\n    // Add shipping step if cart has physical items (simplified check without item.type)\n    const hasPhysicalItems = cart.items.length > 0; // Simplified - assume physical items need shipping\n    \n    if (hasPhysicalItems) {\n      steps.push({\n        type: 'shipping',\n        title: 'Shipping Method',\n        description: 'Choose your shipping method',\n        completed: false,\n        valid: false,\n        errors: []\n      });\n    }\n\n    // Always include payment step\n    steps.push({\n      type: 'payment',\n      title: 'Payment',\n      description: 'Choose your payment method',\n      completed: false,\n      valid: false,\n      errors: []\n    });\n\n    // Add review step\n    steps.push({\n      type: 'review',\n      title: 'Review Order',\n      description: 'Review your order before placing it',\n      completed: false,\n      valid: false,\n      errors: []\n    });\n\n    return steps;\n  }\n\n  /**\n   * Create order (placeholder - would integrate with order service)\n   */\n  private async createOrder(cart: Cart): Promise<Result<Order, WooError>> {\n    try {\n      // This would integrate with the order processing service\n      // For now, return a mock order\n      const order: Order = {\n        id: this.generateOrderId(),\n        number: `ORDER-${Date.now()}`,\n        status: 'pending',\n        currency: cart.currency,\n        total: cart.totals.total,\n        subtotal: cart.totals.subtotal,\n        totalTax: cart.totals.tax,\n        shippingTotal: cart.totals.shipping,\n        shippingTax: cart.totals.shippingTax,\n        discountTotal: cart.totals.discount,\n        feeTotal: cart.totals.fees,\n        feeTax: cart.totals.feeTax,\n        billingAddress: this.flowState.session.billingAddress!,\n        shippingAddress: this.flowState.session.useShippingAsBilling \n          ? this.flowState.session.billingAddress!\n          : this.flowState.session.shippingAddress!,\n        paymentMethod: this.flowState.session.selectedPaymentMethod?.id || '',\n        shippingMethod: this.flowState.session.selectedShippingMethod?.methodId || '',\n        orderNotes: this.flowState.session.orderNotes,\n        lineItems: cart.items.map((item, index) => ({\n          id: index + 1, // Use index as numeric ID\n          productId: item.productId,\n          variationId: item.variationId,\n          quantity: item.quantity,\n          price: item.price,\n          total: item.total,\n          subtotal: item.price * item.quantity,\n          totalTax: 0, // Default to 0 - would be calculated properly in real implementation\n          subtotalTax: 0, // Default to 0 - would be calculated properly in real implementation\n          name: item.name,\n          sku: item.sku,\n          meta: [] // Empty meta array for now\n        })),\n        createdAt: new Date(),\n        updatedAt: new Date()\n      };\n\n      return Ok(order);\n\n    } catch (error) {\n      return Err(ErrorFactory.apiError(\n        'Order creation failed',\n        500,\n        error\n      ));\n    }\n  }\n\n  /**\n   * Initialize payment for order\n   */\n  private async initializePayment(order: Order): Promise<Result<{ redirectUrl?: string }, WooError>> {\n    try {\n      if (!this.flowState.session.selectedPaymentMethod) {\n        return Ok({});\n      }\n\n      const paymentRequest = {\n        paymentMethodId: this.flowState.session.selectedPaymentMethod.id,\n        orderId: order.id,\n        amount: order.total,\n        currency: order.currency,\n        returnUrl: this.config.validationRules.returnUrl || '/checkout/success',\n        cancelUrl: this.config.validationRules.cancelUrl || '/checkout/cancel'\n      };\n\n      const result = await this.paymentService.initializePayment(paymentRequest);\n      if (isErr(result)) {\n        return Err(unwrapErr(result));\n      }\n\n      const payment = unwrap(result);\n      return Ok({\n        redirectUrl: payment.redirectUrl\n      });\n\n    } catch (error) {\n      return Err(ErrorFactory.apiError(\n        'Payment initialization failed',\n        500,\n        error\n      ));\n    }\n  }\n\n  /**\n   * Persist session (placeholder implementation)\n   */\n  private async persistSession(): Promise<void> {\n    // This would integrate with session storage (localStorage, database, etc.)\n    // For now, just store in localStorage\n    if (typeof window !== 'undefined') {\n      localStorage.setItem(`woo-checkout-session-${this.sessionId}`, JSON.stringify(this.flowState));\n    }\n  }\n\n  /**\n   * Clear persisted session\n   */\n  private async clearPersistedSession(): Promise<void> {\n    if (typeof window !== 'undefined') {\n      localStorage.removeItem(`woo-checkout-session-${this.sessionId}`);\n    }\n  }\n\n  /**\n   * Generate session ID\n   */\n  private generateSessionId(): string {\n    return `checkout-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  /**\n   * Generate order ID\n   */\n  private generateOrderId(): number {\n    return Date.now(); // Simple numeric ID based on timestamp\n  }\n}\n\n/**\n * Default checkout flow configuration\n */\nexport const DEFAULT_CHECKOUT_FLOW_CONFIG: CheckoutFlowConfig = {\n  steps: ['address', 'shipping', 'payment', 'review'],\n  allowSkipOptional: false,\n  persistSession: true,\n  sessionTimeout: 30, // 30 minutes\n  autoAdvance: false,\n  validationRules: {\n    minimumOrderAmount: 0,\n    requireEmail: true,\n    requirePhoneNumber: false,\n    requireCompanyName: false,\n    requiredFields: []\n  }\n}; ","/**\n * Order Processing System for WooCommerce Headless SDK\n * Handles order creation, confirmation, status tracking, and inventory management\n * Following the Enhanced Unified 10X Developer Framework\n */\n\nimport { HttpClient } from '../../core/client';\nimport { CacheManager } from '../../core/cache';\nimport { Result, Ok, Err, isErr, unwrap, unwrapErr } from '../../types/result';\nimport { WooError, ErrorFactory } from '../../types/errors';\nimport { \n  Order,\n  OrderStatus,\n  CheckoutSession,\n  BillingAddress,\n  ShippingAddress\n} from '../../types/checkout';\nimport { Cart } from '../../types/cart';\n\n/**\n * Order creation request\n */\nexport interface OrderCreateRequest {\n  readonly cart: Cart;\n  readonly checkoutSession: CheckoutSession;\n  readonly customerNotes?: string;\n  readonly metadata?: Record<string, unknown>;\n}\n\n/**\n * Order creation response\n */\nexport interface OrderCreateResponse {\n  readonly order: Order;\n  readonly requiresPayment: boolean;\n  readonly paymentUrl?: string;\n  readonly confirmationUrl: string;\n}\n\n/**\n * Order confirmation request\n */\nexport interface OrderConfirmationRequest {\n  readonly orderId: string;\n  readonly paymentId?: string;\n  readonly transactionId?: string;\n  readonly paymentStatus?: 'completed' | 'failed' | 'pending';\n}\n\n/**\n * Order status update request\n */\nexport interface OrderStatusUpdateRequest {\n  readonly orderId: string;\n  readonly status: OrderStatus;\n  readonly note?: string;\n  readonly notifyCustomer?: boolean;\n}\n\n/**\n * Inventory update request\n */\nexport interface InventoryUpdateRequest {\n  readonly orderId: string;\n  readonly items: readonly {\n    readonly productId: number;\n    readonly variationId?: number;\n    readonly quantity: number;\n    readonly operation: 'decrease' | 'increase' | 'reserve';\n  }[];\n}\n\n/**\n * Order search criteria\n */\nexport interface OrderSearchCriteria {\n  readonly status?: OrderStatus;\n  readonly customerId?: string;\n  readonly customerEmail?: string;\n  readonly dateFrom?: Date;\n  readonly dateTo?: Date;\n  readonly minAmount?: number;\n  readonly maxAmount?: number;\n  readonly paymentMethod?: string;\n  readonly limit?: number;\n  readonly offset?: number;\n}\n\n/**\n * Order processing configuration\n */\nexport interface OrderProcessingConfig {\n  readonly autoUpdateInventory: boolean;\n  readonly sendConfirmationEmail: boolean;\n  readonly requirePaymentConfirmation: boolean;\n  readonly orderNumberPrefix: string;\n  readonly orderNumberSuffix?: string;\n  readonly defaultStatus: OrderStatus;\n  readonly inventoryHoldMinutes: number;\n  readonly cacheTimeout: number;\n}\n\n/**\n * Order processing service for backend integration\n */\nexport class OrderProcessingService {\n  private readonly client: HttpClient;\n  private readonly cache: CacheManager;\n  private readonly config: OrderProcessingConfig;\n\n  constructor(\n    client: HttpClient,\n    cache: CacheManager,\n    config: OrderProcessingConfig\n  ) {\n    this.client = client;\n    this.cache = cache;\n    this.config = config;\n  }\n\n  /**\n   * Create new order from checkout session\n   */\n  async createOrder(request: OrderCreateRequest): Promise<Result<OrderCreateResponse, WooError>> {\n    try {\n      // Validate cart and checkout session\n      const validationResult = await this.validateOrderCreation(request);\n      if (isErr(validationResult)) {\n        return Err(unwrapErr(validationResult));\n      }\n\n      // Reserve inventory if configured\n      if (this.config.autoUpdateInventory) {\n        const inventoryResult = await this.reserveInventory(request.cart);\n        if (isErr(inventoryResult)) {\n          return Err(unwrapErr(inventoryResult));\n        }\n      }\n\n      // Create order with backend\n      const orderData = this.buildOrderData(request);\n      const response = await this.client.post('/wp-json/wc/v3/orders', orderData);\n\n      if (isErr(response)) {\n        // Release reserved inventory on failure\n        if (this.config.autoUpdateInventory) {\n          await this.releaseInventory(request.cart);\n        }\n        return Err(unwrapErr(response));\n      }\n\n      const data = unwrap(response).data as any;\n      const order = this.mapOrderResponse(data);\n\n      // Update inventory\n      if (this.config.autoUpdateInventory) {\n        await this.updateInventory({\n          orderId: order.id.toString(),\n          items: request.cart.items.map(item => ({\n            productId: item.productId,\n            variationId: item.variationId,\n            quantity: item.quantity,\n            operation: 'decrease'\n          }))\n        });\n      }\n\n      // Cache the order\n      await this.cache.set(`order:${order.id}`, order, this.config.cacheTimeout * 60);\n\n      const orderResponse: OrderCreateResponse = {\n        order,\n        requiresPayment: order.total > 0 && order.status === 'pending',\n        paymentUrl: data.payment_url,\n        confirmationUrl: `/order-confirmation/${order.id}`\n      };\n\n      return Ok(orderResponse);\n\n    } catch (error) {\n      return Err(ErrorFactory.apiError(\n        'Order creation failed',\n        500,\n        error\n      ));\n    }\n  }\n\n  /**\n   * Get order by ID\n   */\n  async getOrder(orderId: string): Promise<Result<Order, WooError>> {\n    try {\n      // Check cache first\n      const cached = await this.cache.get<Order>(`order:${orderId}`);\n      if (cached.success && cached.data) {\n        return Ok(cached.data);\n      }\n\n      // Fetch from backend\n      const response = await this.client.get(`/wp-json/wc/v3/orders/${orderId}`);\n\n      if (isErr(response)) {\n        return Err(unwrapErr(response));\n      }\n\n      const data = unwrap(response).data as any;\n      const order = this.mapOrderResponse(data);\n\n      // Cache the order\n      await this.cache.set(`order:${orderId}`, order, this.config.cacheTimeout * 60);\n\n      return Ok(order);\n\n    } catch (error) {\n      return Err(ErrorFactory.apiError(\n        'Failed to fetch order',\n        500,\n        error\n      ));\n    }\n  }\n\n  /**\n   * Update order status\n   */\n  async updateOrderStatus(request: OrderStatusUpdateRequest): Promise<Result<Order, WooError>> {\n    try {\n      const response = await this.client.put(`/wp-json/wc/v3/orders/${request.orderId}`, {\n        status: request.status,\n        customer_note: request.note,\n        notify_customer: request.notifyCustomer || false\n      });\n\n      if (isErr(response)) {\n        return Err(unwrapErr(response));\n      }\n\n      const data = unwrap(response).data as any;\n      const order = this.mapOrderResponse(data);\n\n      // Update cache\n      await this.cache.set(`order:${order.id}`, order, this.config.cacheTimeout * 60);\n\n      return Ok(order);\n\n    } catch (error) {\n      return Err(ErrorFactory.apiError(\n        'Failed to update order status',\n        500,\n        error\n      ));\n    }\n  }\n\n  /**\n   * Confirm order completion\n   */\n  async confirmOrder(request: OrderConfirmationRequest): Promise<Result<Order, WooError>> {\n    try {\n      // Get current order\n      const orderResult = await this.getOrder(request.orderId);\n      if (isErr(orderResult)) {\n        return Err(unwrapErr(orderResult));\n      }\n\n      const order = unwrap(orderResult);\n\n      // Update order with confirmation details\n      const updateData: any = {\n        status: 'processing',\n        transaction_id: request.transactionId,\n        date_paid: new Date().toISOString()\n      };\n\n      if (request.paymentStatus) {\n        updateData.payment_status = request.paymentStatus;\n      }\n\n      const response = await this.client.put(`/wp-json/wc/v3/orders/${request.orderId}`, updateData);\n\n      if (isErr(response)) {\n        return Err(unwrapErr(response));\n      }\n\n      const data = unwrap(response).data as any;\n      const confirmedOrder = this.mapOrderResponse(data);\n\n      // Update cache\n      await this.cache.set(`order:${confirmedOrder.id}`, confirmedOrder, this.config.cacheTimeout * 60);\n\n      // Send confirmation email if configured\n      if (this.config.sendConfirmationEmail) {\n        await this.sendOrderConfirmationEmail(confirmedOrder);\n      }\n\n      return Ok(confirmedOrder);\n\n    } catch (error) {\n      return Err(ErrorFactory.apiError(\n        'Order confirmation failed',\n        500,\n        error\n      ));\n    }\n  }\n\n  /**\n   * Cancel order\n   */\n  async cancelOrder(orderId: string, reason?: string): Promise<Result<Order, WooError>> {\n    try {\n      // Get current order\n      const orderResult = await this.getOrder(orderId);\n      if (isErr(orderResult)) {\n        return Err(unwrapErr(orderResult));\n      }\n\n      const order = unwrap(orderResult);\n\n      // Only allow cancellation of pending/processing orders\n      if (!['pending', 'processing', 'on-hold'].includes(order.status)) {\n        return Err(ErrorFactory.validationError(\n          `Cannot cancel order with status: ${order.status}`\n        ));\n      }\n\n      // Update order status to cancelled\n      const response = await this.client.put(`/wp-json/wc/v3/orders/${orderId}`, {\n        status: 'cancelled',\n        customer_note: reason || 'Order cancelled by customer'\n      });\n\n      if (isErr(response)) {\n        return Err(unwrapErr(response));\n      }\n\n      const data = unwrap(response).data as any;\n      const cancelledOrder = this.mapOrderResponse(data);\n\n      // Restore inventory if configured\n      if (this.config.autoUpdateInventory) {\n        await this.updateInventory({\n          orderId: cancelledOrder.id,\n          items: cancelledOrder.lineItems.map(item => ({\n            productId: item.productId,\n            variationId: item.variationId,\n            quantity: item.quantity,\n            operation: 'increase'\n          }))\n        });\n      }\n\n      // Update cache\n      await this.cache.set(`order:${cancelledOrder.id}`, cancelledOrder, this.config.cacheTimeout * 60);\n\n      return Ok(cancelledOrder);\n\n    } catch (error) {\n      return Err(ErrorFactory.apiError(\n        'Order cancellation failed',\n        500,\n        error\n      ));\n    }\n  }\n\n  /**\n   * Search orders by criteria\n   */\n  async searchOrders(criteria: OrderSearchCriteria): Promise<Result<Order[], WooError>> {\n    try {\n      const params: Record<string, string> = {};\n\n      if (criteria.status) params.status = criteria.status;\n      if (criteria.customerId) params.customer = criteria.customerId;\n      if (criteria.customerEmail) params.customer_email = criteria.customerEmail;\n      if (criteria.dateFrom) params.after = criteria.dateFrom.toISOString();\n      if (criteria.dateTo) params.before = criteria.dateTo.toISOString();\n      if (criteria.paymentMethod) params.payment_method = criteria.paymentMethod;\n      if (criteria.limit) params.per_page = criteria.limit.toString();\n      if (criteria.offset) params.offset = criteria.offset.toString();\n\n      const response = await this.client.get('/wp-json/wc/v3/orders', params);\n\n      if (isErr(response)) {\n        return Err(unwrapErr(response));\n      }\n\n      const data = unwrap(response).data as any[];\n      const orders = data.map(orderData => this.mapOrderResponse(orderData));\n\n      // Filter by amount if specified\n      let filteredOrders = orders;\n      if (criteria.minAmount || criteria.maxAmount) {\n        filteredOrders = orders.filter(order => {\n          if (criteria.minAmount && order.total < criteria.minAmount) return false;\n          if (criteria.maxAmount && order.total > criteria.maxAmount) return false;\n          return true;\n        });\n      }\n\n      return Ok(filteredOrders);\n\n    } catch (error) {\n      return Err(ErrorFactory.apiError(\n        'Order search failed',\n        500,\n        error\n      ));\n    }\n  }\n\n  /**\n   * Get order notes\n   */\n  async getOrderNotes(orderId: string): Promise<Result<string[], WooError>> {\n    try {\n      const response = await this.client.get(`/wp-json/wc/v3/orders/${orderId}/notes`);\n\n      if (isErr(response)) {\n        return Err(unwrapErr(response));\n      }\n\n      const data = unwrap(response).data as any[];\n      const notes = data.map(note => note.note);\n\n      return Ok(notes);\n\n    } catch (error) {\n      return Err(ErrorFactory.apiError(\n        'Failed to fetch order notes',\n        500,\n        error\n      ));\n    }\n  }\n\n  /**\n   * Add note to order\n   */\n  async addOrderNote(orderId: string, note: string, customerNote: boolean = false): Promise<Result<void, WooError>> {\n    try {\n      const response = await this.client.post(`/wp-json/wc/v3/orders/${orderId}/notes`, {\n        note,\n        customer_note: customerNote\n      });\n\n      if (isErr(response)) {\n        return Err(unwrapErr(response));\n      }\n\n      return Ok(undefined);\n\n    } catch (error) {\n      return Err(ErrorFactory.apiError(\n        'Failed to add order note',\n        500,\n        error\n      ));\n    }\n  }\n\n  /**\n   * Generate order number\n   */\n  generateOrderNumber(): string {\n    const timestamp = Date.now();\n    const random = Math.random().toString(36).substr(2, 4).toUpperCase();\n    return `${this.config.orderNumberPrefix}${timestamp}${random}${this.config.orderNumberSuffix || ''}`;\n  }\n\n  /**\n   * Validate order creation request\n   */\n  async validateOrderCreation(request: OrderCreateRequest): Promise<Result<void, WooError>> {\n    try {\n      const { cart, checkoutSession } = request;\n\n      // Validate cart\n      if (cart.items.length === 0) {\n        return Err(ErrorFactory.validationError('Cart is empty'));\n      }\n\n      if (cart.totals.total < 0) {\n        return Err(ErrorFactory.validationError('Order total cannot be negative'));\n      }\n\n      // Validate addresses\n      if (!checkoutSession.billingAddress) {\n        return Err(ErrorFactory.validationError('Billing address is required'));\n      }\n\n      if (!checkoutSession.useShippingAsBilling && !checkoutSession.shippingAddress) {\n        return Err(ErrorFactory.validationError('Shipping address is required'));\n      }\n\n      // Validate payment method for non-zero totals\n      if (cart.totals.total > 0 && !checkoutSession.selectedPaymentMethod) {\n        return Err(ErrorFactory.validationError('Payment method is required'));\n      }\n\n      // Validate terms acceptance\n      if (!checkoutSession.termsAccepted) {\n        return Err(ErrorFactory.validationError('Terms and conditions must be accepted'));\n      }\n\n      return Ok(undefined);\n\n    } catch (error) {\n      return Err(ErrorFactory.validationError(\n        'Order validation failed',\n        error\n      ));\n    }\n  }\n\n  // Private helper methods\n\n  /**\n   * Build order data for API request\n   */\n  private buildOrderData(request: OrderCreateRequest): any {\n    const { cart, checkoutSession } = request;\n\n    return {\n      payment_method: checkoutSession.selectedPaymentMethod?.id || '',\n      payment_method_title: checkoutSession.selectedPaymentMethod?.title || '',\n      set_paid: false,\n      billing: this.mapAddressForAPI(checkoutSession.billingAddress!),\n      shipping: checkoutSession.useShippingAsBilling \n        ? this.mapAddressForAPI(checkoutSession.billingAddress!)\n        : this.mapAddressForAPI(checkoutSession.shippingAddress!),\n      line_items: cart.items.map(item => ({\n        product_id: item.productId,\n        variation_id: item.variationId || 0,\n        quantity: item.quantity,\n        price: item.price,\n        total: item.total.toString()\n      })),\n      shipping_lines: checkoutSession.selectedShippingMethod ? [{\n        method_id: checkoutSession.selectedShippingMethod.methodId,\n        method_title: checkoutSession.selectedShippingMethod.title,\n        total: checkoutSession.selectedShippingMethod.cost.toString()\n      }] : [],\n      customer_note: checkoutSession.orderNotes || '',\n      status: this.config.defaultStatus,\n      currency: cart.currency,\n      customer_id: checkoutSession.isGuestCheckout ? 0 : undefined,\n      meta_data: [\n        {\n          key: '_woo_headless_checkout_session',\n          value: checkoutSession.id\n        },\n        {\n          key: '_woo_headless_created',\n          value: new Date().toISOString()\n        }\n      ]\n    };\n  }\n\n  /**\n   * Map address for API\n   */\n  private mapAddressForAPI(address: BillingAddress | ShippingAddress): any {\n    return {\n      first_name: address.firstName,\n      last_name: address.lastName,\n      company: address.company || '',\n      address_1: address.address1,\n      address_2: address.address2 || '',\n      city: address.city,\n      state: address.state,\n      postcode: address.postcode,\n      country: address.country,\n      email: address.email || '',\n      phone: address.phone || ''\n    };\n  }\n\n  /**\n   * Map order response from API\n   */\n  private mapOrderResponse(data: any): Order {\n    return {\n      id: data.id.toString(),\n      number: data.number,\n      status: data.status,\n      currency: data.currency,\n      total: parseFloat(data.total),\n      subtotal: parseFloat(data.line_items_subtotal || '0'),\n      totalTax: parseFloat(data.total_tax),\n      shippingTotal: parseFloat(data.shipping_total),\n      shippingTax: parseFloat(data.shipping_tax),\n      discountTotal: parseFloat(data.discount_total),\n      feeTotal: parseFloat(data.fee_total || '0'),\n      feeTax: parseFloat(data.fee_tax || '0'),\n      billingAddress: this.mapAddressFromAPI(data.billing),\n      shippingAddress: this.mapAddressFromAPI(data.shipping),\n      paymentMethod: data.payment_method,\n      shippingMethod: data.shipping_lines[0]?.method_id || '',\n      orderNotes: data.customer_note || '',\n      lineItems: data.line_items.map((item: any) => ({\n        id: item.id.toString(),\n        productId: item.product_id,\n        variationId: item.variation_id || undefined,\n        quantity: item.quantity,\n        price: parseFloat(item.price),\n        total: parseFloat(item.total),\n        name: item.name,\n        sku: item.sku || ''\n      })),\n      createdAt: new Date(data.date_created),\n      updatedAt: new Date(data.date_modified)\n    };\n  }\n\n  /**\n   * Map address from API response\n   */\n  private mapAddressFromAPI(data: any): BillingAddress {\n    return {\n      firstName: data.first_name,\n      lastName: data.last_name,\n      company: data.company,\n      address1: data.address_1,\n      address2: data.address_2,\n      city: data.city,\n      state: data.state,\n      postcode: data.postcode,\n      country: data.country,\n      email: data.email,\n      phone: data.phone\n    };\n  }\n\n  /**\n   * Reserve inventory for cart items\n   */\n  private async reserveInventory(cart: Cart): Promise<Result<void, WooError>> {\n    try {\n      // This would implement inventory reservation logic\n      // For now, return success as placeholder\n      return Ok(undefined);\n    } catch (error) {\n      return Err(ErrorFactory.apiError(\n        'Inventory reservation failed',\n        500,\n        error\n      ));\n    }\n  }\n\n  /**\n   * Release reserved inventory\n   */\n  private async releaseInventory(cart: Cart): Promise<Result<void, WooError>> {\n    try {\n      // This would implement inventory release logic\n      // For now, return success as placeholder\n      return Ok(undefined);\n    } catch (error) {\n      return Err(ErrorFactory.apiError(\n        'Inventory release failed',\n        500,\n        error\n      ));\n    }\n  }\n\n  /**\n   * Update inventory\n   */\n  private async updateInventory(request: InventoryUpdateRequest): Promise<Result<void, WooError>> {\n    try {\n      // This would implement inventory update logic\n      // For now, return success as placeholder\n      return Ok(undefined);\n    } catch (error) {\n      return Err(ErrorFactory.apiError(\n        'Inventory update failed',\n        500,\n        error\n      ));\n    }\n  }\n\n  /**\n   * Send order confirmation email\n   */\n  private async sendOrderConfirmationEmail(order: Order): Promise<Result<void, WooError>> {\n    try {\n      // This would integrate with email service\n      // For now, return success as placeholder\n      return Ok(undefined);\n    } catch (error) {\n      return Err(ErrorFactory.apiError(\n        'Confirmation email failed',\n        500,\n        error\n      ));\n    }\n  }\n}\n\n/**\n * Default order processing configuration\n */\nexport const DEFAULT_ORDER_PROCESSING_CONFIG: OrderProcessingConfig = {\n  autoUpdateInventory: true,\n  sendConfirmationEmail: true,\n  requirePaymentConfirmation: true,\n  orderNumberPrefix: 'WOO-',\n  defaultStatus: 'pending',\n  inventoryHoldMinutes: 15,\n  cacheTimeout: 30 // 30 minutes\n}; ","/**\n * Main Checkout Service for WooCommerce Headless SDK\n * Unified API integrating all checkout components\n * Following the Enhanced Unified 10X Developer Framework\n */\n\nimport { HttpClient } from '../../core/client';\nimport { CacheManager } from '../../core/cache';\nimport { Result, Ok, Err, isErr, isOk, unwrap, unwrapErr } from '../../types/result';\nimport { WooError, ErrorFactory } from '../../types/errors';\nimport { \n  CheckoutSession,\n  CheckoutValidationRules,\n  CheckoutStep,\n  BillingAddress,\n  ShippingAddress,\n  SelectedShippingMethod,\n  PaymentMethod,\n  Order\n} from '../../types/checkout';\nimport { Cart } from '../../types/cart';\n\n// Import all checkout services\nimport { \n  AddressManager, \n  AddressFieldRequirements, \n  AddressValidationContext\n} from './address';\nimport { \n  ShippingService, \n  ShippingRateRequest, \n  ShippingRateResponse,\n  ShippingCalculation,\n  ShippingConfig,\n  DEFAULT_SHIPPING_CONFIG \n} from './shipping';\nimport { \n  PaymentService, \n  PaymentInitRequest,\n  PaymentConfig,\n  DEFAULT_PAYMENT_CONFIG \n} from './payment';\nimport { \n  CheckoutValidationService,\n  CheckoutValidationContext,\n  CheckoutValidationResult,\n  ValidationResult,\n  createValidationRules \n} from './validation';\nimport { \n  CheckoutFlowManager,\n  CheckoutFlowState,\n  CheckoutFlowConfig,\n  CheckoutFlowEventHandlers,\n  StepTransitionResult,\n  DEFAULT_CHECKOUT_FLOW_CONFIG \n} from './flow';\nimport { \n  OrderProcessingService,\n  OrderCreateRequest,\n  OrderCreateResponse,\n  OrderConfirmationRequest,\n  OrderSearchCriteria,\n  OrderProcessingConfig,\n  DEFAULT_ORDER_PROCESSING_CONFIG \n} from './order';\n\n/**\n * Comprehensive checkout configuration\n */\nexport interface CheckoutConfig {\n  readonly address?: Partial<AddressFieldRequirements>;\n  readonly shipping?: Partial<ShippingConfig>;\n  readonly payment?: Partial<PaymentConfig>;\n  readonly flow?: Partial<CheckoutFlowConfig>;\n  readonly order?: Partial<OrderProcessingConfig>;\n  readonly validation?: Partial<CheckoutValidationRules>;\n}\n\n/**\n * Checkout session update options\n */\nexport interface CheckoutSessionUpdateOptions {\n  readonly billingAddress?: BillingAddress;\n  readonly shippingAddress?: ShippingAddress;\n  readonly useShippingAsBilling?: boolean;\n  readonly selectedShippingMethod?: SelectedShippingMethod;\n  readonly selectedPaymentMethod?: PaymentMethod;\n  readonly orderNotes?: string;\n  readonly termsAccepted?: boolean;\n  readonly newsletterOptIn?: boolean;\n}\n\n/**\n * Checkout initialization options\n */\nexport interface CheckoutInitOptions {\n  readonly isGuestCheckout?: boolean;\n  readonly skipValidation?: boolean;\n  readonly startStep?: number;\n}\n\n/**\n * Main checkout service integrating all components\n */\nclass CheckoutService {\n  private readonly config: CheckoutConfig;\n\n  // Service instances\n  private readonly addressManager: AddressManager;\n  private readonly shippingService: ShippingService;\n  private readonly paymentService: PaymentService;\n  private readonly validationService: CheckoutValidationService;\n  private readonly orderProcessingService: OrderProcessingService;\n  \n  // Flow manager (created per checkout session)\n  private flowManager: CheckoutFlowManager | null = null;\n  private currentCart: Cart | null = null;\n\n  constructor(\n    client: HttpClient,\n    cache: CacheManager,\n    config: CheckoutConfig = {}\n  ) {\n    this.config = config;\n\n    // Initialize service instances\n    this.addressManager = new AddressManager();\n    \n    this.shippingService = new ShippingService(\n      client,\n      cache,\n      { ...DEFAULT_SHIPPING_CONFIG, ...config.shipping }\n    );\n    \n    this.paymentService = new PaymentService(\n      client,\n      cache,\n      { ...DEFAULT_PAYMENT_CONFIG, ...config.payment }\n    );\n    \n    this.validationService = new CheckoutValidationService(\n      this.addressManager,\n      this.shippingService,\n      this.paymentService\n    );\n    \n    this.orderProcessingService = new OrderProcessingService(\n      client,\n      cache,\n      { ...DEFAULT_ORDER_PROCESSING_CONFIG, ...config.order }\n    );\n  }\n\n  /**\n   * Initialize checkout with cart\n   */\n  async initializeCheckout(\n    cart: Cart, \n    options: CheckoutInitOptions = {},\n    eventHandlers: CheckoutFlowEventHandlers = {}\n  ): Promise<Result<CheckoutFlowState, WooError>> {\n    try {\n      this.currentCart = cart;\n\n      // Create flow manager\n      const flowConfig: CheckoutFlowConfig = {\n        ...DEFAULT_CHECKOUT_FLOW_CONFIG,\n        ...this.config.flow,\n        validationRules: {\n          ...DEFAULT_CHECKOUT_FLOW_CONFIG.validationRules,\n          ...this.config.validation\n        }\n      };\n\n      this.flowManager = new CheckoutFlowManager(\n        this.addressManager,\n        this.shippingService,\n        this.paymentService,\n        this.validationService,\n        flowConfig,\n        eventHandlers\n      );\n\n      // Initialize the flow\n      const result = await this.flowManager.initializeCheckout(\n        cart, \n        options.isGuestCheckout || false\n      );\n\n      if (isOk(result) && options.startStep && options.startStep > 1) {\n        // Jump to specific step if requested\n        return this.flowManager.goToStep(options.startStep, cart);\n      }\n\n      return result;\n\n    } catch (error) {\n      return Err(ErrorFactory.validationError(\n        'Checkout initialization failed',\n        error\n      ));\n    }\n  }\n\n  /**\n   * Update checkout session\n   */\n  async updateSession(updates: CheckoutSessionUpdateOptions): Promise<Result<CheckoutFlowState, WooError>> {\n    if (!this.flowManager || !this.currentCart) {\n      return Err(ErrorFactory.validationError('Checkout not initialized'));\n    }\n\n    return this.flowManager.updateSession(updates, this.currentCart);\n  }\n\n  /**\n   * Move to next step\n   */\n  async nextStep(): Promise<Result<StepTransitionResult, WooError>> {\n    if (!this.flowManager || !this.currentCart) {\n      return Err(ErrorFactory.validationError('Checkout not initialized'));\n    }\n\n    return this.flowManager.nextStep(this.currentCart);\n  }\n\n  /**\n   * Move to previous step\n   */\n  async previousStep(): Promise<Result<StepTransitionResult, WooError>> {\n    if (!this.flowManager) {\n      return Err(ErrorFactory.validationError('Checkout not initialized'));\n    }\n\n    return this.flowManager.previousStep();\n  }\n\n  /**\n   * Jump to specific step\n   */\n  async goToStep(step: number): Promise<Result<StepTransitionResult, WooError>> {\n    if (!this.flowManager || !this.currentCart) {\n      return Err(ErrorFactory.validationError('Checkout not initialized'));\n    }\n\n    return this.flowManager.goToStep(step, this.currentCart);\n  }\n\n  /**\n   * Get current checkout state\n   */\n  getCurrentState(): CheckoutFlowState | null {\n    return this.flowManager?.getFlowState() || null;\n  }\n\n  /**\n   * Validate current step\n   */\n  async validateCurrentStep(): Promise<Result<CheckoutValidationResult, WooError>> {\n    if (!this.flowManager || !this.currentCart) {\n      return Err(ErrorFactory.validationError('Checkout not initialized'));\n    }\n\n    return this.flowManager.validateCurrentStep(this.currentCart);\n  }\n\n  /**\n   * Complete checkout and create order\n   */\n  async completeCheckout(): Promise<Result<OrderCreateResponse, WooError>> {\n    try {\n      if (!this.flowManager || !this.currentCart) {\n        return Err(ErrorFactory.validationError('Checkout not initialized'));\n      }\n\n      const currentState = this.flowManager.getFlowState();\n      \n      // Create order request\n      const orderRequest: OrderCreateRequest = {\n        cart: this.currentCart,\n        checkoutSession: currentState.session\n      };\n\n      // Create the order\n      const orderResult = await this.orderProcessingService.createOrder(orderRequest);\n      if (isErr(orderResult)) {\n        return Err(unwrapErr(orderResult));\n      }\n\n      const orderResponse = unwrap(orderResult);\n\n      // If payment is required and we have a payment method, initialize payment\n      if (orderResponse.requiresPayment && currentState.session.selectedPaymentMethod) {\n        const paymentRequest: PaymentInitRequest = {\n          paymentMethodId: currentState.session.selectedPaymentMethod.id,\n          orderId: orderResponse.order.id,\n          amount: orderResponse.order.total,\n          currency: orderResponse.order.currency,\n          returnUrl: '/checkout/payment/return',\n          cancelUrl: '/checkout/payment/cancel'\n        };\n\n        const paymentResult = await this.paymentService.initializePayment(paymentRequest);\n        if (isOk(paymentResult)) {\n          const payment = unwrap(paymentResult);\n          return Ok({\n            ...orderResponse,\n            paymentUrl: payment.redirectUrl\n          });\n        }\n      }\n\n      return Ok(orderResponse);\n\n    } catch (error) {\n      return Err(ErrorFactory.apiError(\n        'Checkout completion failed',\n        500,\n        error\n      ));\n    }\n  }\n\n  // Address Management Methods\n\n  /**\n   * Get field requirements for address\n   */\n  getAddressFieldRequirements(addressType: 'billing' | 'shipping'): AddressFieldRequirements {\n    const context: AddressValidationContext = {\n      addressType,\n      isGuestCheckout: this.getCurrentState()?.session.isGuestCheckout || false,\n      fieldRequirements: this.config.address,\n      checkoutRules: this.config.validation\n    };\n\n    return this.addressManager.getFieldRequirements(context);\n  }\n\n  /**\n   * Validate address\n   */\n  async validateAddress(\n    address: BillingAddress | ShippingAddress, \n    type: 'billing' | 'shipping'\n  ): Promise<Result<ValidationResult, WooError>> {\n    if (!this.currentCart) {\n      return Err(ErrorFactory.validationError('Checkout not initialized'));\n    }\n\n    const context: CheckoutValidationContext = {\n      checkoutSession: this.getCurrentState()?.session || {} as CheckoutSession,\n      cart: this.currentCart,\n      validationRules: { ...this.config.validation } as CheckoutValidationRules,\n      isGuestCheckout: this.getCurrentState()?.session.isGuestCheckout || false,\n      currentStep: this.getCurrentState()?.currentStep || 1\n    };\n\n    if (type === 'billing') {\n      return this.validationService.validateBillingAddress(context);\n    } else {\n      return this.validationService.validateShippingAddress(context);\n    }\n  }\n\n  /**\n   * Get address suggestions\n   */\n  async getAddressSuggestions(address: BillingAddress | ShippingAddress): Promise<Result<BillingAddress | ShippingAddress | null, WooError>> {\n    return this.addressManager.suggestAddressCorrection(address);\n  }\n\n  // Shipping Methods\n\n  /**\n   * Get available shipping rates\n   */\n  async getShippingRates(destination?: BillingAddress | ShippingAddress): Promise<Result<ShippingRateResponse, WooError>> {\n    if (!this.currentCart) {\n      return Err(ErrorFactory.validationError('Checkout not initialized'));\n    }\n\n    const currentState = this.getCurrentState();\n    const shippingDestination = destination || \n      (currentState?.session.useShippingAsBilling \n        ? currentState?.session.billingAddress \n        : currentState?.session.shippingAddress);\n\n    if (!shippingDestination) {\n      return Err(ErrorFactory.validationError('Shipping address is required'));\n    }\n\n    const request: ShippingRateRequest = {\n      destination: shippingDestination,\n      cartItems: this.currentCart.items.map(item => ({\n        productId: item.productId,\n        variationId: item.variationId,\n        quantity: item.quantity,\n        weight: item.weight,\n        dimensions: item.dimensions\n      })),\n      cartTotal: this.currentCart.totals.total,\n      currency: this.currentCart.currency\n    };\n\n    return this.shippingService.getShippingRates(request);\n  }\n\n  /**\n   * Calculate shipping for selected method\n   */\n  async calculateShipping(\n    selectedMethod: SelectedShippingMethod,\n    destination?: BillingAddress | ShippingAddress\n  ): Promise<Result<ShippingCalculation, WooError>> {\n    if (!this.currentCart) {\n      return Err(ErrorFactory.validationError('Checkout not initialized'));\n    }\n\n    const currentState = this.getCurrentState();\n    const shippingDestination = destination || \n      (currentState?.session.useShippingAsBilling \n        ? currentState?.session.billingAddress \n        : currentState?.session.shippingAddress);\n\n    if (!shippingDestination) {\n      return Err(ErrorFactory.validationError('Shipping address is required'));\n    }\n\n    return this.shippingService.calculateShipping(\n      selectedMethod,\n      shippingDestination,\n      this.currentCart.totals.total\n    );\n  }\n\n  // Payment Methods\n\n  /**\n   * Get available payment methods\n   */\n  async getPaymentMethods(): Promise<Result<PaymentMethod[], WooError>> {\n    if (!this.currentCart) {\n      return Err(ErrorFactory.validationError('Checkout not initialized'));\n    }\n\n    return this.paymentService.getAvailablePaymentMethods(\n      this.currentCart.totals.total,\n      this.currentCart.currency\n    );\n  }\n\n  /**\n   * Validate payment method\n   */\n  async validatePaymentMethod(methodId: string): Promise<Result<boolean, WooError>> {\n    if (!this.currentCart) {\n      return Err(ErrorFactory.validationError('Checkout not initialized'));\n    }\n\n    const validationResult = await this.paymentService.validatePaymentMethod(\n      methodId,\n      this.currentCart.totals.total,\n      this.currentCart.currency\n    );\n\n    if (isErr(validationResult)) {\n      return Err(unwrapErr(validationResult));\n    }\n\n    return Ok(unwrap(validationResult).isValid);\n  }\n\n  // Order Management\n\n  /**\n   * Get order by ID\n   */\n  async getOrder(orderId: string): Promise<Result<Order, WooError>> {\n    return this.orderProcessingService.getOrder(orderId);\n  }\n\n  /**\n   * Confirm order payment\n   */\n  async confirmOrderPayment(request: OrderConfirmationRequest): Promise<Result<Order, WooError>> {\n    return this.orderProcessingService.confirmOrder(request);\n  }\n\n  /**\n   * Cancel order\n   */\n  async cancelOrder(orderId: string, reason?: string): Promise<Result<Order, WooError>> {\n    return this.orderProcessingService.cancelOrder(orderId, reason);\n  }\n\n  /**\n   * Search orders\n   */\n  async searchOrders(criteria: OrderSearchCriteria): Promise<Result<Order[], WooError>> {\n    return this.orderProcessingService.searchOrders(criteria);\n  }\n\n  // Utility Methods\n\n  /**\n   * Reset checkout session\n   */\n  async resetCheckout(): Promise<Result<void, WooError>> {\n    if (this.flowManager) {\n      const resetResult = await this.flowManager.resetFlow();\n      this.flowManager = null;\n      this.currentCart = null;\n      return resetResult;\n    }\n    return Ok(undefined);\n  }\n\n  /**\n   * Check if checkout can proceed\n   */\n  canProceedToNextStep(): boolean {\n    const state = this.getCurrentState();\n    return state?.canProceed || false;\n  }\n\n  /**\n   * Get current step information\n   */\n  getCurrentStep(): CheckoutStep | null {\n    return this.flowManager?.getCurrentStep() || null;\n  }\n\n  /**\n   * Check if step is completed\n   */\n  isStepCompleted(step: number): boolean {\n    return this.flowManager?.isStepCompleted(step) || false;\n  }\n\n  /**\n   * Generate order number\n   */\n  generateOrderNumber(): string {\n    return this.orderProcessingService.generateOrderNumber();\n  }\n\n  /**\n   * Get checkout configuration\n   */\n  getConfiguration(): CheckoutConfig {\n    return this.config;\n  }\n\n  /**\n   * Update checkout configuration\n   */\n  updateConfiguration(updates: Partial<CheckoutConfig>): void {\n    Object.assign(this.config, updates);\n  }\n}\n\n/**\n * Default checkout configuration\n */\nexport const DEFAULT_CHECKOUT_CONFIG: CheckoutConfig = {\n  address: {\n    firstName: true,\n    lastName: true,\n    company: false,\n    address1: true,\n    address2: false,\n    city: true,\n    state: true,\n    postcode: true,\n    country: true,\n    email: true,\n    phone: false\n  },\n  shipping: DEFAULT_SHIPPING_CONFIG,\n  payment: DEFAULT_PAYMENT_CONFIG,\n  flow: DEFAULT_CHECKOUT_FLOW_CONFIG,\n  order: DEFAULT_ORDER_PROCESSING_CONFIG,\n  validation: createValidationRules().build()\n};\n\n// Export all types and services for advanced usage\nexport * from './address';\nexport * from './shipping';\nexport * from './payment';\nexport * from './validation';\nexport * from './flow';\nexport * from './order';\n\nexport { CheckoutService }; ","/**\n * WooCommerce Headless SDK - Main Export\n * Following the enhanced unified-10x-dev framework\n */\n\n// Core types\nexport * from './types/result';\nexport * from './types/errors';\nexport * from './types/commerce';\nexport * from './types/config';\n\n// Additional cart types (avoiding conflicts with config)\nexport type { \n  CartItem, \n  Cart, \n  CartTotals, \n  CartValidationResult,\n  CartUpdateRequest,\n  CartAddItemRequest,\n  CartQuantityLimits,\n  CartItemMeta,\n  AppliedCoupon,\n  ShippingMethod,\n  CartFee\n} from './types/cart';\n\n// Additional search types (avoiding conflicts with config)\nexport type {\n  SearchQuery,\n  SearchResults,\n  SearchResultItem,\n  SearchFilter,\n  SearchFacet,\n  SearchSuggestion,\n  SearchAggregation,\n  SearchPagination,\n  SearchAnalyticsEvent,\n  SearchHistoryEntry,\n  SearchQueryBuilder,\n  QuickSearchParams,\n  AutoCompleteRequest,\n  AutoCompleteResponse,\n  SearchOperator,\n  SortDirection\n} from './types/search';\n\n// Additional user types\nexport type {\n  UserProfile,\n  CustomerData,\n  UserAddress,\n  UserPreferences,\n  UserOrderSummary,\n  UserWishlist,\n  WishlistItem,\n  UserActivity,\n  UserAuthContext,\n  UserSyncRequest,\n  UserSyncResponse,\n  UserUpdateRequest,\n  AddressValidationResult,\n  UserListParams,\n  UserListResponse,\n  UserStats,\n  UserRole,\n  UserStatus,\n  Gender,\n  AddressType\n} from './types/user';\n\n// Review and rating types\nexport type {\n  ProductReview,\n  ReviewStatus,\n  ReviewImage,\n  CreateReviewRequest,\n  UpdateReviewRequest,\n  ReviewListParams,\n  ReviewListResponse,\n  RatingDistribution,\n  ReviewAnalytics,\n  ReviewVote,\n  ReviewModeration,\n  ReviewValidationResult,\n  ReviewFilter,\n  ReviewSort,\n  ReviewSearchConfig,\n  ReviewNotificationSettings,\n  ReviewExportOptions,\n  ReviewImportOptions,\n  ReviewRateLimit\n} from './types/review';\n\n// Core classes\nexport { HttpClient } from './core/client';\nexport { AuthManager } from './core/auth';\nexport { ConfigManager } from './core/config';\nexport { CacheManager, MemoryCache, LocalStorageCache, IndexedDBCache } from './core/cache';\nexport type { CacheEntry, CacheStorage } from './core/cache';\n\n// Modules\nexport { ProductService } from './modules/products';\nexport type { ProductListParams, ProductListResponse, VariationListParams } from './modules/products';\nexport { CartService } from './modules/cart';\nexport { SearchService } from './modules/search';\nexport { UserService } from './modules/user';\nexport { ReviewService } from './modules/reviews';\n\n// Main SDK class\nexport { WooHeadless } from './woo-headless';\n\n// Version\nexport const VERSION = '1.0.0';\n\n// Export commerce types\nexport {\n  // Types\n  type ProductStatus,\n  type ProductCatalogVisibility,\n  type ProductType,\n  type OrderStatus,\n  type ImageDimensions,\n  type ProductImage,\n  type ProductCategory,\n  type ProductTag,\n  type ProductAttribute,\n  type PriceRange,\n  type ProductDimensions,\n  type MetaData,\n  type WooCommerceProduct,\n  type ProductVariation,\n  type BillingAddress,\n  type ShippingAddress,\n  type OrderLineItem,\n  type WooCommerceOrder,\n  type WooCommerceCustomer,\n  type WooCommerceCoupon,\n  \n  // Schemas\n  ProductSchema,\n  OrderSchema,\n  \n  // Type guards\n  isWooCommerceProduct,\n  isWooCommerceOrder,\n  isWooCommerceCoupon\n} from './types/commerce'; ","/**\n * Main WooHeadless SDK class\n * Following the enhanced unified-10x-dev framework\n */\n\nimport { HttpClient } from './core/client';\nimport { AuthManager } from './core/auth';\nimport { ConfigManager } from './core/config';\nimport { CacheManager } from './core/cache';\nimport { ProductService } from './modules/products';\nimport { CartService } from './modules/cart';\nimport { SearchService } from './modules/search';\nimport { UserService } from './modules/user';\nimport { CheckoutService } from './modules/checkout';\nimport { ReviewService } from './modules/reviews';\nimport { WooConfig, ResolvedWooConfig } from './types/config';\nimport { Result } from './types/result';\nimport { ConfigurationError, WooError } from './types/errors';\n\n/**\n * Main SDK class that provides access to all WooCommerce functionality\n */\nexport class WooHeadless {\n  private config: ResolvedWooConfig;\n  private readonly httpClient: HttpClient;\n  private readonly authManager: AuthManager;\n  private cacheManager: CacheManager;\n  \n  // Public services\n  public readonly products: ProductService;\n  public readonly cart: CartService;\n  public readonly search: SearchService;\n  public readonly user: UserService;\n  public readonly checkout: CheckoutService;\n  public readonly reviews: ReviewService;\n\n  constructor(config: WooConfig) {\n    // Validate and resolve configuration\n    const configResult = ConfigManager.resolveConfig(config);\n    if (!configResult.success) {\n      throw configResult.error;\n    }\n    this.config = configResult.data;\n\n    // Initialize core components\n    this.httpClient = new HttpClient(this.config);\n    this.authManager = new AuthManager(this.config);\n    this.cacheManager = new CacheManager(this.config.cache);\n\n    // Set up authentication interceptor if enabled\n    if (this.config.auth.enabled) {\n      this.httpClient.addRequestInterceptor((options) => {\n        const authHeaders = this.authManager.getAuthorizationHeader();\n        if (authHeaders) {\n          return {\n            ...options,\n            headers: {\n              ...options.headers,\n              ...authHeaders\n            }\n          };\n        }\n        return options;\n      });\n    } else {\n      // Use basic auth with consumer key/secret\n      const basicAuth = AuthManager.generateBasicAuth(\n        this.config.consumerKey,\n        this.config.consumerSecret\n      );\n      this.httpClient.addRequestInterceptor((options) => ({\n        ...options,\n        headers: {\n          ...options.headers,\n          'Authorization': basicAuth\n        }\n      }));\n    }\n\n    // Initialize services\n    this.products = new ProductService(this.httpClient, this.cacheManager);\n    this.cart = new CartService(this.httpClient, this.cacheManager, this.config.cart);\n    this.search = new SearchService(this.httpClient, this.cacheManager, this.config.advancedSearch);\n    this.user = new UserService(this.httpClient, this.cacheManager, this.config.userSync);\n    this.checkout = new CheckoutService(this.httpClient, this.cacheManager, this.config.checkout);\n    this.reviews = new ReviewService(this.httpClient, this.cacheManager);\n  }\n\n  /**\n   * Get current configuration\n   */\n  getConfig(): ResolvedWooConfig {\n    return this.config;\n  }\n\n  /**\n   * Get authentication manager\n   */\n  getAuth(): AuthManager {\n    return this.authManager;\n  }\n\n  /**\n   * Get cache manager\n   */\n  getCache(): CacheManager {\n    return this.cacheManager;\n  }\n\n  /**\n   * Get HTTP client for custom requests\n   */\n  getHttpClient(): HttpClient {\n    return this.httpClient;\n  }\n\n  /**\n   * Clear all caches\n   */\n  async clearCache(): Promise<Result<void, WooError>> {\n    return this.cacheManager.clear();\n  }\n\n  /**\n   * Get cache statistics\n   */\n  async getCacheStats(): Promise<Result<Record<string, number>, WooError>> {\n    return this.cacheManager.getStats();\n  }\n\n  /**\n   * Update configuration at runtime\n   */\n  updateConfig(updates: Partial<WooConfig>): Result<void, ConfigurationError> {\n    const newConfig = { ...this.config, ...updates };\n    const validationResult = ConfigManager.resolveConfig(newConfig);\n    \n    if (!validationResult.success) {\n      return validationResult;\n    }\n\n    // Apply updates\n    Object.assign(this.config, validationResult.data);\n    \n    // Reinitialize components if needed\n    if (updates.cache) {\n      this.cacheManager = new CacheManager(this.config.cache);\n    }\n    \n    return { success: true, data: undefined };\n  }\n\n  /**\n   * Health check to verify API connectivity\n   */\n  async healthCheck(): Promise<Result<boolean, WooError>> {\n    const result = await this.httpClient.get('/');\n    return result.success ? { success: true, data: true } : result;\n  }\n} "],"names":["Ok","data","success","Err","error","isOk","result","isErr","unwrap","Error","JSON","stringify","unwrapErr","NetworkError","constructor","message","details","statusCode","super","this","code","retryable","name","timestamp","Date","AuthError","ValidationError","ApiError","RateLimitError","retryAfter","TimeoutError","timeout","ConfigurationError","ProductNotFoundError","productId","CartError","CheckoutError","PaymentError","ErrorFactory","networkError","authError","validationError","apiError","rateLimitError","timeoutError","configurationError","productNotFoundError","cartError","checkoutError","paymentError","cacheError","CacheError","notImplementedError","persistenceError","ProductSchema","z","object","id","number","string","slug","status","enum","featured","boolean","catalog_visibility","description","short_description","price","regular_price","sale_price","on_sale","stock_status","manage_stock","stock_quantity","optional","categories","array","images","src","alt","OrderSchema","currency","total","customer_id","billing","first_name","last_name","email","phone","line_items","product_id","quantity","DEFAULT_CONFIG","version","environment","cache","enabled","ttl","storage","maxSize","prefix","auth","expiresIn","autoRefresh","refreshThreshold","http","retries","retryDelay","maxRetryDelay","retryCondition","includes","search","fuzzyThreshold","maxResults","enableHighlight","enableSuggestions","cacheResults","enableAnalytics","advancedSearch","fuzzy","threshold","distance","minMatchCharLength","includeScore","highlighting","preTag","postTag","fragmentSize","maxFragments","suggestions","maxSuggestions","minQueryLength","showPopular","showRecent","facets","maxFacets","maxFacetValues","minDocumentCount","analytics","trackQueries","trackFilters","trackClicks","trackConversions","sessionTimeout","caching","maxCacheSize","cacheKey","performance","searchTimeout","debounceDelay","prefetchResults","trackPageViews","trackSearches","i18n","locale","timezone","dateFormat","numberFormat","style","minimumFractionDigits","maximumFractionDigits","debug","logLevel","performanceMonitoring","errorReporting","apiLogging","cart","persistence","strategy","key","encryption","expirationDays","syncToServer","sync","syncIntervalMs","conflictResolution","maxRetries","retryDelayMs","syncOnAuth","syncOnCartChange","backgroundSync","offlineQueueSize","autoCalculateTotals","validateStock","allowBackorders","maxItems","maxQuantityPerItem","enableCoupons","enableShipping","enableFees","enableCrossSells","taxCalculation","pricesIncludeTax","displayMode","roundAtSubtotal","userSync","syncInterval","syncOnLogin","syncProfile","syncAddresses","syncPreferences","syncOrderHistory","syncWishlist","maxOrderHistory","cacheUserData","cacheTtl","checkout","address","firstName","lastName","company","address1","address2","city","state","postcode","country","shipping","calculateTax","defaultCountry","restrictedCountries","cacheTimeout","payment","testMode","supportedMethods","minimumAmount","returnUrl","cancelUrl","flow","steps","allowSkipOptional","persistSession","autoAdvance","validationRules","requireShippingAddress","requireBillingAddress","requirePhoneNumber","requireCompanyName","allowGuestCheckout","minimumOrderAmount","requiredFields","order","autoUpdateInventory","sendConfirmationEmail","requirePaymentConfirmation","orderNumberPrefix","defaultStatus","inventoryHoldMinutes","validation","validateBaseURL","url","URL","validateConsumerCredentials","secret","trim","length","validateCacheConfig","config","HttpClient","requestInterceptors","responseInterceptors","errorInterceptors","abortControllers","Map","baseURL","addRequestInterceptor","interceptor","push","addResponseInterceptor","addErrorInterceptor","request","options","requestId","generateRequestId","processedOptions","attemptRequest","response","createErrorFromException","delete","get","headers","method","post","body","put","patch","cancelRequest","controller","abort","cancelAllRequests","values","clear","lastError","attempt","executeRequest","shouldRetry","delay","calculateRetryDelay","abortController","AbortController","set","buildURL","timeoutId","setTimeout","fetchOptions","buildHeaders","signal","buildBody","fetch","clearTimeout","ok","createErrorFromResponse","parseResponse","responseHeaders","extractHeaders","statusText","aborted","path","cleanPath","startsWith","slice","Accept","contentType","json","text","forEach","value","parseInt","jitteredDelay","Math","pow","random","min","ms","Promise","resolve","now","toString","substr","LocalTokenStorage","localStorage","getItem","setItem","remove","removeItem","keys","Object","MemoryTokenStorage","store","Array","from","AuthManager","currentToken","refreshTimer","window","initializeToken","tokenData","parsed","parse","isTokenValid","scheduleRefresh","clearToken","setToken","getToken","token","isAuthenticated","validateToken","clearRefreshTimer","logout","createTokenFromAuthResponse","authResponse","expiresAt","expires","issuedAt","getAuthorizationHeader","Authorization","refreshTime","getTime","handleTokenRefresh","generateBasicAuth","consumerKey","consumerSecret","btoa","createOAuthSignature","parameters","floor","oauthParams","oauth_consumer_key","oauth_nonce","substring","oauth_signature_method","oauth_timestamp","oauth_version","sortedParams","sort","map","encodeURIComponent","join","signatureBase","toUpperCase","signingKey","signature","oauth_signature","ConfigManager","resolveConfig","validateConfig","hasConsumerKey","Boolean","hasConsumerSecret","getEnvironmentConfig","fromEnvironment","process","env","WOO_BASE_URL","WOO_CONSUMER_KEY","WOO_CONSUMER_SECRET","WOO_VERSION","NODE_ENV","envConfig","assign","mergeConfigs","configs","merged","MemoryCache","maxSizeMB","entry","size","estimateSize","evictIfNeeded","has","requiredSize","currentSize","entries","sortedEntries","a","b","LocalStorageCache","item","serialized","e","evictOldest","count","removeCount","ceil","i","IndexedDBCache","dbName","storeName","db","initDB","indexedDB","open","onerror","onsuccess","onupgradeneeded","event","target","objectStoreNames","contains","createObjectStore","keyPath","dbResult","transaction","objectStore","CacheManager","layers","initializeLayers","layerName","layer","promote","finalTtl","errors","getStats","stats","sizeResult","foundLayer","layerOrder","foundIndex","indexOf","ProductService","client","list","params","validationResult","validateListParams","queryParams","buildQueryParams","cachedResult","URLSearchParams","totalProducts","totalPages","products","product","validated","currentPage","page","perPage","limit","getBySlug","find","p","getVariations","buildVariationQueryParams","query","getByCategory","categoryId","category","getFeatured","getOnSale","onSale","minPrice","maxPrice","per_page","tag","orderby","offset","inStock","min_price","max_price","include","exclude","parent","CartItemMetaSchema","displayKey","displayValue","CartQuantityLimitsSchema","max","step","CartItemSchema","positive","variationId","regularPrice","salePrice","totalPrice","sku","weight","dimensions","width","height","image","stockQuantity","stockStatus","backorders","quantityLimits","meta","attributes","record","addedAt","date","updatedAt","CartTotalsSchema","subtotal","subtotalTax","shippingTotal","shippingTax","discountTotal","discountTax","cartContentsTotal","cartContentsTax","feeTotal","feeTax","totalTax","AppliedCouponSchema","discountType","amount","freeShipping","expiryDate","usageLimit","usageCount","individualUse","productIds","excludedProductIds","categoryIds","excludedCategoryIds","maximumAmount","CartSchema","items","itemCount","totals","appliedCoupons","shippingMethods","any","chosenShippingMethods","fees","needsShipping","needsPayment","hasCalculatedShipping","currencySymbol","taxDisplayMode","crossSells","isEmpty","createdAt","customerId","sessionId","CartAddItemRequestSchema","replace","isCart","obj","generateId","CartSyncManager","httpClient","deviceId","syncStatus","backgroundSyncTimer","isOnline","syncQueue","eventHandlers","generateDeviceId","setupNetworkMonitoring","setupBackgroundSync","getStatus","getLastSyncAt","lastSyncAt","addEventHandler","handler","removeEventHandler","index","splice","syncCart","localCart","authContext","conflicts","syncedAt","changes","itemsAdded","itemsUpdated","itemsRemoved","couponsAdded","couponsRemoved","userId","context","setSyncStatus","notifyEventHandlers","serverCartResult","fetchServerCart","serverCartData","uploadResult","uploadCart","mergedCart","mergeResult","mergeCarts","resolveResult","resolveConflicts","queueAction","action","queueItem","retryCount","shift","processQueue","failedItems","processQueueItem","enable","disable","stopBackgroundSync","destroy","metadata","syncVersion","source","serverCart","itemMergeResult","mergeCartItems","mergedItems","itemConflicts","filter","some","local","localItem","couponMergeResult","mergeCoupons","mergedCoupons","reduce","sum","localItems","serverItems","processedKeys","Set","serverItem","add","conflict","type","itemKey","localValue","serverValue","suggestion","getQuantityMergeSuggestion","resolvedQuantity","resolveQuantityConflict","localCoupons","serverCoupons","processedCodes","localCoupon","serverCoupon","coupon","localQuantity","serverQuantity","console","warn","args","onSyncStart","onSyncComplete","onSyncError","onConflictDetected","navigator","onLine","addEventListener","setInterval","clearInterval","crypto","randomUUID","CartPersistenceManager","save","toISOString","getStorageKey","sessionStorage","saveToIndexedDB","saveToServer","load","loadFromIndexedDB","loadFromServer","test","clearFromIndexedDB","clearFromServer","openIndexedDB","reject","close","createIndex","unique","cartData","log","CartTotalsCalculator","calculate","customerData","calculateSubtotal","calculateSubtotalTax","calculateDiscounts","calculateShipping","calculateFees","calculateFinalTotal","roundTotal","tax","discount","taxRate","getDefaultTaxRate","itemSubtotal","coupons","calculateSingleCouponDiscount","applicableItems","couponAppliesToItem","applicableSubtotal","percentDiscount","cartTotal","selectedMethod","cost","taxable","taxes","fee","taxSum","US","CA","GB","DE","FR","AU","round","CartService","currentCart","calculator","syncManager","getCart","loadResult","createEmptyCart","addItem","validateAddItemRequest","cartResult","productResult","fetchProductData","stockValidation","generateCartItemKey","existingItemIndex","findIndex","updatedItems","createCartItem","existingItem","newQuantity","updatedItem","backordersAllowed","soldIndividually","downloadable","virtual","newItem","updatedCart","updateCartWithItems","saveResult","updateItem","removeResult","itemIndex","_","newTotals","clearCart","emptyCart","validateCart","mutableErrors","mutableWarnings","validateCartItem","constraintErrors","constraintWarnings","validateCartConstraints","w","couponErrors","couponWarnings","validateAppliedCoupons","totalsWarnings","validateCartTotals","isValid","warnings","currentStock","requestedQuantity","stockErrors","stockWarnings","validateItemStock","quantityErrors","quantityWarnings","validateItemQuantityLimits","priceWarnings","validateItemPriceChanges","variationErrors","validateProductVariation","currentProduct","availableStock","lowStockThreshold","backorderNotify","currentRegularPrice","parseFloat","currentSalePrice","abs","toFixed","previousPrice","currentPrice","priceIncrease","itemSalePrice","previousSalePrice","attributeName","attributeValue","totalQuantity","maxTotalQuantity","maxRecommended","couponCode","recalculatedTotals","tolerance","storedTotal","calculatedTotal","difference","applyCoupon","validateCoupon","valid","reason","recalculateWithCoupon","removeCoupon","normalizedCode","c","updatedAppliedCoupons","updatedTotals","getAvailableCoupons","availableCoupons","isCouponEligibleForCart","couponResult","fetchCouponData","couponData","validateCouponEligibility","date_expires","usage_limit","usage_count","minimum_amount","minAmount","maximum_amount","maxAmount","product_ids","excluded_product_ids","individual_use","k","backorders_allowed","sold_individually","setAuthContext","syncCartWithServer","catch","getAuthContext","getSyncStatus","addSyncEventHandler","removeSyncEventHandler","syncResult","enableSync","disableSync","processOfflineQueue","SearchFilterSchema","field","operator","unknown","label","RangeFilterSchema","union","SearchSortSchema","direction","SearchPaginationSchema","SearchQuerySchema","filters","rangeFilters","tagIds","excludeProductIds","minRating","pagination","highlight","resultPosition","SearchAnalyticsManager","searchHistory","trackEvent","eventKey","updateSearchHistory","getSearchHistory","cachedHistory","resultCount","clickedResults","conversions","unshift","getSessionId","SearchQueryBuilderImpl","queryText","range","rangeFilter","isArray","tagId","rating","attribute","pageNum","limitNum","build","reset","SearchService","fuseInstance","productsIndex","initializeFuseInstance","cachedIndex","createFuseInstance","refreshSearchIndex","fuseOptions","includeMatches","Fuse","allProducts","hasMore","quickSearch","builder","createQueryBuilder","split","startTime","validateSearchQuery","generateCacheKey","searchResults","score","highlights","extractHighlights","matchedFields","extractMatchedFields","applyFilters","applySorting","totalHits","maxScore","r","paginatedResults","applyPagination","generateFacets","aggregations","generateAggregations","generateSuggestions","processingTime","results","parsedQuery","executionStats","indexSize","cacheHit","autoComplete","includeProducts","fuseResults","trackResultClick","position","keyData","fuseResult","matches","match","indices","filteredResults","cat","minOk","maxOk","applyCustomFilter","applyRangeFilter","sorts","aValue","bValue","date_created","average_rating","total_sales","prices","avg","historyResult","toLowerCase","isDefault","language","timeFormat","emailNotifications","orderUpdates","promotions","newsletter","wishlistReminders","backInStock","priceDrops","privacy","profileVisibility","showPurchaseHistory","allowRecommendations","dataSharing","wordpressUserId","username","displayName","avatar","bio","website","dateOfBirth","gender","roles","dateRegistered","lastLogin","isEmailVerified","isPhoneVerified","UserSyncRequestSchema","externalUserId","forceRefresh","UserAuthContextSchema","accessToken","refreshToken","tokenExpiry","permissions","EmailVerificationService","sendVerification","rateLimitResult","checkRateLimit","generateVerificationToken","tokenExpiryMinutes","isUsed","attempts","storeVerificationToken","emailResult","sendVerificationEmail","updateRateLimit","tokenId","removeVerificationToken","confirmVerification","tokenResult","getVerificationToken","verificationResult","markEmailAsVerified","markTokenAsUsed","clearRateLimit","verifiedAt","getVerificationStatus","userResponse","isVerified","verificationDate","getVerificationDate","pendingTokens","getPendingTokens","pendingVerification","lastTokenSent","rateLimitInfo","getRateLimitInfo","attemptsRemaining","maxResendAttempts","resendVerification","invalidateUserTokens","templateType","isVerificationRequired","requireVerificationForPurchase","simpleHash","str","hash","charCodeAt","metaKey","updatedTokens","getUserTokens","cached","verificationData","emailVerifiedAt","verifiedEmail","_email_verified","_email_verified_at","_verified_email","template","getEmailTemplate","verificationUrl","buildVerificationUrl","emailData","to","subject","html","processTemplate","htmlBody","expiryMinutes","textBody","fromEmail","fromName","sendEmail","baseUrl","verificationPath","templates","variables","processed","placeholder","RegExp","String","cooldownEnd","lastAttempt","resendCooldownMinutes","updatedInfo","tokensJson","_email_verification_tokens","allTokens","updatedToken","tokens","DEFAULT_EMAIL_VERIFICATION_CONFIG","maxAttemptsPerDay","autoVerifyOnRegistration","emailService","provider","welcome","changeEmail","resend","DownloadManagementService","getCustomerDownloads","downloads","customerDownloads","download","customerDownload","mapToCustomerDownload","orderDate","generateDownloadLink","validateDownloadPermission","permission","rateLimiting","ipAddress","generateSecureToken","security","fileInfo","getFileInformation","downloadId","file","secureUrl","generateSecureUrl","cacheDownloadToken","orderId","downloadUrl","downloadsRemaining","fileSize","fileName","permissionResponse","permissionId","permissionData","mapToDownloadPermission","validateOwnership","isActive","accessExpires","ipValidation","validateCustomerIP","trackDownload","trackAnalytics","analyticsData","download_id","downloaded_at","downloadedAt","ip_address","user_agent","userAgent","file_size","download_duration","downloadDuration","successful","error_message","errorMessage","bandwidth","serveFile","downloadToken","tokenValidation","validateDownloadToken","updateDownloadCount","fileStream","createFileStream","filePath","getDownloadStatistics","startDate","endDate","start_date","end_date","totalDownloads","total_downloads","totalBandwidth","total_bandwidth","popularProducts","popular_products","productName","product_name","downloadCount","download_count","downloadsByDate","downloads_by_date","d","averageFileSize","average_file_size","successRate","success_rate","cleanupExpiredDownloads","downloadData","access_expires","isExpired","canDownload","downloads_remaining","permission_id","order_id","order_date","file_name","accessGranted","access_granted","orderKey","order_key","is_active","basePath","mimeType","stream","ReadableStream","start","enqueue","Uint8Array","getMimeType","extension","pop","pdf","zip","exe","dmg","mp4","mp3","jpg","jpeg","png","txt","hourlyKey","getHours","currentCount","maxDownloadsPerHour","DEFAULT_DOWNLOAD_CONFIG","maxDownloadsPerProduct","defaultExpiryDays","maxFileSize","allowedFileTypes","secureDownloads","maxBandwidthPerHour","checksumValidation","encryptFiles","secureBasePath","UserCacheManager","getUserProfile","cacheUserProfile","profile","clearUserCache","AddressValidator","validateAddress","isValidEmail","isValidPhone","isValidPostalCode","pattern","UserService","emailVerificationConfig","downloadConfig","currentAuthContext","userCache","emailVerification","isUserAuthContext","syncRequest","syncUserData","getCurrentAuthContext","clearAuthContext","validateSyncRequest","syncErrors","addresses","preferences","orderHistory","wishlist","profileResult","syncUserProfile","addressResult","syncUserAddresses","prefResult","syncUserPreferences","orderResult","syncUserOrderHistory","wishlistResult","syncUserWishlist","useCache","userData","display_name","avatar_urls","updateUserProfile","updates","updateData","getCustomerData","role","transformWooAddressToUserAddress","isPayingCustomer","is_paying_customer","ordersCount","orders_count","totalSpent","total_spent","avatarUrl","avatar_url","dateCreated","dateModified","date_modified","metaData","meta_data","sendEmailVerification","confirmEmailVerification","getEmailVerificationStatus","resendEmailVerification","isEmailVerificationRequired","getUserOrderHistory","orderNumber","total_tax","shipping_total","paymentMethod","payment_method","paymentMethodTitle","payment_method_title","logUserActivity","activity","activityEntry","customerResult","customer","isPublic","wooAddress","address_1","address_2","CreateReviewSchema","review","reviewer","reviewer_email","parent_id","ReviewService","rateLimitStore","totalReviews","reviews","ratingDistribution","calculateRatingDistribution","averageRating","average","reviewId","create","reviewData","validateReview","rateLimitCheck","processedImages","imageResult","processReviewImages","reviewPayload","sanitizeContent","requiresModeration","createdReview","attachImagesToReview","invalidateReviewCaches","trackReviewEvent","hasImages","update","existingReview","updatePayload","updatedReview","updateReviewImages","force","getProductReviews","getAnalytics","period","reviewsResult","verifiedReviews","verified","reviewsWithReplies","replies","totalHelpfulVotes","helpful_votes","previousPeriodData","getPreviousPeriodData","verifiedPurchaseRatio","responseRate","helpfulnessRatio","recentTrend","reviewCount","ratingChange","topKeywords","extractTopKeywords","voteHelpful","voteType","userEmail","getUserVote","votePayload","review_id","vote_type","user_email","voted_at","moderate","updateResult","moderation","moderated_at","automated","applyFilterToParams","primarySort","ratings","after","before","distribution","percentage","ZodError","spamScore","calculateSpamScore","containsProfanity","canSubmit","userKey","userLimit","hourInMs","resetTime","content","suspiciousPatterns","lowerContent","word","cacheKeys","deletePattern","BaseAddressSchema","BillingAddressSchema","extend","ShippingAddressSchema","regex","expiryMonth","int","expiryYear","getFullYear","cvv","holderName","feesTax","validate","COUNTRY_CONFIGS","postcodePattern","stateRequired","postcodeRequired","phonePattern","JP","BR","IN","NL","AddressManager","customCountryConfigs","countryConfigs","validateAddressWithContext","countryConfig","fieldRequirements","buildFieldRequirements","validateRequiredFields","validateFieldFormats","getFieldRequirements","countryCode","checkoutRules","isFieldRequired","fieldName","addressType","isGuestCheckout","validateBillingAddress","validateShippingAddress","addressesEqual","suggestAddressCorrection","suggestedAddress","capitalizeWords","formatPostcode","getCountryConfig","getSupportedCountries","setCountryConfig","parseAddress","rawData","billingAddress","billingValidation","createValidationError","shippingAddress","shippingValidation","baseAddress","validateBaseAddress","baseValidation","convertToBillingAddress","convertToShippingAddress","baseRequirements","overrides","requirements","char","cleaned","ShippingService","getShippingRates","isShippingAvailable","destination","cachedRates","cartItems","cart_total","responseData","shippingResponse","rates","zones","defaultRate","default_rate","freeShippingThreshold","free_shipping_threshold","estimatedDelivery","estimated_delivery","getShippingZones","cachedZones","method_id","methodId","zone_id","zoneId","shippingCost","trackingAvailable","tracking_available","checkFreeShipping","getCheapestRate","cheapest","current","getFastestRate","priorityOrder","methodType","rate","filterRatesByMethod","groupRatesByZone","grouped","zone","methods","validateShippingSelection","availableRates","updateOrderTotalsWithShipping","currentTotals","shippingCalculation","estimateDeliveryDate","deliveryMatch","minDays","maxDays","isBusinessDays","deliveryDate","daysToAdd","addedDays","setDate","getDate","getDay","clearShippingCache","invalidatePattern","Buffer","DEFAULT_SHIPPING_CONFIG","PaymentService","getAvailablePaymentMethods","paymentResponse","availableMethods","payment_gateways","defaultMethod","default_gateway","minimumAmounts","minimum_amounts","initializePayment","methodsResult","m","paymentMethodId","return_url","cancel_url","paymentId","payment_id","redirectUrl","redirect_url","requiresRedirect","requires_redirect","clientSecret","client_secret","paymentIntentId","payment_intent_id","instructions","expires_at","checkPaymentStatus","transactionId","transaction_id","failureReason","failure_reason","nextAction","next_action","handlePaymentCallback","callbackData","verifyCallbackSignature","cancelPayment","validatePaymentMethod","methodMinimum","title","generateRedirectUrl","searchParams","parseCallbackUrl","callbackUrl","getPaymentMethodDisplay","icon","acceptedCards","filterPaymentMethods","criteria","supportedCountries","supportedCurrencies","clearPaymentCache","DEFAULT_PAYMENT_CONFIG","CheckoutValidationService","addressManager","shippingService","paymentService","validateCheckout","validationResults","criticalErrors","blockers","recommendations","billingResult","checkoutSession","useShippingAsBilling","shippingResult","selectedShippingMethod","shippingMethodResult","validateShippingMethod","selectedPaymentMethod","paymentResult","totalsResult","validateOrderTotals","allValid","every","hasAddressErrors","component","hasPaymentErrors","hasStockErrors","generateRecommendations","canProceed","addressContext","requireEmail","ratesResult","maximumOrderAmount","actualTotal","validateStep","flatMap","validateField","billingCountry","ValidationRuleBuilder","rules","required","fields","CheckoutFlowManager","validationService","generateSessionId","flowState","initializeFlowState","initializeCheckout","session","cartId","orderTotals","createEmptyCheckoutFlow","currentStep","completedSteps","availableSteps","buildAvailableSteps","canGoBack","nextStep","validateCurrentStep","newStep","previousStep","completeCheckout","onStepChange","onStepComplete","goToStep","targetStep","updateSession","skipOptionalValidations","onValidationError","createOrder","createdOrder","paymentInit","paymentStatus","onCheckoutComplete","woError","onCheckoutError","getFlowState","getCurrentStep","stepIndex","isStepCompleted","resetFlow","clearPersistedSession","orderNotes","termsAccepted","newsletterOptIn","progress","completed","generateOrderId","shippingMethod","lineItems","paymentRequest","DEFAULT_CHECKOUT_FLOW_CONFIG","OrderProcessingService","validateOrderCreation","inventoryResult","reserveInventory","orderData","buildOrderData","releaseInventory","mapOrderResponse","updateInventory","operation","requiresPayment","paymentUrl","payment_url","confirmationUrl","getOrder","updateOrderStatus","customer_note","note","notify_customer","notifyCustomer","confirmOrder","date_paid","payment_status","confirmedOrder","sendOrderConfirmationEmail","cancelOrder","cancelledOrder","searchOrders","customerEmail","customer_email","dateFrom","dateTo","orders","filteredOrders","getOrderNotes","addOrderNote","customerNote","generateOrderNumber","orderNumberSuffix","set_paid","mapAddressForAPI","variation_id","shipping_lines","method_title","line_items_subtotal","shipping_tax","discount_total","fee_total","fee_tax","mapAddressFromAPI","DEFAULT_ORDER_PROCESSING_CONFIG","CheckoutService","flowManager","orderProcessingService","flowConfig","startStep","getCurrentState","currentState","orderRequest","orderResponse","getAddressFieldRequirements","getAddressSuggestions","shippingDestination","getPaymentMethods","confirmOrderPayment","resetCheckout","resetResult","canProceedToNextStep","getConfiguration","updateConfiguration","configResult","authManager","cacheManager","authHeaders","basicAuth","user","getConfig","getAuth","getCache","getHttpClient","clearCache","getCacheStats","updateConfig","newConfig","healthCheck","fn","defaultValue"],"mappings":"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"}